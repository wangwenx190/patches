From 58bedfb886f87395db5c0f04aa1d34d06f212c2e Mon Sep 17 00:00:00 2001
From: Yuhang Zhao <2546789017@qq.com>
Date: Fri, 17 Jun 2022 20:33:03 +0800
Subject: [PATCH] wangwenx190: Custom tweaks

Important changes list:

01. Win32: Remove WS_POPUP for most cases.
02. Win32: Remove UI Automation wrapper layer.
03. Win32: Disable the Direct2D QPA, it's useless and has bad performance.
04. Disable the offscreen QPA, it's useless.
05. Disable the minimal QPA, it's useless.
06. Win32: Add more entries to QOperatingSystemVersion.
07. Win32: Add environment variable to add offset to the system menu.
08. Win32: Add environment variable to disable bitmap redirection.
09. Win32: Restore Windows 7 RTM compatibility (QtMutex & QtRhi & QPA).
10. MSVC: Add support for VC-LTL (reduce final binary size).
11. MSVC: Add support for YY-Thunks (can help Qt run on Windows Vista RTM).
12. 3rd-party: Include some useful patches from the Telegram team.
13. Other minor tweaks.

Signed-off-by: Yuhang Zhao <2546789017@qq.com>
---
 build-test.bat                                |   27 +
 cmake/FindLCMS2.cmake                         |   78 +
 cmake/QtBaseGlobalTargets.cmake               |    2 +
 cmake/QtBuild.cmake                           |    9 +
 cmake/QtCompilerOptimization.cmake            |   15 +-
 cmake/QtInternalTargets.cmake                 |   60 +-
 cmake/VC-LTL.cmake                            |   94 +
 cmake/YY-Thunks.cmake                         |   90 +
 configure.cmake                               |   10 +
 qt_cmdline.cmake                              |    2 +
 src/corelib/CMakeLists.txt                    |   10 +-
 src/corelib/global/qlibraryinfo.cpp           |   20 +-
 src/corelib/global/qlibraryinfo.h             |    5 +
 .../global/qoperatingsystemversion.cpp        |   10 +
 src/corelib/global/qoperatingsystemversion.h  |   40 +
 .../global/qoperatingsystemversion_win.cpp    |   20 +-
 src/corelib/global/qsysinfo.cpp               |   34 +-
 src/corelib/io/qfilesystemengine_win.cpp      |  108 +-
 src/corelib/io/qfilesystemiterator_win.cpp    |    6 +-
 src/corelib/io/qlockfile_win.cpp              |   14 +-
 src/corelib/io/qstandardpaths_win.cpp         |    4 +
 src/corelib/kernel/qcoreapplication.cpp       |   39 +
 src/corelib/kernel/qeventdispatcher_win.cpp   |   77 +-
 src/corelib/kernel/qeventdispatcher_win_p.h   |    2 +
 src/corelib/kernel/qfunctions_win.cpp         |   10 +-
 src/corelib/plugin/qsystemlibrary.cpp         |   46 +-
 src/corelib/text/qlocale_win.cpp              |   23 +-
 src/corelib/thread/qfutex_p.h                 |   76 +-
 src/corelib/thread/qlocking_p.h               |    7 +-
 src/corelib/thread/qmutex.cpp                 |    2 +
 src/corelib/thread/qmutex_p.h                 |    9 +-
 src/corelib/thread/qmutex_win.cpp             |   30 +
 src/corelib/thread/qwaitcondition_p.h         |    7 +-
 src/gui/CMakeLists.txt                        |   34 +-
 src/gui/configure.cmake                       |    8 +
 src/gui/image/qimage.cpp                      |   77 +-
 src/gui/image/qimagereader.cpp                |    1 +
 src/gui/kernel/qhighdpiscaling.cpp            |    4 +-
 src/gui/kernel/qopenglcontext.cpp             |   30 +-
 src/gui/opengl/qopengl.cpp                    |   32 +-
 src/gui/painting/qpainter.cpp                 |  119 +-
 src/gui/rhi/qrhid3d11.cpp                     |  538 +-
 src/gui/rhi/qrhid3d11_p_p.h                   |    3 +-
 src/gui/rhi/qrhid3d12.cpp                     | 6079 +++++++++++++++++
 src/gui/text/qtextcursor.cpp                  |    6 +
 src/gui/text/qtextengine.cpp                  |   71 +-
 src/gui/text/qtextengine_p.h                  |    2 +
 src/gui/text/qtextlayout.cpp                  |   11 +
 .../qwindowsdirectwritefontdatabase.cpp       |    6 +-
 src/gui/text/windows/qwindowsfontdatabase.cpp |    3 +-
 .../text/windows/qwindowsfontdatabasebase.cpp |   21 +-
 .../windows/qwindowsfontenginedirectwrite.cpp |    9 +-
 .../socket/qnativesocketengine_win.cpp        |   21 +-
 src/openglwidgets/qopenglwidget.cpp           |   41 +-
 .../imageformats/jpeg/qjpeghandler.cpp        |    3 +
 .../qnetworklistmanagerevents.cpp             |   54 +-
 src/plugins/platforms/CMakeLists.txt          |    9 -
 src/plugins/platforms/windows/CMakeLists.txt  |    6 +-
 .../platforms/windows/qwin10helpers.cpp       |   43 +-
 .../platforms/windows/qwindowscontext.cpp     |  401 +-
 .../platforms/windows/qwindowscontext.h       |  137 +-
 .../windows/qwindowsdialoghelpers.cpp         |    3 +-
 .../platforms/windows/qwindowsdrag.cpp        |    7 +-
 .../platforms/windows/qwindowsintegration.cpp |   25 +-
 .../platforms/windows/qwindowskeymapper.cpp   |   18 +-
 .../windows/qwindowsmousehandler.cpp          |   11 +-
 .../windows/qwindowsopengltester.cpp          |    6 +-
 .../windows/qwindowspointerhandler.cpp        |   25 +-
 .../platforms/windows/qwindowsscreen.cpp      |   71 +-
 .../platforms/windows/qwindowsservices.cpp    |    4 +
 .../windows/qwindowssystemtrayicon.cpp        |    8 +-
 .../platforms/windows/qwindowstheme.cpp       |  146 +-
 .../platforms/windows/qwindowswindow.cpp      |  149 +-
 .../uiautomation/qwindowsuiaaccessibility.cpp |    9 +-
 .../uiautomation/qwindowsuiabaseprovider.h    |    4 +-
 .../uiautomation/qwindowsuiamainprovider.cpp  |   53 +-
 .../windows/uiautomation/qwindowsuiautils.h   |    2 +-
 .../windowsvista/qwindowsvistastyle.cpp       |   31 +
 .../windowsvista/qwindowsvistastyle_p_p.h     |    1 +
 src/tools/rcc/main.cpp                        |    7 +-
 src/tools/rcc/rcc.cpp                         |    8 +-
 src/widgets/CMakeLists.txt                    |    1 -
 src/widgets/dialogs/qwizard_win.cpp           |   55 +-
 src/widgets/kernel/qwidget.cpp                |   18 +
 src/widgets/widgets/qabstractscrollarea.cpp   |    7 +-
 85 files changed, 8696 insertions(+), 728 deletions(-)
 create mode 100644 build-test.bat
 create mode 100644 cmake/FindLCMS2.cmake
 create mode 100644 cmake/VC-LTL.cmake
 create mode 100644 cmake/YY-Thunks.cmake
 create mode 100644 src/corelib/thread/qmutex_win.cpp
 create mode 100644 src/gui/rhi/qrhid3d12.cpp

diff --git a/build-test.bat b/build-test.bat
new file mode 100644
index 0000000000..03cc233d9a
--- /dev/null
+++ b/build-test.bat
@@ -0,0 +1,27 @@
+@echo on
+setlocal
+call "%ProgramFiles%\Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build\vcvars64.bat"
+cd /d "%~dp0"
+if exist build-test rd /s /q build-test
+md build-test
+cd build-test
+md cmake
+cd cmake
+:: -DINPUT_mimetype_database_compression=zstd -DQT_DISABLE_DEPRECATED_UP_TO=0x070000
+set __common_flags=-Wno-dev -DCMAKE_MESSAGE_LOG_LEVEL=STATUS -DQT_BUILD_TESTS=OFF -DQT_BUILD_EXAMPLES=OFF -DFEATURE_relocatable=ON -DFEATURE_system_zlib=OFF -DINPUT_intelcet=yes -DINPUT_spectre=yes -DINPUT_ehcont=yes
+cmake %__common_flags% -DCMAKE_INSTALL_PREFIX="%~dp0build-test\shared" -DCMAKE_CONFIGURATION_TYPES=Release;Debug -DCMAKE_INTERPROCEDURAL_OPTIMIZATION_RELEASE=ON -DBUILD_SHARED_LIBS=ON -G"Ninja Multi-Config" "%~dp0"
+cmake --build . --parallel
+ninja install
+cd ..
+rd /s /q cmake
+md cmake
+cd cmake
+cmake %__common_flags% -DCMAKE_INSTALL_PREFIX="%~dp0build-test\static" -DCMAKE_BUILD_TYPE=Release -DCMAKE_INTERPROCEDURAL_OPTIMIZATION_RELEASE=OFF -DBUILD_SHARED_LIBS=OFF -GNinja "%~dp0"
+cmake --build . --parallel
+cmake --install .
+cd ..
+rd /s /q cmake
+endlocal
+cd /d "%~dp0"
+pause
+exit /b 0
diff --git a/cmake/FindLCMS2.cmake b/cmake/FindLCMS2.cmake
new file mode 100644
index 0000000000..fd32d9a783
--- /dev/null
+++ b/cmake/FindLCMS2.cmake
@@ -0,0 +1,78 @@
+# - Find LCMS2
+# Find the LCMS2 includes and library
+# This module defines
+#  LCMS2_INCLUDE_DIR, where to find lcms.h
+#  LCMS2_LIBRARIES, the libraries needed to use LCMS2.
+#  LCMS2_VERSION, The value of LCMS_VERSION defined in lcms.h
+#  LCMS2_FOUND, If false, do not try to use LCMS2.
+
+
+# Copyright (c) 2008, Adrian Page, <adrian@pagenet.plus.com>
+# Copyright (c) 2009, Cyrille Berger, <cberger@cberger.net>
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+if(TARGET LCMS2::LCMS2)
+    set(LCMS2_FOUND TRUE)
+    return()
+endif()
+
+# use pkg-config to get the directories and then use these values
+# in the FIND_PATH() and FIND_LIBRARY() calls
+if(NOT WIN32)
+   find_package(PkgConfig)
+   pkg_check_modules(PC_LCMS2 lcms2)
+   set(LCMS2_DEFINITIONS ${PC_LCMS2_CFLAGS_OTHER})
+endif()
+
+find_path(LCMS2_INCLUDE_DIR lcms2.h
+   PATHS
+   ${PC_LCMS2_INCLUDEDIR}
+   ${PC_LCMS2_INCLUDE_DIRS}
+   PATH_SUFFIXES lcms2 liblcms2
+)
+
+find_library(LCMS2_LIBRARIES NAMES lcms2 liblcms2 lcms-2 liblcms-2
+   PATHS
+   ${PC_LCMS2_LIBDIR}
+   ${PC_LCMS2_LIBRARY_DIRS}
+   PATH_SUFFIXES lcms2
+)
+
+if(LCMS2_INCLUDE_DIR AND LCMS2_LIBRARIES)
+   set(LCMS2_FOUND TRUE)
+else()
+   set(LCMS2_FOUND FALSE)
+endif()
+
+if(LCMS2_FOUND)
+   file(READ ${LCMS2_INCLUDE_DIR}/lcms2.h LCMS2_VERSION_CONTENT)
+   string(REGEX MATCH "#define LCMS_VERSION[ ]*[0-9]*\n" LCMS2_VERSION_MATCH ${LCMS2_VERSION_CONTENT})
+   if(LCMS2_VERSION_MATCH)
+      string(REGEX REPLACE "#define LCMS_VERSION[ ]*([0-9]*)\n" "\\1" LCMS2_VERSION ${LCMS2_VERSION_MATCH})
+      if(NOT LCMS2_FIND_QUIETLY)
+         string(SUBSTRING ${LCMS2_VERSION} 0 1 LCMS2_MAJOR_VERSION)
+         string(SUBSTRING ${LCMS2_VERSION} 1 2 LCMS2_MINOR_VERSION)
+         message(STATUS "Found lcms version ${LCMS2_MAJOR_VERSION}.${LCMS2_MINOR_VERSION}, ${LCMS2_LIBRARIES}")
+      endif()
+   else()
+      if(NOT LCMS2_FIND_QUIETLY)
+         message(STATUS "Found lcms2 but failed to find version ${LCMS2_LIBRARIES}")
+      endif()
+      set(LCMS2_VERSION NOTFOUND)
+   endif()
+   add_library(LCMS2::LCMS2 INTERFACE IMPORTED)
+   target_link_libraries(LCMS2::LCMS2 INTERFACE ${LCMS2_LIBRARIES})
+   target_include_directories(LCMS2::LCMS2 INTERFACE ${LCMS2_INCLUDE_DIR})
+else()
+   if(NOT LCMS2_FIND_QUIETLY)
+      if(LCMS2_FIND_REQUIRED)
+         message(FATAL_ERROR "Required package lcms2 NOT found")
+      else()
+         message(STATUS "lcms2 NOT found")
+      endif()
+   endif()
+endif()
+
+mark_as_advanced(LCMS2_INCLUDE_DIR LCMS2_LIBRARIES LCMS2_VERSION)
diff --git a/cmake/QtBaseGlobalTargets.cmake b/cmake/QtBaseGlobalTargets.cmake
index e8d3100681..f80942e8a1 100644
--- a/cmake/QtBaseGlobalTargets.cmake
+++ b/cmake/QtBaseGlobalTargets.cmake
@@ -287,6 +287,8 @@ qt_copy_or_install(FILES
                    cmake/QtWasmHelpers.cmake
                    cmake/QtWrapperScriptHelpers.cmake
                    cmake/QtWriteArgsFile.cmake
+                   cmake/VC-LTL.cmake
+                   cmake/YY-Thunks.cmake
                    cmake/modulecppexports.h.in
                    cmake/modulecppexports_p.h.in
                    cmake/qbatchedtestrunner.in.cpp
diff --git a/cmake/QtBuild.cmake b/cmake/QtBuild.cmake
index 1469abf176..56df58eb44 100644
--- a/cmake/QtBuild.cmake
+++ b/cmake/QtBuild.cmake
@@ -578,3 +578,12 @@ _qt_internal_generate_tool_command_wrapper()
 if(CMAKE_VERSION VERSION_LESS "3.19.0")
     variable_watch(CMAKE_CURRENT_LIST_DIR qt_watch_current_list_dir)
 endif()
+
+if(MSVC)
+    include(VC-LTL)
+    if("x${SupportLTL}" STREQUAL "xtrue")
+        set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>" CACHE STRING "" FORCE)
+    endif()
+    set(YYTHUNKS_TARGET_OS "WinXP" CACHE STRING "" FORCE)
+    include(YY-Thunks)
+endif()
diff --git a/cmake/QtCompilerOptimization.cmake b/cmake/QtCompilerOptimization.cmake
index b5b49ab78a..2a756b229b 100644
--- a/cmake/QtCompilerOptimization.cmake
+++ b/cmake/QtCompilerOptimization.cmake
@@ -92,10 +92,15 @@ endif()
 
 # Windows MSVC
 if(MSVC)
-    set(QT_CFLAGS_OPTIMIZE "-O2")
-    set(QT_CFLAGS_OPTIMIZE_DEBUG "-Od")
-    set(QT_CFLAGS_OPTIMIZE_SIZE "-O1")
-    set(QT_CFLAGS_OPTIMIZE_VALID_VALUES "/O2" "/O1" "/Od" "/Ob0" "/Ob1" "/Ob2" "/O0" "-O0")
+    set(QT_CFLAGS_OPTIMIZE "-O2 -Oi -Oy -Ot")
+    if(MSVC_VERSION GREATER_EQUAL 1920) # Visual Studio 2019 version 16.0
+        string(APPEND QT_CFLAGS_OPTIMIZE " -Ob3 ")
+    else()
+        string(APPEND QT_CFLAGS_OPTIMIZE " -Ob2 ")
+    endif()
+    set(QT_CFLAGS_OPTIMIZE_DEBUG "-Od -Ob0")
+    set(QT_CFLAGS_OPTIMIZE_SIZE "-O1 -Ob2 -Oi- -Os")
+    set(QT_CFLAGS_OPTIMIZE_VALID_VALUES "/O2" "/O1" "/Od" "/Ob0" "/Ob1" "/Ob2" "/Ob3" "/O0" "-O0")
 
     if(CLANG)
         set(QT_CFLAGS_OPTIMIZE_FULL "/clang:-O3")
@@ -124,5 +129,5 @@ endif()
 # Emscripten Clang
 if(WASM)
     set(QT_CFLAGS_OPTIMIZE_DEBUG "-O2 -g") # -Og is not supported
-    set(QT_CFLAGS_SSE2 -O2 -msimd128 -msse -msse2)
+    set(QT_CFLAGS_SSE2 "-O2 -msimd128 -msse -msse2")
 endif()
diff --git a/cmake/QtInternalTargets.cmake b/cmake/QtInternalTargets.cmake
index dc45b57eec..44807d6fcc 100644
--- a/cmake/QtInternalTargets.cmake
+++ b/cmake/QtInternalTargets.cmake
@@ -245,6 +245,9 @@ if (MSVC)
             -Zc:referenceBinding
             -Zc:ternary
         )
+        target_link_options(PlatformCommonInternal INTERFACE 
+            -DEPENDENTLOADFLAG:0x800
+        )
     endif()
     if (MSVC_VERSION GREATER_EQUAL 1919 AND NOT CLANG) # MSVC 2019
         target_compile_options(PlatformCommonInternal INTERFACE
@@ -253,6 +256,11 @@ if (MSVC)
             #-Zc:preprocessor # breaks build due to bug in default Windows SDK 10.0.19041
         )
     endif()
+    if (MSVC_VERSION GREATER_EQUAL 1925 AND NOT CLANG) # Visual Studio 2019 version 16.5
+        target_compile_options(PlatformCommonInternal INTERFACE
+            $<$<CONFIG:Release>:-QIntel-jcc-erratum>
+        )
+    endif()
 
     target_compile_options(PlatformCommonInternal INTERFACE
         -Zc:wchar_t
@@ -260,13 +268,19 @@ if (MSVC)
     )
 
     target_compile_options(PlatformCommonInternal INTERFACE
-        $<$<NOT:$<CONFIG:Debug>>:-guard:cf -Gw>
+        $<$<NOT:$<CONFIG:Debug>>:-fp:fast -guard:cf -GF -GT -Gw -Gy> # -GA for executables.
     )
 
     target_link_options(PlatformCommonInternal INTERFACE
         -DYNAMICBASE -NXCOMPAT -LARGEADDRESSAWARE
-        $<$<NOT:$<CONFIG:Debug>>:-OPT:REF -OPT:ICF -GUARD:CF>
+        $<$<NOT:$<CONFIG:Debug>>:-OPT:REF -OPT:ICF -OPT:LBR -GUARD:CF>
     )
+
+    if(TEST_architecture_arch STREQUAL "x86_64")
+        target_link_options(PlatformCommonInternal INTERFACE
+            -HIGHENTROPYVA
+        )
+    endif()
 endif()
 
 if(MINGW)
@@ -279,16 +293,50 @@ endif()
 
 if(QT_FEATURE_intelcet)
     if(MSVC)
-        target_link_options(PlatformCommonInternal INTERFACE
-            -CETCOMPAT
-        )
+        if(MSVC_VERSION GREATER_EQUAL 1920) # Visual Studio 2019 version 16.0
+            # wangwenx190: Enabling CET causes MOC fail to compile source files. Why ???
+            #[[target_link_options(PlatformCommonInternal INTERFACE
+                $<$<NOT:$<CONFIG:Debug>>:-CETCOMPAT>
+            )]]
+        endif()
     else()
         target_compile_options(PlatformCommonInternal INTERFACE
-            -fcf-protection=full
+            $<$<NOT:$<CONFIG:Debug>>:-fcf-protection=full>
         )
     endif()
 endif()
 
+if(QT_FEATURE_spectre)
+    if(MSVC)
+        if(MSVC_VERSION GREATER_EQUAL 1925) # Visual Studio 2019 version 16.5
+            target_compile_options(PlatformCommonInternal INTERFACE
+                -Qspectre-load
+            )
+        elseif(MSVC_VERSION GREATER_EQUAL 1912) # Visual Studio 2017 version 15.5
+            target_compile_options(PlatformCommonInternal INTERFACE
+                -Qspectre
+            )
+        endif()
+    else()
+        # TODO
+    endif()
+endif()
+
+if(QT_FEATURE_ehcont)
+    if(MSVC)
+        if(MSVC_VERSION GREATER_EQUAL 1927) # Visual Studio 2019 version 16.7
+            target_compile_options(PlatformCommonInternal INTERFACE
+                $<$<NOT:$<CONFIG:Debug>>:-guard:ehcont>
+            )
+            target_compile_options(PlatformCommonInternal INTERFACE
+                $<$<NOT:$<CONFIG:Debug>>:-guard:ehcont>
+            )
+        endif()
+    else()
+        # TODO
+    endif()
+endif()
+
 if(QT_FEATURE_force_asserts)
     target_compile_definitions(PlatformCommonInternal INTERFACE QT_FORCE_ASSERTS)
 endif()
diff --git a/cmake/VC-LTL.cmake b/cmake/VC-LTL.cmake
new file mode 100644
index 0000000000..2bab2f21d6
--- /dev/null
+++ b/cmake/VC-LTL.cmake
@@ -0,0 +1,94 @@
+﻿# https://github.com/Chuyu-Team/VC-LTL5
+
+#
+#  VC-LTL自动化加载配置，建议你将此文件单独复制到你的工程再使用，该文件能自动识别当前环境是否存在VC-LTL，并且自动应用。
+#
+#  使用方法：
+#    1. 在“CMakeLists.txt” 添加 “include("VC-LTL helper for cmake.cmake")”。
+#
+#  VC-LTL默认搜索顺序
+#    1. “VC-LTL helper for cmake.cmake”所在根目录，即 ${CMAKE_CURRENT_LIST_DIR}
+#    2. 当前CMake根目录，即 ${CMAKE_CURRENT_SOURCE_DIR}/VC-LTL
+#    3. 当前项目根目录，即 ${PROJECT_SOURCE_DIR}/VC-LTL
+#    4. 当前CMake父目录，即 ${CMAKE_CURRENT_SOURCE_DIR}/../VC-LTL
+#    5. 当前项目根目录，即 ${PROJECT_SOURCE_DIR}/../VC-LTL
+#    6. 注册表HKEY_CURRENT_USER\Code\VC-LTL@Root
+#
+#  把VC-LTL放在其中一个位置即可，VC-LTL就能被自动引用。
+#
+#  如果你对默认搜索顺序不满，你可以修改此文件。你也可以直接指定${VC_LTL_Root}宏更加任性的去加载VC-LTL。
+#
+
+if(NOT MSVC OR DEFINED __VC_LTL_CMAKE_INCLUDE_GUARD)
+    return()
+endif()
+set(__VC_LTL_CMAKE_INCLUDE_GUARD 1)
+
+#####################################################################VC-LTL设置#####################################################################
+
+#控制TargetPlatform版本，目前可用版本为5.1.2600.0     6.0.6000.0（默认）    6.2.9200.0     10.0.10240.0    10.0.19041.0
+if(NOT DEFINED WindowsTargetPlatformMinVersion)
+    set(WindowsTargetPlatformMinVersion "10.0.19041.0" CACHE STRING "" FORCE)
+endif()
+
+#启用干净的导入表，消除 ucrt apiset(如：api-ms-win-crt-time-l1-1-0.dll)，满足强迫症患者。
+if(NOT DEFINED CleanImport)
+    set(CleanImport "true" CACHE STRING "" FORCE)
+endif()
+
+####################################################################################################################################################
+
+if(NOT VC_LTL_Root)
+	if(EXISTS ${CMAKE_CURRENT_LIST_DIR}/_msvcrt.h)
+		set(VC_LTL_Root ${CMAKE_CURRENT_LIST_DIR})
+	endif()
+endif()
+
+if(NOT VC_LTL_Root)
+	if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/VC-LTL/_msvcrt.h)
+		set(VC_LTL_Root ${CMAKE_CURRENT_SOURCE_DIR}/VC-LTL)
+	endif()
+endif()
+
+if(NOT VC_LTL_Root)
+	if(EXISTS ${PROJECT_SOURCE_DIR}/VC-LTL/_msvcrt.h)
+        set(VC_LTL_Root ${PROJECT_SOURCE_DIR}/VC-LTL)
+    endif()
+endif()
+
+if(NOT VC_LTL_Root)
+	if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/../VC-LTL/_msvcrt.h)
+        set(VC_LTL_Root ${CMAKE_CURRENT_SOURCE_DIR}/../VC-LTL)
+    endif()
+endif()
+
+if(NOT VC_LTL_Root)
+	if(EXISTS ${PROJECT_SOURCE_DIR}/../VC-LTL/_msvcrt.h)
+        set(VC_LTL_Root ${PROJECT_SOURCE_DIR}/../VC-LTL)
+    endif()
+endif()
+
+if(NOT VC_LTL_Root)
+    EXECUTE_PROCESS(COMMAND reg query "HKEY_CURRENT_USER\\Code\\VC-LTL" -v "Root"
+                    OUTPUT_VARIABLE FOUND_FILE
+                    ERROR_VARIABLE ERROR_INFO
+                   )
+
+    string(REGEX MATCH "[a-zA-Z]:\\\\.+\\\\"
+           FOUND_LTL
+           ${FOUND_FILE})
+    if (NOT ${FOUND_LTL} STREQUAL "")
+        set(VC_LTL_Root ${FOUND_LTL})
+    endif()
+
+    if(NOT DEFINED VC_LTL_Root)
+        string(REGEX MATCH "\\\\\\\\.+\\\\" FOUND_LTL ${FOUND_FILE})
+        if (NOT ${FOUND_LTL} STREQUAL "")
+            set(VC_LTL_Root ${FOUND_LTL})
+        endif()
+    endif()
+endif()
+
+if(VC_LTL_Root)
+    include("${VC_LTL_Root}\\config\\config.cmake")
+endif()
diff --git a/cmake/YY-Thunks.cmake b/cmake/YY-Thunks.cmake
new file mode 100644
index 0000000000..92532d72dc
--- /dev/null
+++ b/cmake/YY-Thunks.cmake
@@ -0,0 +1,90 @@
+#[[
+  MIT License
+
+  Copyright (C) 2023 by wangwenx190 (Yuhang Zhao)
+
+  Permission is hereby granted, free of charge, to any person obtaining a copy
+  of this software and associated documentation files (the "Software"), to deal
+  in the Software without restriction, including without limitation the rights
+  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+  copies of the Software, and to permit persons to whom the Software is
+  furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included in
+  all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+  SOFTWARE.
+]]
+
+# https://github.com/Chuyu-Team/YY-Thunks
+
+if(NOT MSVC OR DEFINED __YY_THUNKS_CMAKE_INCLUDE_GUARD)
+    return()
+endif()
+set(__YY_THUNKS_CMAKE_INCLUDE_GUARD 1)
+
+if(NOT DEFINED YYTHUNKS_TARGET_OS)
+    set(YYTHUNKS_TARGET_OS "Vista" CACHE STRING "Supported values: Vista, WinXP" FORCE)
+endif()
+
+set(__yy_thunks_dir)
+if(DEFINED ENV{YYTHUNKS_INSTALL_DIR} AND EXISTS "$ENV{YYTHUNKS_INSTALL_DIR}")
+    set(__yy_thunks_dir "$ENV{YYTHUNKS_INSTALL_DIR}")
+else()
+    set(__yy_thunks_reg)
+    cmake_host_system_information(RESULT __yy_thunks_reg
+        QUERY WINDOWS_REGISTRY "HKCU/Code/YY-Thunks"
+        VALUE "Root")
+    if(__yy_thunks_reg AND EXISTS "${__yy_thunks_reg}")
+        set(__yy_thunks_dir "${__yy_thunks_reg}")
+    elseif(EXISTS "${CMAKE_CURRENT_LIST_DIR}/YY-Thunks")
+        set(__yy_thunks_dir "${CMAKE_CURRENT_LIST_DIR}/YY-Thunks")
+    elseif(EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/YY-Thunks")
+        set(__yy_thunks_dir "${CMAKE_CURRENT_SOURCE_DIR}/YY-Thunks")
+    elseif(EXISTS "${PROJECT_SOURCE_DIR}/YY-Thunks")
+        set(__yy_thunks_dir "${PROJECT_SOURCE_DIR}/YY-Thunks")
+    elseif(EXISTS "${CMAKE_SOURCE_DIR}/YY-Thunks")
+        set(__yy_thunks_dir "${CMAKE_SOURCE_DIR}/YY-Thunks")
+    elseif(EXISTS "${CMAKE_SOURCE_DIR}/../YY-Thunks")
+        set(__yy_thunks_dir "${CMAKE_SOURCE_DIR}/../YY-Thunks")
+    endif()
+endif()
+
+if(__yy_thunks_dir AND EXISTS "${__yy_thunks_dir}")
+    if(CMAKE_SIZEOF_VOID_P EQUAL 8)
+        set(__yy_thunks_arch x64)
+    else()
+        set(__yy_thunks_arch x86)
+    endif()
+    set(__yy_thunks_obj "${__yy_thunks_dir}/objs/${__yy_thunks_arch}/YY_Thunks_for_${YYTHUNKS_TARGET_OS}.obj")
+    if(EXISTS "${__yy_thunks_obj}")
+        set(YYTHUNKS_FOUND TRUE CACHE BOOL "" FORCE)
+        set(YYTHUNKS_INSTALL_DIR "${__yy_thunks_dir}" CACHE STRING "" FORCE)
+        set(YYTHUNKS_OBJ_PATH "${__yy_thunks_obj}" CACHE STRING "" FORCE)
+        add_link_options("${__yy_thunks_obj}")
+        message("###################################################################################################")
+        message("#                                                                                                 #")
+        message("#           ██    ██ ██    ██       ████████ ██   ██ ██    ██ ███    ██ ██   ██ ███████           #")
+        message("#            ██  ██   ██  ██           ██    ██   ██ ██    ██ ████   ██ ██  ██  ██                #")
+        message("#             ████     ████   █████    ██    ███████ ██    ██ ██ ██  ██ █████   ███████           #")
+        message("#              ██       ██             ██    ██   ██ ██    ██ ██  ██ ██ ██  ██       ██           #")
+        message("#              ██       ██             ██    ██   ██  ██████  ██   ████ ██   ██ ███████           #")
+        message("#                                                                                                 #")
+        message("###################################################################################################")
+        message("")
+        message(" YY-Thunks install dir     :" ${__yy_thunks_dir})
+        message(" YY-Thunks target platform :" ${YYTHUNKS_TARGET_OS})
+        message(" YY-Thunks obj file path   :" ${__yy_thunks_obj})
+        message("")
+    else()
+        message(WARNING "YY-Thunks's obj file is missing!")
+    endif()
+else()
+    message(WARNING "Can't locate the YY-Thunks installation directory!")
+endif()
diff --git a/configure.cmake b/configure.cmake
index 07a0b1836d..149b8abe87 100644
--- a/configure.cmake
+++ b/configure.cmake
@@ -1126,6 +1126,14 @@ qt_feature("intelcet" PRIVATE
     LABEL "Using Intel CET"
     CONDITION ( INPUT_intelcet STREQUAL yes ) OR TEST_intelcet
 )
+qt_feature("spectre" PRIVATE
+    LABEL "Mitigate Spectre issues"
+    CONDITION INPUT_spectre STREQUAL yes
+)
+qt_feature("ehcont" PRIVATE
+    LABEL "Ehcont guard"
+    CONDITION INPUT_ehcont STREQUAL yes
+)
 qt_configure_add_summary_build_type_and_config()
 qt_configure_add_summary_section(NAME "Build options")
 qt_configure_add_summary_build_mode(Mode)
@@ -1176,6 +1184,8 @@ qt_configure_add_summary_entry(ARGS "relocatable")
 qt_configure_add_summary_entry(ARGS "precompile_header")
 qt_configure_add_summary_entry(ARGS "ltcg")
 qt_configure_add_summary_entry(ARGS "intelcet")
+qt_configure_add_summary_entry(ARGS "spectre")
+qt_configure_add_summary_entry(ARGS "ehcont")
 qt_configure_add_summary_entry(
     ARGS "wasm-simd128"
     CONDITION ( TEST_architecture_arch STREQUAL wasm )
diff --git a/qt_cmdline.cmake b/qt_cmdline.cmake
index 5450b2562c..0bfc75636b 100644
--- a/qt_cmdline.cmake
+++ b/qt_cmdline.cmake
@@ -74,6 +74,8 @@ qt_commandline_option(openssl-runtime TYPE void NAME openssl VALUE runtime)
 qt_commandline_option(linker TYPE optionalString VALUES bfd gold lld mold)
 qt_commandline_option(ltcg TYPE boolean)
 qt_commandline_option(intelcet TYPE boolean)
+qt_commandline_option(spectre TYPE boolean)
+qt_commandline_option(ehcont TYPE boolean)
 # special case begin
 qt_commandline_option(make TYPE addString VALUES examples libs tests tools
                       benchmarks manual-tests minimal-static-tests)
diff --git a/src/corelib/CMakeLists.txt b/src/corelib/CMakeLists.txt
index 1a8cc08de5..74fa1a64f8 100644
--- a/src/corelib/CMakeLists.txt
+++ b/src/corelib/CMakeLists.txt
@@ -486,9 +486,8 @@ qt_internal_extend_target(Core CONDITION QT_FEATURE_animation
 # from the wrong DLL at runtime and crash!
 qt_internal_extend_target(Core CONDITION QT_FEATURE_thread AND WIN32
     SOURCES
+        thread/qmutex_win.cpp
         thread/qwaitcondition_win.cpp
-    LIBRARIES
-        synchronization
 )
 
 qt_internal_extend_target(Core CONDITION WIN32
@@ -754,12 +753,6 @@ qt_internal_extend_target(Core CONDITION WIN32
         text/qlocale_win.cpp
 )
 
-# On MS-Win, clang has two flavors, one of which immitates MSVC (so claims to be it)
-qt_internal_extend_target(Core CONDITION WIN32 AND MSVC AND NOT CLANG
-    LIBRARIES
-        runtimeobject
-)
-
 qt_internal_extend_target(Core CONDITION QT_FEATURE_icu
     SOURCES
         text/qcollator_icu.cpp
@@ -1269,6 +1262,7 @@ qt_internal_extend_target(Core CONDITION QT_FEATURE_ctf AND QT_FEATURE_library
 set_source_files_properties(
     thread/qmutex_mac.cpp
     thread/qmutex_unix.cpp
+    thread/qmutex_win.cpp
     PROPERTIES HEADER_FILE_ONLY ON)  # special case: These files are included by qmutex.cpp!
 
 set_source_files_properties(serialization/qcborstreamwriter.cpp # CBOR macro clashes
diff --git a/src/corelib/global/qlibraryinfo.cpp b/src/corelib/global/qlibraryinfo.cpp
index 715bda488c..6973de9d76 100644
--- a/src/corelib/global/qlibraryinfo.cpp
+++ b/src/corelib/global/qlibraryinfo.cpp
@@ -296,8 +296,13 @@ static QString prefixFromQtCoreLibraryHelper(const QString &qtCoreLibraryPath)
 {
     const QString qtCoreLibrary = QDir::fromNativeSeparators(qtCoreLibraryPath);
     const QString libDir = QFileInfo(qtCoreLibrary).absolutePath();
-    const QString prefixDir = libDir + "/" QT_CONFIGURE_LIBLOCATION_TO_PREFIX_PATH;
-    return QDir::cleanPath(prefixDir);
+    const QString prefix = libDir + "/";
+    return QDir::cleanPath([&prefix]() -> QString {
+        if (qEnvironmentVariableIntValue("QT_FORCE_LOAD_PLUGINS_FROM_CORE_DIR")) {
+            return prefix;
+        }
+        return prefix + QT_CONFIGURE_LIBLOCATION_TO_PREFIX_PATH;
+    }());
 }
 #endif
 
@@ -686,6 +691,17 @@ const char *qVersion() noexcept
     return QT_VERSION_STR;
 }
 
+/*!
+    A special function to identify this custom Qt build.
+    It will always return the magic number "2546789017"
+    as the result. It's my QQ number and you can contact
+    me by sending me an e-mail to "2546789017@qq.com".
+*/
+quint64 __wangwenx190__() noexcept
+{
+    return 2546789017;
+}
+
 #if QT_DEPRECATED_SINCE(6, 9)
 
 bool qSharedBuild() noexcept
diff --git a/src/corelib/global/qlibraryinfo.h b/src/corelib/global/qlibraryinfo.h
index d4e8f8b050..6cd0b448cf 100644
--- a/src/corelib/global/qlibraryinfo.h
+++ b/src/corelib/global/qlibraryinfo.h
@@ -61,6 +61,11 @@ Q_CORE_EXPORT Q_DECL_CONST_FUNCTION bool qSharedBuild() noexcept;
 
 #endif
 
+#if (!defined(QT_NAMESPACE) && defined(__cplusplus))
+extern "C"
+#endif
+Q_CORE_EXPORT Q_DECL_CONST_FUNCTION quint64 __wangwenx190__(void) noexcept;
+
 QT_END_NAMESPACE
 
 #endif // QLIBRARYINFO_H
diff --git a/src/corelib/global/qoperatingsystemversion.cpp b/src/corelib/global/qoperatingsystemversion.cpp
index c57483273f..a5aff6d0b6 100644
--- a/src/corelib/global/qoperatingsystemversion.cpp
+++ b/src/corelib/global/qoperatingsystemversion.cpp
@@ -361,6 +361,9 @@ bool QOperatingSystemVersionBase::isAnyOfType(std::initializer_list<OSType> type
 
 #ifndef QT_BOOTSTRAPPED
 
+const QOperatingSystemVersion QOperatingSystemVersion::WindowsVista =
+    QOperatingSystemVersion(QOperatingSystemVersion::Windows, 6, 0);
+
 /*!
     \variable QOperatingSystemVersion::Windows7
     \brief a version corresponding to Windows 7 (version 6.1).
@@ -393,6 +396,13 @@ const QOperatingSystemVersion QOperatingSystemVersion::Windows8_1 =
 const QOperatingSystemVersion QOperatingSystemVersion::Windows10 =
     QOperatingSystemVersion(QOperatingSystemVersion::Windows, 10);
 
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1507;
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1511;
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1607;
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1703;
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1709;
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1803;
+
 /*!
     \variable QOperatingSystemVersion::Windows10_1809
     \brief a version corresponding to Windows 10 October 2018 Update
diff --git a/src/corelib/global/qoperatingsystemversion.h b/src/corelib/global/qoperatingsystemversion.h
index 80a4cbbacb..fef7907459 100644
--- a/src/corelib/global/qoperatingsystemversion.h
+++ b/src/corelib/global/qoperatingsystemversion.h
@@ -123,6 +123,7 @@ public:
     // until Qt7
     // @note: New entries should be added after the if-def-ery until Qt 7!!
 #if QT_VERSION < QT_VERSION_CHECK(7, 0, 0) && !defined(QT_BOOTSTRAPPED)
+    static const QOperatingSystemVersion WindowsVista;
     static const QOperatingSystemVersion Windows7;
     static const QOperatingSystemVersion Windows8;
     static const QOperatingSystemVersion Windows8_1;
@@ -153,6 +154,7 @@ public:
     static const QOperatingSystemVersion Android10;
     static const QOperatingSystemVersion Android11;
 #else
+    static constexpr QOperatingSystemVersionBase WindowsVista { QOperatingSystemVersionBase::Windows, 6, 0 };
     static constexpr QOperatingSystemVersionBase Windows7 { QOperatingSystemVersionBase::Windows, 6, 1 };
     static constexpr QOperatingSystemVersionBase Windows8 { QOperatingSystemVersionBase::Windows, 6, 2 };
     static constexpr QOperatingSystemVersionBase Windows8_1 { QOperatingSystemVersionBase::Windows, 6, 3 };
@@ -184,6 +186,12 @@ public:
     static constexpr QOperatingSystemVersionBase Android11 { QOperatingSystemVersionBase::Android, 11, 0 };
 #endif // New (static constexpr) entries go here, only cherry-pick as far back as 6.3 (QTBUG-97808):
 
+    static constexpr QOperatingSystemVersionBase Windows10_1507 { QOperatingSystemVersionBase::Windows, 10, 0, 10240 }; // TH1
+    static constexpr QOperatingSystemVersionBase Windows10_1511 { QOperatingSystemVersionBase::Windows, 10, 0, 10586 }; // TH2
+    static constexpr QOperatingSystemVersionBase Windows10_1607 { QOperatingSystemVersionBase::Windows, 10, 0, 14393 }; // RS1
+    static constexpr QOperatingSystemVersionBase Windows10_1703 { QOperatingSystemVersionBase::Windows, 10, 0, 15063 }; // RS2
+    static constexpr QOperatingSystemVersionBase Windows10_1709 { QOperatingSystemVersionBase::Windows, 10, 0, 16299 }; // RS3
+    static constexpr QOperatingSystemVersionBase Windows10_1803 { QOperatingSystemVersionBase::Windows, 10, 0, 17134 }; // RS4
     static constexpr QOperatingSystemVersionBase Windows10_1809 { QOperatingSystemVersionBase::Windows, 10, 0, 17763 }; // RS5
     static constexpr QOperatingSystemVersionBase Windows10_1903 { QOperatingSystemVersionBase::Windows, 10, 0, 18362 }; // 19H1
     static constexpr QOperatingSystemVersionBase Windows10_1909 { QOperatingSystemVersionBase::Windows, 10, 0, 18363 }; // 19H2
@@ -202,6 +210,38 @@ public:
 
     static constexpr QOperatingSystemVersionBase MacOSVentura { QOperatingSystemVersionBase::MacOS, 13, 0 };
 
+#ifdef Q_OS_WINDOWS
+#  define MAKE_VERSION_FUNCTION(Name, Version) \
+    [[nodiscard]] static inline bool isWin##Name##OrGreater() \
+    { \
+        static const bool result = QOperatingSystemVersion::current() >= QOperatingSystemVersion::Windows##Version; \
+        return result; \
+    }
+    MAKE_VERSION_FUNCTION(Vista, Vista)
+    MAKE_VERSION_FUNCTION(7, 7)
+    MAKE_VERSION_FUNCTION(8, 8)
+    MAKE_VERSION_FUNCTION(8Point1, 8_1)
+    MAKE_VERSION_FUNCTION(10, 10)
+    MAKE_VERSION_FUNCTION(10TH1, 10_1507)
+    MAKE_VERSION_FUNCTION(10TH2, 10_1511)
+    MAKE_VERSION_FUNCTION(10RS1, 10_1607)
+    MAKE_VERSION_FUNCTION(10RS2, 10_1703)
+    MAKE_VERSION_FUNCTION(10RS3, 10_1709)
+    MAKE_VERSION_FUNCTION(10RS4, 10_1803)
+    MAKE_VERSION_FUNCTION(10RS5, 10_1809)
+    MAKE_VERSION_FUNCTION(1019H1, 10_1903)
+    MAKE_VERSION_FUNCTION(1019H2, 10_1909)
+    MAKE_VERSION_FUNCTION(1020H1, 10_2004)
+    MAKE_VERSION_FUNCTION(1020H2, 10_20H2)
+    MAKE_VERSION_FUNCTION(1021H1, 10_21H1)
+    MAKE_VERSION_FUNCTION(1021H2, 10_21H2)
+    MAKE_VERSION_FUNCTION(1022H2, 10_22H2)
+    MAKE_VERSION_FUNCTION(11, 11)
+    MAKE_VERSION_FUNCTION(1121H2, 11_21H2)
+    MAKE_VERSION_FUNCTION(1122H2, 11_22H2)
+#  undef MAKE_VERSION_FUNCTION
+#endif // Q_OS_WINDOWS
+
     constexpr QOperatingSystemVersion(const QOperatingSystemVersionBase &osversion)
         : QOperatingSystemVersionBase(osversion) {}
 
diff --git a/src/corelib/global/qoperatingsystemversion_win.cpp b/src/corelib/global/qoperatingsystemversion_win.cpp
index a209fb17b6..50edb719fd 100644
--- a/src/corelib/global/qoperatingsystemversion_win.cpp
+++ b/src/corelib/global/qoperatingsystemversion_win.cpp
@@ -51,7 +51,18 @@ OSVERSIONINFOEX qWindowsVersionInfo()
             result.wServicePackMinor = 0;
 
             const QByteArray winVerOverride = qgetenv("QT_WINVER_OVERRIDE");
-            if (winVerOverride == "WINDOWS10" || winVerOverride == "2016"
+            if (winVerOverride == "WINDOWSVISTA" || winVerOverride == "2008") {
+                result.dwMajorVersion = 6;
+            } else if (winVerOverride == "WINDOWS7" || winVerOverride == "2008_R2") {
+                result.dwMajorVersion = 6;
+                result.dwMinorVersion = 1;
+            } else if (winVerOverride == "WINDOWS8" || winVerOverride == "2012") {
+                result.dwMajorVersion = 6;
+                result.dwMinorVersion = 2;
+            } else if (winVerOverride == "WINDOWS8_1" || winVerOverride == "2012_R2") {
+                result.dwMajorVersion = 6;
+                result.dwMinorVersion = 3;
+            } else if (winVerOverride == "WINDOWS10" || winVerOverride == "2016"
                 || winVerOverride == "2019" || winVerOverride == "2022") {
                 result.dwMajorVersion = 10;
             } else if (winVerOverride == "WINDOWS11") {
@@ -61,7 +72,12 @@ OSVERSIONINFOEX qWindowsVersionInfo()
                 return realResult;
             }
 
-            if (winVerOverride == "2016" || winVerOverride == "2019"
+            if (winVerOverride == "2008"
+                || winVerOverride == "2008_R2"
+                || winVerOverride == "2012"
+                || winVerOverride == "2012_R2"
+                || winVerOverride == "2016"
+                || winVerOverride == "2019"
                 || winVerOverride == "2022") {
                 // If the current host OS is a domain controller and the override OS
                 // is also a server type OS, preserve that information
diff --git a/src/corelib/global/qsysinfo.cpp b/src/corelib/global/qsysinfo.cpp
index 3654b70984..00462cc1cf 100644
--- a/src/corelib/global/qsysinfo.cpp
+++ b/src/corelib/global/qsysinfo.cpp
@@ -165,12 +165,17 @@ static inline QString windowsDisplayVersion()
 {
     // https://tickets.puppetlabs.com/browse/FACT-3058
     // The "ReleaseId" key stopped updating since Windows 10 20H2.
-    if (QOperatingSystemVersion::current() >= QOperatingSystemVersion::Windows10_20H2)
+    if (QOperatingSystemVersion::isWin1020H2OrGreater())
         return readVersionRegistryString(L"DisplayVersion");
     else
         return readVersionRegistryString(L"ReleaseId");
 }
 
+static QString windows7Build()
+{
+    return readVersionRegistryString(L"CurrentBuild");
+}
+
 static QString winSp_helper()
 {
     const auto osv = qWindowsVersionInfo();
@@ -194,6 +199,14 @@ static const char *osVer_helper(QOperatingSystemVersion version = QOperatingSyst
 
 #define Q_WINVER(major, minor) (major << 8 | minor)
     switch (Q_WINVER(osver.dwMajorVersion, osver.dwMinorVersion)) {
+    case Q_WINVER(6, 0):
+        return workstation ? "Vista" : "Server 2008";
+    case Q_WINVER(6, 1):
+        return workstation ? "7" : "Server 2008 R2";
+    case Q_WINVER(6, 2):
+        return workstation ? "8" : "Server 2012";
+    case Q_WINVER(6, 3):
+        return workstation ? "8.1" : "Server 2012 R2";
     case Q_WINVER(10, 0):
         if (workstation) {
             if (osver.dwBuildNumber >= 22000)
@@ -885,10 +898,21 @@ QString QSysInfo::prettyProductName()
     return result + " ("_L1 + versionString + u')';
 #  else
     // (resembling winver.exe): Windows 10 "Windows 10 Version 1809"
-    const auto displayVersion = windowsDisplayVersion();
-    if (!displayVersion.isEmpty())
-        result += " Version "_L1 + displayVersion;
-    return result;
+    if (majorVersion >= 10) {
+        const auto displayVersion = windowsDisplayVersion();
+        if (!displayVersion.isEmpty())
+            result += " Version "_L1 + displayVersion;
+        return result;
+    }
+    // Windows 7: "Windows 7 Version 6.1 (Build 7601: Service Pack 1)"
+    result += " Version "_L1 + versionString + " ("_L1;
+    const auto build = windows7Build();
+    if (!build.isEmpty())
+        result += "Build "_L1 + build;
+    const auto servicePack = winSp_helper();
+    if (!servicePack.isEmpty())
+        result += ": "_L1 + servicePack;
+    return result + u')';
 #  endif // Windows
 #elif defined(Q_OS_HAIKU)
     return "Haiku "_L1 + productVersion();
diff --git a/src/corelib/io/qfilesystemengine_win.cpp b/src/corelib/io/qfilesystemengine_win.cpp
index 6d085d98c9..f39ac6af09 100644
--- a/src/corelib/io/qfilesystemengine_win.cpp
+++ b/src/corelib/io/qfilesystemengine_win.cpp
@@ -1027,7 +1027,10 @@ QByteArray QFileSystemEngine::id(const QFileSystemEntry &entry)
 //static
 QByteArray QFileSystemEngine::id(HANDLE fHandle)
 {
-    return fileIdWin8(HANDLE(fHandle));
+    if (QOperatingSystemVersion::isWin8OrGreater())
+        return fileIdWin8(HANDLE(fHandle));
+    else
+        return fileId(HANDLE(fHandle));
 }
 
 //static
@@ -1747,41 +1750,76 @@ bool QFileSystemEngine::moveFileToTrash(const QFileSystemEntry &source,
     // we need the "display name" of the file, so can't use nativeAbsoluteFilePath
     const QString sourcePath = QDir::toNativeSeparators(absoluteName(source).filePath());
 
-    QComHelper comHelper;
-
-    IFileOperation *pfo = nullptr;
-    IShellItem *deleteItem = nullptr;
-    FileOperationProgressSink *sink = nullptr;
-    HRESULT hres = E_FAIL;
-
-    auto coUninitialize = qScopeGuard([&](){
-        if (sink)
-            sink->Release();
-        if (deleteItem)
-            deleteItem->Release();
-        if (pfo)
-            pfo->Release();
+    /*
+        Windows 7 insists on showing confirmation dialogs and ignores the respective
+        flags set on IFileOperation. Fall back to SHFileOperation, even if it doesn't
+        give us the new location of the file.
+    */
+    if (QOperatingSystemVersion::isWin8OrGreater()) {
+        QComHelper comHelper;
+
+        IFileOperation *pfo = nullptr;
+        IShellItem *deleteItem = nullptr;
+        FileOperationProgressSink *sink = nullptr;
+        HRESULT hres = E_FAIL;
+
+        auto coUninitialize = qScopeGuard([&](){
+            if (sink)
+                sink->Release();
+            if (deleteItem)
+                deleteItem->Release();
+            if (pfo)
+                pfo->Release();
+            if (!SUCCEEDED(hres))
+                error = QSystemError(hres, QSystemError::NativeError);
+        });
+
+        hres = CoCreateInstance(CLSID_FileOperation, nullptr, CLSCTX_ALL, IID_PPV_ARGS(&pfo));
+        if (!pfo)
+            return false;
+        pfo->SetOperationFlags(FOF_ALLOWUNDO | FOFX_RECYCLEONDELETE | FOF_NOCONFIRMATION
+                            | FOF_SILENT | FOF_NOERRORUI);
+        hres = SHCreateItemFromParsingName(reinterpret_cast<const wchar_t*>(sourcePath.utf16()),
+                                        nullptr, IID_PPV_ARGS(&deleteItem));
+        if (!deleteItem)
+            return false;
+        sink = new FileOperationProgressSink;
+        hres = pfo->DeleteItem(deleteItem, static_cast<IFileOperationProgressSink*>(sink));
         if (!SUCCEEDED(hres))
-            error = QSystemError(hres, QSystemError::NativeError);
-    });
-
-    hres = CoCreateInstance(CLSID_FileOperation, nullptr, CLSCTX_ALL, IID_PPV_ARGS(&pfo));
-    if (!pfo)
-        return false;
-    pfo->SetOperationFlags(FOF_ALLOWUNDO | FOFX_RECYCLEONDELETE | FOF_NOCONFIRMATION
-                        | FOF_SILENT | FOF_NOERRORUI);
-    hres = SHCreateItemFromParsingName(reinterpret_cast<const wchar_t*>(sourcePath.utf16()),
-                                    nullptr, IID_PPV_ARGS(&deleteItem));
-    if (!deleteItem)
-        return false;
-    sink = new FileOperationProgressSink;
-    hres = pfo->DeleteItem(deleteItem, static_cast<IFileOperationProgressSink*>(sink));
-    if (!SUCCEEDED(hres))
-        return false;
-    hres = pfo->PerformOperations();
-    if (!SUCCEEDED(hres))
-        return false;
-    newLocation = QFileSystemEntry(sink->targetPath);
+            return false;
+        hres = pfo->PerformOperations();
+        if (!SUCCEEDED(hres))
+            return false;
+        newLocation = QFileSystemEntry(sink->targetPath);
+    } else {
+        // double null termination needed, so can't use QString::utf16
+        QVarLengthArray<wchar_t, MAX_PATH + 1> winFile(sourcePath.length() + 2);
+        sourcePath.toWCharArray(winFile.data());
+        winFile[sourcePath.length()] = wchar_t{};
+        winFile[sourcePath.length() + 1] = wchar_t{};
+
+        SHFILEOPSTRUCTW operation;
+        operation.hwnd = nullptr;
+        operation.wFunc = FO_DELETE;
+        operation.pFrom = winFile.constData();
+        operation.pTo = nullptr;
+        operation.fFlags = FOF_ALLOWUNDO | FOF_NO_UI;
+        operation.fAnyOperationsAborted = FALSE;
+        operation.hNameMappings = nullptr;
+        operation.lpszProgressTitle = nullptr;
+
+        int result = SHFileOperation(&operation);
+        if (result != 0) {
+            error = QSystemError(result, QSystemError::NativeError);
+            return false;
+        }
+        /*
+            This implementation doesn't let us know where the file ended up, even if
+            we would specify FOF_WANTMAPPINGHANDLE | FOF_RENAMEONCOLLISION, as
+            FOF_RENAMEONCOLLISION has no effect unless files are moved, copied, or renamed.
+        */
+        Q_UNUSED(newLocation);
+    }
 
     return true;
 }
diff --git a/src/corelib/io/qfilesystemiterator_win.cpp b/src/corelib/io/qfilesystemiterator_win.cpp
index 2c16cc7f6b..5be794920c 100644
--- a/src/corelib/io/qfilesystemiterator_win.cpp
+++ b/src/corelib/io/qfilesystemiterator_win.cpp
@@ -55,8 +55,10 @@ bool QFileSystemIterator::advance(QFileSystemEntry &fileEntry, QFileSystemMetaDa
         haveData = true;
         int infoLevel = 0 ;         // FindExInfoStandard;
         DWORD dwAdditionalFlags  = 0;
-        dwAdditionalFlags = 2;  // FIND_FIRST_EX_LARGE_FETCH
-        infoLevel = 1 ;         // FindExInfoBasic;
+        if (QOperatingSystemVersion::isWin7OrGreater()) {
+            dwAdditionalFlags = 2;  // FIND_FIRST_EX_LARGE_FETCH
+            infoLevel = 1 ;         // FindExInfoBasic;
+        }
         int searchOps =  0;         // FindExSearchNameMatch
         if (onlyDirs)
             searchOps = 1 ;         // FindExSearchLimitToDirectories
diff --git a/src/corelib/io/qlockfile_win.cpp b/src/corelib/io/qlockfile_win.cpp
index b9d7721517..33a4291035 100644
--- a/src/corelib/io/qlockfile_win.cpp
+++ b/src/corelib/io/qlockfile_win.cpp
@@ -13,8 +13,12 @@
 #include "QtCore/qdebug.h"
 #include "QtCore/qthread.h"
 
+#include <QtCore/private/qsystemlibrary_p.h>
+
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
 static inline bool fileExists(const wchar_t *fileName)
 {
     WIN32_FILE_ATTRIBUTE_DATA  data;
@@ -96,12 +100,16 @@ bool QLockFilePrivate::isProcessRunning(qint64 pid, const QString &appname)
 
 QString QLockFilePrivate::processNameByPid(qint64 pid)
 {
+    static const auto pGetModuleFileNameExW =
+        reinterpret_cast<decltype(&::GetModuleFileNameExW)>(
+            QSystemLibrary::resolve(u"psapi"_s, "GetModuleFileNameExW"));
+    if (!pGetModuleFileNameExW)
+        return QString();
     HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, DWORD(pid));
-    if (!hProcess) {
+    if (!hProcess)
         return QString();
-    }
     wchar_t buf[MAX_PATH];
-    const DWORD length = GetModuleFileNameExW(hProcess, NULL, buf, sizeof(buf) / sizeof(wchar_t));
+    const DWORD length = pGetModuleFileNameExW(hProcess, NULL, buf, sizeof(buf) / sizeof(wchar_t));
     CloseHandle(hProcess);
     if (!length)
         return QString();
diff --git a/src/corelib/io/qstandardpaths_win.cpp b/src/corelib/io/qstandardpaths_win.cpp
index 13b8fe224a..581e2695fe 100644
--- a/src/corelib/io/qstandardpaths_win.cpp
+++ b/src/corelib/io/qstandardpaths_win.cpp
@@ -10,6 +10,7 @@
 #include <qcoreapplication.h>
 #endif
 
+#include <qoperatingsystemversion.h>
 #include <qt_windows.h>
 #include <shlobj.h>
 #include <intshcut.h>
@@ -60,6 +61,9 @@ static inline void appendTestMode(QString &path)
 
 static bool isProcessLowIntegrity()
 {
+    if (!QOperatingSystemVersion::isWin8OrGreater())
+        return false;
+
     // same as GetCurrentProcessToken()
     const auto process_token = HANDLE(quintptr(-4));
 
diff --git a/src/corelib/kernel/qcoreapplication.cpp b/src/corelib/kernel/qcoreapplication.cpp
index 3feb4cf4c4..fdf474efeb 100644
--- a/src/corelib/kernel/qcoreapplication.cpp
+++ b/src/corelib/kernel/qcoreapplication.cpp
@@ -37,6 +37,7 @@
 #include <qelapsedtimer.h>
 #include <qlibraryinfo.h>
 #include <qvarlengtharray.h>
+#include <qoperatingsystemversion.h>
 #include <private/qfactoryloader_p.h>
 #include <private/qfunctions_p.h>
 #include <private/qlocale_p.h>
@@ -122,6 +123,10 @@ Q_TRACE_POINT(qtcore, QCoreApplication_sendSpontaneousEvent, QObject *receiver,
 Q_TRACE_POINT(qtcore, QCoreApplication_notify_entry, QObject *receiver, QEvent *event, QEvent::Type type);
 Q_TRACE_POINT(qtcore, QCoreApplication_notify_exit, bool consumed, bool filtered);
 
+#ifndef QT_BOOTSTRAPPED
+static constexpr const char kWwx190EnvVar[] = "__wangwenx190__";
+#endif
+
 #if defined(Q_OS_WIN) || defined(Q_OS_MAC)
 extern QString qAppFileName();
 #endif
@@ -460,6 +465,9 @@ QCoreApplicationPrivate::QCoreApplicationPrivate(int &aargc, char **aargv)
 
 QCoreApplicationPrivate::~QCoreApplicationPrivate()
 {
+#ifndef QT_BOOTSTRAPPED
+    qunsetenv(kWwx190EnvVar);
+#endif
 #ifndef QT_NO_QOBJECT
     cleanupThreadData();
 #endif
@@ -582,6 +590,33 @@ void QCoreApplicationPrivate::initConsole()
         // Unknown input, don't make any decision for the user.
         return;
     }
+    if (qEnvironmentVariableIntValue("QT_WIN_DEBUG_CONSOLE_USE_UTF8")) {
+        SetConsoleCP(CP_UTF8);
+        SetConsoleOutputCP(CP_UTF8);
+    }
+    if (consoleAllocated) {
+        SetConsoleTitleW([]() -> const wchar_t * {
+            const QString appName = QCoreApplication::applicationName();
+            if (appName.isEmpty())
+                return L"Qt debug window";
+            return reinterpret_cast<const wchar_t *>(
+                        (u"%1 debug window"_s.arg(appName)).utf16());
+        }());
+    }
+    if (QOperatingSystemVersion::isWin10OrGreater()) {
+        const auto enableVirtualTerminalProcessingForHandle =
+            [](const HANDLE handle) -> void {
+                if (!handle || handle == INVALID_HANDLE_VALUE)
+                    return;
+                DWORD mode = 0;
+                if (GetConsoleMode(handle, &mode) == FALSE)
+                    return;
+                mode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
+                SetConsoleMode(handle, mode);
+            };
+        enableVirtualTerminalProcessingForHandle(GetStdHandle(STD_OUTPUT_HANDLE));
+        enableVirtualTerminalProcessingForHandle(GetStdHandle(STD_ERROR_HANDLE));
+    }
     // The std{in,out,err} handles are read-only, so we need to pass in dummies.
     FILE *in = nullptr;
     FILE *out = nullptr;
@@ -828,6 +863,10 @@ void Q_TRACE_INSTRUMENT(qtcore) QCoreApplicationPrivate::init()
     Q_ASSERT_X(!QCoreApplication::self, "QCoreApplication", "there should be only one application object");
     QCoreApplication::self = q;
 
+#ifndef QT_BOOTSTRAPPED
+    qputenv(kWwx190EnvVar, QByteArray::number(__wangwenx190__()));
+#endif
+
 #if QT_CONFIG(thread)
 #ifdef Q_OS_WASM
     emscripten::val hardwareConcurrency = emscripten::val::global("navigator")["hardwareConcurrency"];
diff --git a/src/corelib/kernel/qeventdispatcher_win.cpp b/src/corelib/kernel/qeventdispatcher_win.cpp
index 1c54c97514..9452ddaeed 100644
--- a/src/corelib/kernel/qeventdispatcher_win.cpp
+++ b/src/corelib/kernel/qeventdispatcher_win.cpp
@@ -6,7 +6,6 @@
 
 #include "qcoreapplication.h"
 #include <private/qsystemlibrary_p.h>
-#include "qoperatingsystemversion.h"
 #include "qpair.h"
 #include "qset.h"
 #include "qsocketnotifier.h"
@@ -18,6 +17,8 @@
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
 #ifndef TIME_KILL_SYNCHRONOUS
 #  define TIME_KILL_SYNCHRONOUS 0x0100
 #endif
@@ -76,7 +77,17 @@ void WINAPI QT_WIN_CALLBACK qt_fast_timer_proc(uint timerId, uint /*reserved*/,
         return;
     auto t = reinterpret_cast<WinTimerInfo*>(user);
     Q_ASSERT(t);
-    QCoreApplication::postEvent(t->dispatcher, new QTimerEvent(t->timerId));
+    QMutexLocker lock(&t->fastTimerMutex);
+    if (t->timerId != -1) {
+        QCoreApplication::postEvent(t->dispatcher, new QTimerEvent(t->timerId));
+        return;
+    }
+    Q_ASSERT(!t->inTimerEvent);
+    Q_ASSERT(t->fastTimerId != 0);
+    timeKillEvent(t->fastTimerId);
+    lock.unlock();
+
+    delete t;
 }
 
 LRESULT QT_WIN_CALLBACK qt_internal_proc(HWND hwnd, UINT message, WPARAM wp, LPARAM lp)
@@ -346,17 +357,22 @@ void QEventDispatcherWin32Private::registerTimer(WinTimerInfo *t)
         // optimization for single-shot-zero-timer
         QCoreApplication::postEvent(q, new QZeroTimerEvent(t->timerId));
         ok = true;
-    } else if (tolerance == TIMERV_DEFAULT_COALESCING) {
+    } else if (interval < 1000u && tolerance == TIMERV_DEFAULT_COALESCING) {
         // 3/2016: Although MSDN states timeSetEvent() is deprecated, the function
         // is still deemed to be the most reliable precision timer.
         t->fastTimerId = timeSetEvent(interval, 1, qt_fast_timer_proc, DWORD_PTR(t),
                                       TIME_CALLBACK_FUNCTION | TIME_PERIODIC | TIME_KILL_SYNCHRONOUS);
-        ok = t->fastTimerId;
+        ok = (t->fastTimerId != 0);
     }
 
     if (!ok) {
-        // user normal timers for (Very)CoarseTimers, or if no more multimedia timers available
-        ok = SetCoalescableTimer(internalHwnd, t->timerId, interval, nullptr, tolerance);
+        static const auto pSetCoalescableTimer =
+            reinterpret_cast<decltype(&::SetCoalescableTimer)>(
+                QSystemLibrary::resolve(u"user32"_s, "SetCoalescableTimer"));
+        if (pSetCoalescableTimer) {
+            // user normal timers for (Very)CoarseTimers, or if no more multimedia timers available
+            ok = pSetCoalescableTimer(internalHwnd, t->timerId, interval, nullptr, tolerance);
+        }
     }
     if (!ok)
         ok = SetTimer(internalHwnd, t->timerId, interval, nullptr);
@@ -367,16 +383,34 @@ void QEventDispatcherWin32Private::registerTimer(WinTimerInfo *t)
 
 void QEventDispatcherWin32Private::unregisterTimer(WinTimerInfo *t)
 {
+    const auto tTimerId = t->timerId;
+    const auto tDispatcher = t->dispatcher;
+    const auto tUseFastTimer = (t->fastTimerId != 0);
+    const auto tDelete = (!tUseFastTimer && !t->inTimerEvent);
     if (t->interval == 0) {
-        QCoreApplicationPrivate::removePostedTimerEvent(t->dispatcher, t->timerId);
-    } else if (t->fastTimerId != 0) {
-        timeKillEvent(t->fastTimerId);
-        QCoreApplicationPrivate::removePostedTimerEvent(t->dispatcher, t->timerId);
+        QCoreApplicationPrivate::removePostedTimerEvent(tDispatcher, tTimerId);
+    } else if (tUseFastTimer) {
+        // 't' will be deleted in the next qt_fast_timer_proc.
+        // timeKillEvent(t->fastTimerId);
     } else {
-        KillTimer(internalHwnd, t->timerId);
+        KillTimer(internalHwnd, tTimerId);
+    }
+    if (tUseFastTimer && !t->inTimerEvent) {
+        // sendTimerEvent locks the mutex in case of t->inTimerEvent.
+        t->fastTimerMutex.lock();
     }
+    // Upon fastTimerMutex unlock qt_fast_timer_proc may delete 't'.
     t->timerId = -1;
-    if (!t->inTimerEvent)
+    if (tUseFastTimer) {
+        if (!t->inTimerEvent) {
+            // sendTimerEvent unlocks the mutex in case of t->inTimerEvent.
+            // Right after that line qt_fast_timer_proc may delete 't'.
+            t->fastTimerMutex.unlock();
+        }
+        QCoreApplicationPrivate::removePostedTimerEvent(tDispatcher, tTimerId);
+    }
+
+    if (tDelete)
         delete t;
 }
 
@@ -391,14 +425,27 @@ void QEventDispatcherWin32Private::sendTimerEvent(int timerId)
         calculateNextTimeout(t, qt_msectime());
 
         QTimerEvent e(t->timerId);
+
+        const auto tUseFastTimer = (t->fastTimerId != 0);
+        if (tUseFastTimer) {
+            // sendEvent below may unregisterTimer,
+            // qt_fast_timer_proc should not delete 't' just yet.
+            t->fastTimerMutex.lock();
+        }
+
         QCoreApplication::sendEvent(t->obj, &e);
 
         // timer could have been removed
-        if (t->timerId == -1) {
+        if (t->timerId == -1 && !tUseFastTimer) {
             delete t;
         } else {
             t->inTimerEvent = false;
         }
+
+        if (tUseFastTimer) {
+            // Right after that line qt_fast_timer_proc may delete 't'.
+            t->fastTimerMutex.unlock();
+        }
     }
 }
 
@@ -858,7 +905,9 @@ bool QEventDispatcherWin32::event(QEvent *e)
 
             // timer could have been removed
             if (t->timerId == -1) {
-                delete t;
+                if (t->fastTimerId == 0) {
+                    delete t;
+                }
             } else {
                 if (t->interval == 0 && t->inTimerEvent) {
                     // post the next zero timer event as long as the timer was not restarted
diff --git a/src/corelib/kernel/qeventdispatcher_win_p.h b/src/corelib/kernel/qeventdispatcher_win_p.h
index ecd4bcb27b..febf45927c 100644
--- a/src/corelib/kernel/qeventdispatcher_win_p.h
+++ b/src/corelib/kernel/qeventdispatcher_win_p.h
@@ -19,6 +19,7 @@
 #include "QtCore/qt_windows.h"
 #include "QtCore/qhash.h"
 #include "QtCore/qatomic.h"
+#include "QtCore/qmutex.h"
 
 #include "qabstracteventdispatcher_p.h"
 
@@ -94,6 +95,7 @@ struct WinTimerInfo {                           // internal timer info
     QObject *obj;                               // - object to receive events
     bool inTimerEvent;
     UINT fastTimerId;
+    QMutex fastTimerMutex;
 };
 
 class QZeroTimerEvent : public QTimerEvent
diff --git a/src/corelib/kernel/qfunctions_win.cpp b/src/corelib/kernel/qfunctions_win.cpp
index ed0e25467c..2022ff2f24 100644
--- a/src/corelib/kernel/qfunctions_win.cpp
+++ b/src/corelib/kernel/qfunctions_win.cpp
@@ -4,6 +4,7 @@
 #include "qfunctions_win_p.h"
 
 #include <QtCore/qdebug.h>
+#include <QtCore/private/qsystemlibrary_p.h>
 
 #include <combaseapi.h>
 #include <objbase.h>
@@ -15,6 +16,8 @@
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
 QComHelper::QComHelper(COINIT concurrencyModel)
 {
     // Avoid overhead of initializing and using obsolete technology
@@ -44,8 +47,13 @@ bool qt_win_hasPackageIdentity()
 {
 #if defined(HAS_APPMODEL)
     static const bool hasPackageIdentity = []() {
+        static const auto pGetCurrentPackageFullName =
+            reinterpret_cast<decltype(&::GetCurrentPackageFullName)>(
+                QSystemLibrary::resolve(u"kernel32"_s, "GetCurrentPackageFullName"));
+        if (!pGetCurrentPackageFullName)
+            return false;
         UINT32 length = 0;
-        switch (const auto result = GetCurrentPackageFullName(&length, nullptr)) {
+        switch (const auto result = pGetCurrentPackageFullName(&length, nullptr)) {
         case ERROR_INSUFFICIENT_BUFFER:
             return true;
         case APPMODEL_ERROR_NO_PACKAGE:
diff --git a/src/corelib/plugin/qsystemlibrary.cpp b/src/corelib/plugin/qsystemlibrary.cpp
index d3dff226d9..44129a432c 100644
--- a/src/corelib/plugin/qsystemlibrary.cpp
+++ b/src/corelib/plugin/qsystemlibrary.cpp
@@ -42,9 +42,9 @@ using namespace Qt::StringLiterals;
 extern QString qAppFileName();
 #endif
 
-static QString qSystemDirectory()
+[[nodiscard]] static inline QString qSystemDirectory()
 {
-    static const QString result = []() -> QString {
+    static const auto result = []() -> QString {
         QVarLengthArray<wchar_t, MAX_PATH> fullPath = {};
         UINT retLen = ::GetSystemDirectoryW(fullPath.data(), MAX_PATH);
         if (retLen > MAX_PATH) {
@@ -52,15 +52,39 @@ static QString qSystemDirectory()
             retLen = ::GetSystemDirectoryW(fullPath.data(), retLen);
         }
         // in some rare cases retLen might be 0
-        return QString::fromWCharArray(fullPath.constData(), int(retLen));
+        QString path = QString::fromWCharArray(fullPath.constData(), int(retLen));
+        // Remove any trailing line separators.
+        while (path.endsWith(u'\\') || path.endsWith(u'/'))
+            path.chop(1);
+        return path;
+    }();
+    return result;
+}
+
+[[nodiscard]] static inline bool isLoadFromSystem32Available()
+{
+    static const auto result = []() -> bool {
+        const QString filePath = qSystemDirectory() + u"\\kernel32.dll"_s;
+        const HMODULE library = ::LoadLibraryW(reinterpret_cast<const wchar_t *>(filePath.utf16()));
+        if (!library)
+            return false;
+        const bool ret = ::GetProcAddress(library, "AddDllDirectory") != nullptr;
+        ::FreeLibrary(library);
+        return ret;
     }();
     return result;
 }
 
 HINSTANCE QSystemLibrary::load(const wchar_t *libraryName, bool onlySystemDirectory /* = true */)
 {
-    if (onlySystemDirectory)
-        return ::LoadLibraryExW(libraryName, nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);
+    const QString fileName = QString::fromWCharArray(libraryName);
+
+    if (onlySystemDirectory) {
+        if (isLoadFromSystem32Available())
+            return ::LoadLibraryExW(libraryName, nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);
+        const QString path = qSystemDirectory() + u'\\' + fileName;
+        return ::LoadLibraryW(reinterpret_cast<const wchar_t *>(path.utf16()));
+    }
 
     QStringList searchOrder;
 
@@ -72,17 +96,11 @@ HINSTANCE QSystemLibrary::load(const wchar_t *libraryName, bool onlySystemDirect
     const QString PATH(QLatin1StringView(qgetenv("PATH")));
     searchOrder << PATH.split(u';', Qt::SkipEmptyParts);
 
-    const QString fileName = QString::fromWCharArray(libraryName);
-
     // Start looking in the order specified
-    for (int i = 0; i < searchOrder.count(); ++i) {
+    for (int i = 0; i != searchOrder.count(); ++i) {
         QString fullPathAttempt = searchOrder.at(i);
-        if (!fullPathAttempt.endsWith(u'\\')) {
-            fullPathAttempt.append(u'\\');
-        }
-        fullPathAttempt.append(fileName);
-        HINSTANCE inst = ::LoadLibrary(reinterpret_cast<const wchar_t *>(fullPathAttempt.utf16()));
-        if (inst != nullptr)
+        fullPathAttempt += u'\\' + fileName;
+        if (const HINSTANCE inst = ::LoadLibraryW(reinterpret_cast<const wchar_t *>(fullPathAttempt.utf16())))
             return inst;
     }
     return nullptr;
diff --git a/src/corelib/text/qlocale_win.cpp b/src/corelib/text/qlocale_win.cpp
index 43324fbfb6..0162e74ab2 100644
--- a/src/corelib/text/qlocale_win.cpp
+++ b/src/corelib/text/qlocale_win.cpp
@@ -15,6 +15,7 @@
 #include <q20algorithm.h>
 
 #ifdef Q_OS_WIN
+#   include <qoperatingsystemversion.h>
 #   include <qt_windows.h>
 #   include <time.h>
 #endif
@@ -659,17 +660,19 @@ QVariant QSystemLocalePrivate::uiLanguages()
 {
     QStringList result;
 #if QT_CONFIG(cpp_winrt)
-    using namespace winrt;
-    using namespace Windows::System::UserProfile;
-    QT_TRY {
-        auto languages = GlobalizationPreferences::Languages();
-        for (const auto &lang : languages)
-            result << QString::fromStdString(winrt::to_string(lang));
-    } QT_CATCH(...) {
-        // pass, just fall back to WIN32 API implementation
+    if (QOperatingSystemVersion::isWin10OrGreater()) {
+        using namespace winrt;
+        using namespace Windows::System::UserProfile;
+        QT_TRY {
+            const auto languages = GlobalizationPreferences::Languages();
+            for (auto &&lang : languages)
+                result << QString::fromStdString(winrt::to_string(lang));
+        } QT_CATCH(...) {
+            // pass, just fall back to WIN32 API implementation
+        }
+        if (!result.isEmpty())
+            return result; // else just fall back to WIN32 API implementation
     }
-    if (!result.isEmpty())
-        return result; // else just fall back to WIN32 API implementation
 #endif // QT_CONFIG(cpp_winrt)
     // mingw and clang still have to use Win32 API
     unsigned long cnt = 0;
diff --git a/src/corelib/thread/qfutex_p.h b/src/corelib/thread/qfutex_p.h
index 48f03f5ed0..fe799c68ca 100644
--- a/src/corelib/thread/qfutex_p.h
+++ b/src/corelib/thread/qfutex_p.h
@@ -17,9 +17,12 @@
 
 #include <private/qglobal_p.h>
 #include <QtCore/qtsan_impl.h>
+#include <QtCore/qstring.h>
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
 namespace QtDummyFutex {
     constexpr inline bool futexAvailable() { return false; }
     template <typename Atomic>
@@ -109,35 +112,86 @@ namespace QtFutex = QtLinuxFutex;
 QT_END_NAMESPACE
 
 #elif defined(Q_OS_WIN)
-#  include <qt_windows.h>
+#  include <QtCore/qoperatingsystemversion.h>
+#  include <QtCore/private/qsystemlibrary_p.h>
+#  include <QtCore/qt_windows.h>
 
 QT_BEGIN_NAMESPACE
-namespace QtWindowsFutex {
-#define QT_ALWAYS_USE_FUTEX
-constexpr inline bool futexAvailable() { return true; }
+namespace QtWindowsFutex
+{
+#ifdef QT_ALWAYS_USE_FUTEX
+#  undef QT_ALWAYS_USE_FUTEX
+#endif
+
+inline bool futexAvailable()
+{
+    return QOperatingSystemVersion::isWin8OrGreater();
+}
+
+struct QFutexApi
+{
+    decltype(&::WaitOnAddress) pWaitOnAddress = nullptr;
+    decltype(&::WakeByAddressAll) pWakeByAddressAll = nullptr;
+    decltype(&::WakeByAddressSingle) pWakeByAddressSingle = nullptr;
+
+    static QFutexApi *instance()
+    {
+        static QFutexApi api;
+        return &api;
+    }
+
+private:
+    Q_DISABLE_COPY_MOVE(QFutexApi)
+
+    explicit QFutexApi()
+    {
+        if (!futexAvailable())
+            return;
+        QSystemLibrary library(u"kernelbase"_s);
+        pWaitOnAddress = reinterpret_cast<decltype(pWaitOnAddress)>(library.resolve("WaitOnAddress"));
+        pWakeByAddressAll = reinterpret_cast<decltype(pWakeByAddressAll)>(library.resolve("WakeByAddressAll"));
+        pWakeByAddressSingle = reinterpret_cast<decltype(pWakeByAddressSingle)>(library.resolve("WakeByAddressSingle"));
+    }
+
+    ~QFutexApi() = default;
+};
 
 template <typename Atomic>
 inline void futexWait(Atomic &futex, typename Atomic::Type expectedValue)
 {
+    if (!QFutexApi::instance()->pWaitOnAddress)
+        return;
     QtTsan::futexRelease(&futex);
-    WaitOnAddress(&futex, &expectedValue, sizeof(expectedValue), INFINITE);
+    QFutexApi::instance()->pWaitOnAddress(&futex, &expectedValue, sizeof(expectedValue), INFINITE);
     QtTsan::futexAcquire(&futex);
 }
+
 template <typename Atomic>
 inline bool futexWait(Atomic &futex, typename Atomic::Type expectedValue, qint64 nstimeout)
 {
-    BOOL r = WaitOnAddress(&futex, &expectedValue, sizeof(expectedValue), DWORD(nstimeout / 1000 / 1000));
+    if (!QFutexApi::instance()->pWaitOnAddress)
+        return false;
+    const BOOL r = QFutexApi::instance()->pWaitOnAddress(&futex, &expectedValue, sizeof(expectedValue), DWORD(nstimeout / 1000 / 1000));
     return r || GetLastError() != ERROR_TIMEOUT;
 }
-template <typename Atomic> inline void futexWakeAll(Atomic &futex)
+
+template <typename Atomic>
+inline void futexWakeAll(Atomic &futex)
 {
-    WakeByAddressAll(&futex);
+    if (!QFutexApi::instance()->pWakeByAddressAll)
+        return;
+    QFutexApi::instance()->pWakeByAddressAll(&futex);
 }
-template <typename Atomic> inline void futexWakeOne(Atomic &futex)
+
+template <typename Atomic>
+inline void futexWakeOne(Atomic &futex)
 {
-    WakeByAddressSingle(&futex);
-}
+    if (!QFutexApi::instance()->pWakeByAddressSingle)
+        return;
+    QFutexApi::instance()->pWakeByAddressSingle(&futex);
 }
+} // namespace QtWindowsFutex
+
 namespace QtFutex = QtWindowsFutex;
 QT_END_NAMESPACE
 #else
diff --git a/src/corelib/thread/qlocking_p.h b/src/corelib/thread/qlocking_p.h
index 9fa7e70da9..0c205fff66 100644
--- a/src/corelib/thread/qlocking_p.h
+++ b/src/corelib/thread/qlocking_p.h
@@ -8,9 +8,10 @@
 //  W A R N I N G
 //  -------------
 //
-// This file is not part of the Qt API. It exists for the convenience of
-// qmutex.cpp and qmutex_unix.cpp. This header file may change from version to
-// version without notice, or even be removed.
+// This file is not part of the Qt API.  It exists for the convenience
+// of qmutex.cpp, qmutex_unix.cpp, and qmutex_win.cpp.  This header
+// file may change from version to version without notice, or even be
+// removed.
 //
 // We mean it.
 //
diff --git a/src/corelib/thread/qmutex.cpp b/src/corelib/thread/qmutex.cpp
index 7b4aac9532..ae1a3a7313 100644
--- a/src/corelib/thread/qmutex.cpp
+++ b/src/corelib/thread/qmutex.cpp
@@ -869,6 +869,8 @@ QT_END_NAMESPACE
 // nothing
 #elif defined(Q_OS_MAC)
 #  include "qmutex_mac.cpp"
+#elif defined(Q_OS_WIN)
+#  include "qmutex_win.cpp"
 #else
 #  include "qmutex_unix.cpp"
 #endif
diff --git a/src/corelib/thread/qmutex_p.h b/src/corelib/thread/qmutex_p.h
index 565de31ca0..7c9977599f 100644
--- a/src/corelib/thread/qmutex_p.h
+++ b/src/corelib/thread/qmutex_p.h
@@ -10,9 +10,10 @@
 //  W A R N I N G
 //  -------------
 //
-// This file is not part of the Qt API. It exists for the convenience of
-// qmutex.cpp and qmutex_unix.cpp. This header file may change from version to
-// version without notice, or even be removed.
+// This file is not part of the Qt API.  It exists for the convenience
+// of qmutex.cpp, qmutex_unix.cpp, and qmutex_win.cpp.  This header
+// file may change from version to version without notice, or even be
+// removed.
 //
 // We mean it.
 //
@@ -91,6 +92,8 @@ public:
     bool wakeup;
     pthread_mutex_t mutex;
     pthread_cond_t cond;
+#elif defined(Q_OS_WIN)
+    Qt::HANDLE event;
 #endif
 };
 
diff --git a/src/corelib/thread/qmutex_win.cpp b/src/corelib/thread/qmutex_win.cpp
new file mode 100644
index 0000000000..8c7741c113
--- /dev/null
+++ b/src/corelib/thread/qmutex_win.cpp
@@ -0,0 +1,30 @@
+// Copyright (C) 2016 The Qt Company Ltd.
+// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
+
+#include "qmutex.h"
+#include <qatomic.h>
+#include "qmutex_p.h"
+#include <qt_windows.h>
+
+QT_BEGIN_NAMESPACE
+
+QMutexPrivate::QMutexPrivate()
+{
+    event = CreateEvent(0, FALSE, FALSE, 0);
+
+    if (!event)
+        qWarning("QMutexPrivate::QMutexPrivate: Cannot create event");
+}
+
+QMutexPrivate::~QMutexPrivate()
+{ CloseHandle(event); }
+
+bool QMutexPrivate::wait(int timeout)
+{
+    return (WaitForSingleObjectEx(event, timeout < 0 ? INFINITE : timeout, FALSE) == WAIT_OBJECT_0);
+}
+
+void QMutexPrivate::wakeUp() noexcept
+{ SetEvent(event); }
+
+QT_END_NAMESPACE
diff --git a/src/corelib/thread/qwaitcondition_p.h b/src/corelib/thread/qwaitcondition_p.h
index cfb36ca30b..01bb000366 100644
--- a/src/corelib/thread/qwaitcondition_p.h
+++ b/src/corelib/thread/qwaitcondition_p.h
@@ -7,9 +7,10 @@
 //  W A R N I N G
 //  -------------
 //
-// This file is not part of the Qt API. It exists for the convenience of
-// qmutex.cpp and qmutex_unix.cpp. This header file may change from version to
-// version without notice, or even be removed.
+// This file is not part of the Qt API.  It exists for the convenience
+// of qmutex.cpp, qmutex_unix.cpp, and qmutex_win.cpp.  This header
+// file may change from version to version without notice, or even be
+// removed.
 //
 // We mean it.
 //
diff --git a/src/gui/CMakeLists.txt b/src/gui/CMakeLists.txt
index 5b8bc278e9..77bff06ae5 100644
--- a/src/gui/CMakeLists.txt
+++ b/src/gui/CMakeLists.txt
@@ -419,11 +419,6 @@ qt_internal_extend_target(Gui CONDITION WIN32
         ole32
         shell32
         user32
-    PUBLIC_LIBRARIES
-        d3d11
-        dxgi
-        dxguid
-        dcomp
 )
 
 if(QT_FEATURE_egl)
@@ -457,21 +452,6 @@ qt_internal_extend_target(Gui CONDITION APPLE AND QT_FEATURE_accessibility
         ${FWFoundation}
 )
 
-qt_internal_extend_target(Gui CONDITION QT_FEATURE_accessibility AND WIN32
-    SOURCES
-        accessible/windows/apisupport/qwindowsuiawrapper.cpp accessible/windows/apisupport/qwindowsuiawrapper_p.h
-        accessible/windows/apisupport/uiaattributeids_p.h
-        accessible/windows/apisupport/uiaclientinterfaces_p.h
-        accessible/windows/apisupport/uiacontroltypeids_p.h
-        accessible/windows/apisupport/uiaerrorids_p.h
-        accessible/windows/apisupport/uiaeventids_p.h
-        accessible/windows/apisupport/uiageneralids_p.h
-        accessible/windows/apisupport/uiapatternids_p.h
-        accessible/windows/apisupport/uiapropertyids_p.h
-        accessible/windows/apisupport/uiaserverinterfaces_p.h
-        accessible/windows/apisupport/uiatypes_p.h
-)
-
 if(QT_FEATURE_accessibility AND QT_FEATURE_accessibility_atspi_bridge)
     set(atspi_accessibility ON)
 else()
@@ -530,6 +510,11 @@ qt_internal_extend_target(Gui CONDITION QT_FEATURE_movie
         image/qmovie.cpp image/qmovie.h
 )
 
+qt_internal_extend_target(Gui CONDITION QT_FEATURE_lcms2
+    LIBRARIES
+        LCMS2::LCMS2
+)
+
 qt_internal_extend_target(Gui CONDITION QT_FEATURE_png
     SOURCES
         image/qpnghandler.cpp image/qpnghandler_p.h
@@ -717,20 +702,11 @@ qt_internal_extend_target(Gui CONDITION QT_FEATURE_freetype AND WIN32
 qt_internal_extend_target(Gui CONDITION QT_FEATURE_direct2d AND QT_FEATURE_directwrite AND WIN32
     SOURCES
         text/windows/qwindowsfontenginedirectwrite.cpp text/windows/qwindowsfontenginedirectwrite_p.h
-    LIBRARIES
-        d2d1
 )
 
 qt_internal_extend_target(Gui CONDITION QT_FEATURE_direct2d AND QT_FEATURE_directwrite AND QT_FEATURE_directwrite3 AND WIN32
     SOURCES
         text/windows/qwindowsdirectwritefontdatabase.cpp text/windows/qwindowsdirectwritefontdatabase_p.h
-    LIBRARIES
-        dwrite
-)
-
-qt_internal_extend_target(Gui CONDITION QT_FEATURE_direct2d AND QT_FEATURE_directwrite AND WIN32 AND NOT QT_FEATURE_directwrite3
-    LIBRARIES
-        dwrite
 )
 
 qt_internal_extend_target(Gui CONDITION MINGW AND WIN32
diff --git a/src/gui/configure.cmake b/src/gui/configure.cmake
index d8319c120b..f1a7553db6 100644
--- a/src/gui/configure.cmake
+++ b/src/gui/configure.cmake
@@ -58,6 +58,7 @@ qt_find_package(WrapOpenGL PROVIDED_TARGETS WrapOpenGL::WrapOpenGL MODULE_NAME g
 qt_find_package(GLESv2 PROVIDED_TARGETS GLESv2::GLESv2 MODULE_NAME gui QMAKE_LIB opengl_es2)
 qt_find_package(Tslib PROVIDED_TARGETS PkgConfig::Tslib MODULE_NAME gui QMAKE_LIB tslib)
 qt_find_package(WrapVulkanHeaders PROVIDED_TARGETS WrapVulkanHeaders::WrapVulkanHeaders MODULE_NAME gui QMAKE_LIB vulkan MARK_OPTIONAL) # special case
+qt_find_package(LCMS2 PROVIDED_TARGETS LCMS2::LCMS2 MODULE_NAME gui QMAKE_LIB lcms2)
 if((LINUX) OR QT_FIND_ALL_PACKAGES_ALWAYS)
     qt_find_package(Wayland PROVIDED_TARGETS Wayland::Server MODULE_NAME gui QMAKE_LIB wayland_server)
 endif()
@@ -672,6 +673,12 @@ qt_feature("fontconfig" PUBLIC PRIVATE
     CONDITION NOT WIN32 AND QT_FEATURE_system_freetype AND Fontconfig_FOUND
 )
 qt_feature_definition("fontconfig" "QT_NO_FONTCONFIG" NEGATE VALUE "1")
+qt_feature("lcms2" PUBLIC
+    SECTION "Images"
+    LABEL "Little CMS"
+    PURPOSE "Supports the Little CMS color engine."
+    CONDITION LCMS2_FOUND
+)
 qt_feature("gbm"
     LABEL "GBM"
     CONDITION gbm_FOUND
@@ -1232,6 +1239,7 @@ qt_configure_add_summary_entry(ARGS "system-freetype")
 qt_configure_add_summary_entry(ARGS "harfbuzz")
 qt_configure_add_summary_entry(ARGS "system-harfbuzz")
 qt_configure_add_summary_entry(ARGS "fontconfig")
+qt_configure_add_summary_entry(ARGS "lcms2")
 qt_configure_add_summary_section(NAME "Image formats")
 qt_configure_add_summary_entry(ARGS "gif")
 qt_configure_add_summary_entry(ARGS "ico")
diff --git a/src/gui/image/qimage.cpp b/src/gui/image/qimage.cpp
index dc2d936fda..52d6ec16e5 100644
--- a/src/gui/image/qimage.cpp
+++ b/src/gui/image/qimage.cpp
@@ -44,6 +44,10 @@
 
 #include <memory>
 
+#if QT_CONFIG(lcms2)
+#include <lcms2.h>
+#endif
+
 QT_BEGIN_NAMESPACE
 
 using namespace Qt::StringLiterals;
@@ -4858,13 +4862,13 @@ QImage Q_TRACE_INSTRUMENT(qtgui) QImage::transformed(const QTransform &matrix, Q
 #endif
             ) {
             if (mat.m11() < 0.0F && mat.m22() < 0.0F) { // horizontal/vertical flip
-                return smoothScaled(wd, hd).mirrored(true, true).convertToFormat(format());
+                return smoothScaled(wd, hd).mirrored(true, true);
             } else if (mat.m11() < 0.0F) { // horizontal flip
-                return smoothScaled(wd, hd).mirrored(true, false).convertToFormat(format());
+                return smoothScaled(wd, hd).mirrored(true, false);
             } else if (mat.m22() < 0.0F) { // vertical flip
-                return smoothScaled(wd, hd).mirrored(false, true).convertToFormat(format());
+                return smoothScaled(wd, hd).mirrored(false, true);
             } else { // no flipping
-                return smoothScaled(wd, hd).convertToFormat(format());
+                return smoothScaled(wd, hd);
             }
         }
     }
@@ -4981,6 +4985,43 @@ void QImage::setColorSpace(const QColorSpace &colorSpace)
         d->colorSpace = colorSpace;
 }
 
+#if QT_CONFIG(lcms2)
+/**
+* Convert from Qt format to lcms2 format
+*/
+static cmsUInt32Number toLcmsFormat(QImage::Format fmt)
+{
+    switch (fmt) {
+    case QImage::Format_ARGB32:  //  (0xAARRGGBB)
+    case QImage::Format_RGB32:   //  (0xffRRGGBB)
+        return TYPE_BGRA_8;
+
+    case QImage::Format_RGB888:
+        return TYPE_RGB_8;       // 24-bit RGB format (8-8-8).
+
+    case QImage::Format_RGBX8888:
+    case QImage::Format_RGBA8888:
+        return TYPE_RGBA_8;
+
+    case QImage::Format_Grayscale8:
+        return TYPE_GRAY_8;
+
+    case QImage::Format_Grayscale16:
+        return TYPE_GRAY_16;
+
+    case QImage::Format_RGBA64:
+    case QImage::Format_RGBX64:
+        return TYPE_RGBA_16;
+
+    case QImage::Format_BGR888:
+        return TYPE_BGR_8;
+
+    default:
+        return 0;
+    }
+}
+#endif
+
 /*!
     \since 5.14
 
@@ -4994,6 +5035,34 @@ void QImage::convertToColorSpace(const QColorSpace &colorSpace)
 {
     if (!d)
         return;
+#if QT_CONFIG(lcms2)
+    auto lcmsSuccess = false;
+    const auto profileFrom = d->colorSpace.iccProfile();
+    const auto profileTo = colorSpace.iccProfile();
+    if (profileFrom.isEmpty() || profileTo.isEmpty() || profileFrom == profileTo)
+        return;
+    const auto hProfileFrom = cmsOpenProfileFromMem(profileFrom.constData(), profileFrom.size());
+    const auto hProfileTo = cmsOpenProfileFromMem(profileTo.constData(), profileTo.size());
+    const auto lcmsFormat = toLcmsFormat(format());
+    if (hProfileFrom && hProfileTo && lcmsFormat) {
+        const auto xform = cmsCreateTransform(hProfileFrom, lcmsFormat, hProfileTo,
+                                              lcmsFormat, INTENT_PERCEPTUAL, 0);
+        if (xform) {
+            cmsDoTransformLineStride(xform, constBits(), bits(),
+                                     width(), height(), bytesPerLine(),
+                                     bytesPerLine(), 0, 0);
+            d->colorSpace = colorSpace;
+            lcmsSuccess = true;
+            cmsDeleteTransform(xform);
+        }
+    }
+    if (hProfileTo)
+        cmsCloseProfile(hProfileTo);
+    if (hProfileFrom)
+        cmsCloseProfile(hProfileFrom);
+    if (lcmsSuccess)
+        return;
+#endif
     if (!d->colorSpace.isValid())
         return;
     if (!colorSpace.isValid()) {
diff --git a/src/gui/image/qimagereader.cpp b/src/gui/image/qimagereader.cpp
index 6208ae52c7..97fbf54aef 100644
--- a/src/gui/image/qimagereader.cpp
+++ b/src/gui/image/qimagereader.cpp
@@ -1289,6 +1289,7 @@ bool QImageReader::read(QImage *image)
     if (autoTransform())
         qt_imageTransform(*image, transformation());
 
+    image->convertToColorSpace(QColorSpace::SRgb);
     return true;
 }
 
diff --git a/src/gui/kernel/qhighdpiscaling.cpp b/src/gui/kernel/qhighdpiscaling.cpp
index 0f4803d92a..e279befab4 100644
--- a/src/gui/kernel/qhighdpiscaling.cpp
+++ b/src/gui/kernel/qhighdpiscaling.cpp
@@ -614,13 +614,13 @@ qreal QHighDpiScaling::screenSubfactor(const QPlatformScreen *screen)
         if (auto qScreen = screen->screen()) {
             auto screenFactor = qScreen->property(scaleFactorProperty).toReal(&screenPropertyUsed);
             if (screenPropertyUsed)
-                factor = screenFactor;
+                factor = roundScaleFactor(screenFactor);
         }
 
         if (!screenPropertyUsed) {
             auto byNameIt = QHighDpiScaling::m_namedScreenScaleFactors.constFind(screen->name());
             if ((screenPropertyUsed = byNameIt != QHighDpiScaling::m_namedScreenScaleFactors.cend()))
-                factor = *byNameIt;
+                factor = roundScaleFactor(*byNameIt);
         }
     }
 
diff --git a/src/gui/kernel/qopenglcontext.cpp b/src/gui/kernel/qopenglcontext.cpp
index a018f86763..79d0f212b5 100644
--- a/src/gui/kernel/qopenglcontext.cpp
+++ b/src/gui/kernel/qopenglcontext.cpp
@@ -652,8 +652,17 @@ bool QOpenGLContext::makeCurrent(QSurface *surface)
         return false;
     }
 
-    if (!d->platformGLContext->makeCurrent(surface->surfaceHandle()))
+    if (!d->platformGLContext->makeCurrent(surface->surfaceHandle())) {
+        // In this place the context could switch from isValid to !isValid.
+        // It may still be current (from the previous successful calls),
+        // so we need to make everything look as if it was not set current.
+        if (QOpenGLContext::currentContext() == this) {
+            // resources?..
+            QOpenGLContextPrivate::setCurrentContext(nullptr);
+            d->surface = nullptr;
+        }
         return false;
+    }
 
     QOpenGLContextPrivate::setCurrentContext(this);
 #ifndef QT_NO_DEBUG
@@ -718,8 +727,14 @@ bool QOpenGLContext::makeCurrent(QSurface *surface)
 void QOpenGLContext::doneCurrent()
 {
     Q_D(QOpenGLContext);
-    if (!isValid())
+    if (!isValid()) {
+        if (QOpenGLContext::currentContext() == this) {
+            // resources?..
+            QOpenGLContextPrivate::setCurrentContext(nullptr);
+            d->surface = nullptr;
+        }
         return;
+    }
 
     if (QOpenGLContext::currentContext() == this)
         d->shareGroup->d_func()->deletePendingResources(this);
@@ -776,6 +791,17 @@ void QOpenGLContext::swapBuffers(QSurface *surface)
     if (surface->format().swapBehavior() == QSurfaceFormat::SingleBuffer)
         functions()->glFlush();
     d->platformGLContext->swapBuffers(surfaceHandle);
+
+    if (!isValid()) {
+        // The swapBuffers call could switch the context from isValid to !isValid.
+        // It may still be current (from the previous successful calls),
+        // so we need to make everything look as if it was not set current.
+        if (QOpenGLContext::currentContext() == this) {
+            // resources?..
+            QOpenGLContextPrivate::setCurrentContext(nullptr);
+            d->surface = nullptr;
+        }
+    }
 }
 
 /*!
diff --git a/src/gui/opengl/qopengl.cpp b/src/gui/opengl/qopengl.cpp
index 7c997103d5..2821915c92 100644
--- a/src/gui/opengl/qopengl.cpp
+++ b/src/gui/opengl/qopengl.cpp
@@ -195,13 +195,35 @@ struct OsTypeTerm
     static QString hostOs();
     static QVersionNumber hostKernelVersion() { return QVersionNumber::fromString(QSysInfo::kernelVersion()); }
     static QString hostOsRelease() {
+        QString ver = {};
 #ifdef Q_OS_WIN
-        if (QOperatingSystemVersion::current() >= QOperatingSystemVersion::Windows11)
-            return u"11"_s;
-        return u"10"_s;
-#else
-        return {};
+        const auto osver = QOperatingSystemVersion::current();
+#define Q_WINVER(major, minor) (major << 8 | minor)
+        switch (Q_WINVER(osver.majorVersion(), osver.minorVersion())) {
+        case Q_WINVER(6, 0):
+            ver = QStringLiteral("Vista");
+            break;
+        case Q_WINVER(6, 1):
+            ver = QStringLiteral("7");
+            break;
+        case Q_WINVER(6, 2):
+            ver = QStringLiteral("8");
+            break;
+        case Q_WINVER(6, 3):
+            ver = QStringLiteral("8.1");
+            break;
+        case Q_WINVER(10, 0):
+            if (osver.microVersion() >= 22000)
+                ver = QStringLiteral("11");
+            else
+                ver = QStringLiteral("10");
+            break;
+        default:
+            break;
+        }
+#undef Q_WINVER
 #endif
+        return ver;
     }
 
     bool isNull() const { return type.isEmpty(); }
diff --git a/src/gui/painting/qpainter.cpp b/src/gui/painting/qpainter.cpp
index e69f369dbe..359a9b949b 100644
--- a/src/gui/painting/qpainter.cpp
+++ b/src/gui/painting/qpainter.cpp
@@ -5949,6 +5949,93 @@ static QPixmap generateWavyPixmap(qreal maxRadius, const QPen &pen)
     return pixmap;
 }
 
+// Patch: Improved underline with SpellCheck style for macOS and Windows.
+// Added implementation of underline drawing from Chrome.
+static QPixmap generateChromeSpellcheckPixmap(qreal descent, qreal factor, const QPen &pen) {
+    QString key = QLatin1String("ChromeUnderline-")
+        % pen.color().name()
+        % HexString<qreal>(factor)
+        % HexString<qreal>(pen.widthF());
+
+    QPixmap pixmap;
+    if (QPixmapCache::find(key, &pixmap)) {
+        return pixmap;
+    }
+    // https://chromium.googlesource.com/chromium/src/+/refs/heads/master/third_party/blink/renderer/core/paint/document_marker_painter.cc
+
+#ifdef Q_OS_MAC
+    Q_UNUSED(descent);
+
+    constexpr qreal kMarkerHeight = 3;
+
+    const auto ratio = qApp->devicePixelRatio();
+    const qreal height = kMarkerHeight * factor;
+    const qreal width = height + 1;
+
+    pixmap = QPixmap(qCeil(width) * ratio, qFloor(height) * ratio);
+    pixmap.setDevicePixelRatio(ratio);
+    pixmap.fill(Qt::transparent);
+    {
+        QPainter imgPainter(&pixmap);
+        imgPainter.setPen(Qt::NoPen);
+        imgPainter.setBrush(pen.color());
+        imgPainter.setRenderHints(
+            QPainter::Antialiasing | QPainter::SmoothPixmapTransform);
+        imgPainter.drawEllipse(0, 0, qFloor(height), qFloor(height));
+    }
+
+#else
+
+    constexpr qreal kMarkerWidth = 4;
+    constexpr qreal kMarkerHeight = 2;
+
+    const auto x1 = (kMarkerWidth * -3 / 8) * factor;
+    const auto y1 = (kMarkerHeight * 3 / 4) * factor;
+
+    const auto cY = (kMarkerHeight * 1 / 4) * factor;
+
+    const auto c1X1 = (kMarkerWidth * -1 / 8) * factor;
+    const auto c1X2 = (kMarkerWidth * 3 / 8) * factor;
+    const auto c1X3 = (kMarkerWidth * 7 / 8) * factor;
+
+    const auto c2X1 = (kMarkerWidth * 1 / 8) * factor;
+    const auto c2X2 = (kMarkerWidth * 5 / 8) * factor;
+    const auto c2X3 = (kMarkerWidth * 9 / 8) * factor;
+
+    QPainterPath path;
+    path.moveTo(x1, y1);
+    path.cubicTo(c1X1, y1,
+        c1X1, cY,
+        c2X1, cY);
+    path.cubicTo(c1X2, cY,
+        c1X2, y1,
+        c2X2, y1);
+    path.cubicTo(c1X3, y1,
+        c1X3, cY,
+        c2X3, cY);
+
+    pixmap = QPixmap(kMarkerWidth * factor, kMarkerHeight * factor * 2);
+    pixmap.fill(Qt::transparent);
+    {
+        QPen wavePen = pen;
+        wavePen.setCapStyle(Qt::RoundCap);
+        wavePen.setJoinStyle(Qt::RoundJoin);
+        wavePen.setWidthF(1 * factor);
+
+        QPainter imgPainter(&pixmap);
+        imgPainter.setPen(std::move(wavePen));
+        imgPainter.setRenderHint(QPainter::Antialiasing);
+        imgPainter.translate(0, descent - (kMarkerHeight * factor));
+        imgPainter.drawPath(std::move(path));
+    }
+
+#endif
+
+    QPixmapCache::insert(std::move(key), pixmap);
+
+    return pixmap;
+}
+
 static void drawTextItemDecoration(QPainter *painter, const QPointF &pos, const QFontEngine *fe, QTextEngine *textEngine,
                                    QTextCharFormat::UnderlineStyle underlineStyle,
                                    QTextItem::RenderFlags flags, qreal width,
@@ -5966,18 +6053,36 @@ static void drawTextItemDecoration(QPainter *painter, const QPointF &pos, const
     pen.setWidthF(fe->lineThickness().toReal());
     pen.setCapStyle(Qt::FlatCap);
 
-    QLineF line(qFloor(pos.x()), pos.y(), qFloor(pos.x() + width), pos.y());
+    // Patch: Improved underline with SpellCheck style for macOS and Windows.
+    // Slightly move the beginning of the underline to the right.
+    QLineF line(qFloor(pos.x() + 1), pos.y(), qFloor(pos.x() + width), pos.y());
 
     const qreal underlineOffset = fe->underlinePosition().toReal();
 
     if (underlineStyle == QTextCharFormat::SpellCheckUnderline) {
-        QPlatformTheme *theme = QGuiApplicationPrivate::platformTheme();
-        if (theme)
-            underlineStyle = QTextCharFormat::UnderlineStyle(theme->themeHint(QPlatformTheme::SpellCheckUnderlineStyle).toInt());
-        if (underlineStyle == QTextCharFormat::SpellCheckUnderline) // still not resolved
-            underlineStyle = QTextCharFormat::WaveUnderline;
-    }
+        const qreal fontFactor = qreal(charFormat.font().pixelSize()) / qreal(10.);
+        painter->save();
+        painter->translate(0, pos.y() + 1);
+        const qreal maxHeight = fe->descent().toReal() - qreal(1);
+
+        QColor uc = charFormat.underlineColor();
+        if (uc.isValid())
+            pen.setColor(uc);
 
+        const QPixmap wave = generateChromeSpellcheckPixmap(maxHeight, fontFactor, pen);
+        const int descent = qFloor(maxHeight);
+
+        painter->setBrushOrigin(painter->brushOrigin().x(), 0);
+#ifdef Q_OS_MAC
+        const auto h = wave.height() / qApp->devicePixelRatio();
+        painter->drawTiledPixmap(
+            QRectF(pos.x(), (descent - h) / 2., qCeil(width), h),
+            wave);
+#else
+        painter->fillRect(pos.x(), 0, qCeil(width), descent, wave);
+#endif
+        painter->restore();
+    } else
     if (underlineStyle == QTextCharFormat::WaveUnderline) {
         painter->save();
         painter->translate(0, pos.y() + 1);
diff --git a/src/gui/rhi/qrhid3d11.cpp b/src/gui/rhi/qrhid3d11.cpp
index e2e85cd36a..ebeae1ac93 100644
--- a/src/gui/rhi/qrhid3d11.cpp
+++ b/src/gui/rhi/qrhid3d11.cpp
@@ -9,6 +9,8 @@
 #include <qmath.h>
 #include <private/qsystemlibrary_p.h>
 #include <QtCore/qcryptographichash.h>
+#include <QtCore/qoperatingsystemversion.h>
+#include <QtCore/private/qsystemlibrary_p.h>
 #include <QtCore/private/qsystemerror_p.h>
 
 #include <d3dcompiler.h>
@@ -96,6 +98,9 @@ using namespace Qt::StringLiterals;
 #define D3D11_VS_INPUT_REGISTER_COUNT 32
 #endif
 
+static constexpr const auto qWKPDID_D3DDebugObjectNameA = GUID{0x429b8c22,0x9188,0x4b0c,{0x87,0x42,0xac,0xb0,0xbf,0x85,0xc2,0x00}};
+static constexpr const auto qWKPDID_D3DDebugObjectNameW = GUID{0x4cca5fd8,0x921f,0x42c8,{0x85,0x66,0x70,0xca,0xf2,0xa9,0xb7,0x41}};
+
 QRhiD3D11::QRhiD3D11(QRhiD3D11InitParams *params, QRhiD3D11NativeHandles *importParams)
     : ofr(this),
       deviceCurse(this)
@@ -109,7 +114,7 @@ QRhiD3D11::QRhiD3D11(QRhiD3D11InitParams *params, QRhiD3D11NativeHandles *import
         if (importParams->dev && importParams->context) {
             dev = reinterpret_cast<ID3D11Device *>(importParams->dev);
             ID3D11DeviceContext *ctx = reinterpret_cast<ID3D11DeviceContext *>(importParams->context);
-            if (SUCCEEDED(ctx->QueryInterface(__uuidof(ID3D11DeviceContext1), reinterpret_cast<void **>(&context)))) {
+            if (SUCCEEDED(ctx->QueryInterface(IID_PPV_ARGS(&context)))) {
                 // get rid of the ref added by QueryInterface
                 ctx->Release();
                 importedDeviceAndContext = true;
@@ -129,112 +134,174 @@ inline Int aligned(Int v, Int byteAlign)
     return (v + byteAlign - 1) & ~(byteAlign - 1);
 }
 
-static IDXGIFactory1 *createDXGIFactory2()
+static bool g_using_dxgi_1_0 = false;
+
+static IDXGIFactory *createDXGIFactory()
+{
+    static const auto pCreateDXGIFactory =
+        reinterpret_cast<decltype(&::CreateDXGIFactory)>(
+            QSystemLibrary::resolve(u"dxgi"_s, "CreateDXGIFactory"));
+    if (!pCreateDXGIFactory)
+        return nullptr;
+    IDXGIFactory *result = nullptr;
+    const HRESULT hr = pCreateDXGIFactory(IID_PPV_ARGS(&result));
+    if (SUCCEEDED(hr))
+        return result;
+    qWarning("CreateDXGIFactory() failed to create DXGI factory: %s",
+        qPrintable(QSystemError::windowsComString(hr)));
+    return nullptr;
+}
+
+static IDXGIFactory1 *createDXGIFactory1()
 {
+    static const auto pCreateDXGIFactory1 =
+        reinterpret_cast<decltype(&::CreateDXGIFactory1)>(
+            QSystemLibrary::resolve(u"dxgi"_s, "CreateDXGIFactory1"));
+    if (!pCreateDXGIFactory1)
+        return nullptr;
     IDXGIFactory1 *result = nullptr;
-    const HRESULT hr = CreateDXGIFactory2(0, __uuidof(IDXGIFactory2), reinterpret_cast<void **>(&result));
-    if (FAILED(hr)) {
-        qWarning("CreateDXGIFactory2() failed to create DXGI factory: %s",
-            qPrintable(QSystemError::windowsComString(hr)));
-        result = nullptr;
-    }
-    return result;
+    const HRESULT hr = pCreateDXGIFactory1(IID_PPV_ARGS(&result));
+    if (SUCCEEDED(hr))
+        return result;
+    qWarning("CreateDXGIFactory1() failed to create DXGI factory: %s",
+        qPrintable(QSystemError::windowsComString(hr)));
+    return nullptr;
 }
 
-bool QRhiD3D11::create(QRhi::Flags flags)
+static IDXGIFactory2 *createDXGIFactory2()
 {
-    rhiFlags = flags;
+    static const auto pCreateDXGIFactory2 =
+        reinterpret_cast<decltype(&::CreateDXGIFactory2)>(
+            QSystemLibrary::resolve(u"dxgi"_s, "CreateDXGIFactory2"));
+    if (!pCreateDXGIFactory2)
+        return nullptr;
+    IDXGIFactory2 *result = nullptr;
+    const HRESULT hr = pCreateDXGIFactory2(0, IID_PPV_ARGS(&result));
+    if (SUCCEEDED(hr))
+        return result;
+    qWarning("CreateDXGIFactory2() failed to create DXGI factory: %s",
+        qPrintable(QSystemError::windowsComString(hr)));
+    return nullptr;
+}
 
-    uint devFlags = 0;
-    if (debugLayer)
-        devFlags |= D3D11_CREATE_DEVICE_DEBUG;
+bool QRhiD3D11::create(QRhi::Flags flags)
+{
+    static const auto pD3D11CreateDevice =
+        reinterpret_cast<decltype(&::D3D11CreateDevice)>(
+            QSystemLibrary::resolve(u"d3d11"_s, "D3D11CreateDevice"));
+    if (!pD3D11CreateDevice) {
+        qWarning() << "D3D11 is not available on this platform.";
+        return false;
+    }
 
     dxgiFactory = createDXGIFactory2();
-    if (!dxgiFactory)
-        return false;
+    if (dxgiFactory) {
+        supportsFlipSwapchain = QOperatingSystemVersion::isWin10OrGreater()
+            && !qEnvironmentVariableIntValue("QT_D3D_NO_FLIP");
+    } else {
+        supportsFlipSwapchain = false;
+        dxgiFactory = createDXGIFactory1();
+        if (!dxgiFactory) {
+            dxgiFactory = createDXGIFactory();
+            if (!dxgiFactory) {
+                qWarning() << "DXGI is not available on this platform.";
+                return false;
+            }
+            g_using_dxgi_1_0 = true;
+        }
+    }
 
-    // For a FLIP_* swapchain Present(0, 0) is not necessarily
-    // sufficient to get non-blocking behavior, try using ALLOW_TEARING
-    // when available.
     supportsAllowTearing = false;
-    IDXGIFactory5 *factory5 = nullptr;
-    if (SUCCEEDED(dxgiFactory->QueryInterface(__uuidof(IDXGIFactory5), reinterpret_cast<void **>(&factory5)))) {
-        BOOL allowTearing = false;
-        if (SUCCEEDED(factory5->CheckFeatureSupport(DXGI_FEATURE_PRESENT_ALLOW_TEARING, &allowTearing, sizeof(allowTearing))))
-            supportsAllowTearing = allowTearing;
-        factory5->Release();
+    if (supportsFlipSwapchain) {
+        // For a FLIP_* swapchain Present(0, 0) is not necessarily
+        // sufficient to get non-blocking behavior, try using ALLOW_TEARING
+        // when available.
+        IDXGIFactory5 *factory5 = nullptr;
+        if (SUCCEEDED(dxgiFactory->QueryInterface(IID_PPV_ARGS(&factory5)))) {
+            BOOL allowTearing = false;
+            if (SUCCEEDED(factory5->CheckFeatureSupport(DXGI_FEATURE_PRESENT_ALLOW_TEARING, &allowTearing, sizeof(allowTearing))))
+                supportsAllowTearing = allowTearing;
+            factory5->Release();
+        }
     }
 
-    if (qEnvironmentVariableIntValue("QT_D3D_FLIP_DISCARD"))
-        qWarning("The default swap effect is FLIP_DISCARD, QT_D3D_FLIP_DISCARD is now ignored");
+    qCDebug(QRHI_LOG_INFO, "FLIP_* swapchain supported = %s, ALLOW_TEARING supported = %s",
+            supportsFlipSwapchain ? "true" : "false",
+            supportsAllowTearing ? "true" : "false");
 
-    if (qEnvironmentVariableIntValue("QT_D3D_NO_FLIP"))
-        qWarning("Non-FLIP swapchains are no longer supported, QT_D3D_NO_FLIP is now ignored");
+    qCDebug(QRHI_LOG_INFO, "Default swap effect: %s",
+            supportsFlipSwapchain ? "FLIP_DISCARD" : "DISCARD");
 
-    qCDebug(QRHI_LOG_INFO, "FLIP_* swapchain supported = true, ALLOW_TEARING supported = %s",
-            supportsAllowTearing ? "true" : "false");
+    rhiFlags = flags;
 
-    qCDebug(QRHI_LOG_INFO, "Default swap effect: FLIP_DISCARD");
+    uint devFlags = 0;
+    if (debugLayer)
+        devFlags |= D3D11_CREATE_DEVICE_DEBUG;
 
     if (!importedDeviceAndContext) {
-        IDXGIAdapter1 *adapter;
-        int requestedAdapterIndex = -1;
-        if (qEnvironmentVariableIsSet("QT_D3D_ADAPTER_INDEX"))
-            requestedAdapterIndex = qEnvironmentVariableIntValue("QT_D3D_ADAPTER_INDEX");
-
-        // The importParams may specify an adapter by the luid, take that into account.
-        if (requestedAdapterIndex < 0 && (adapterLuid.LowPart || adapterLuid.HighPart)) {
-            for (int adapterIndex = 0; dxgiFactory->EnumAdapters1(UINT(adapterIndex), &adapter) != DXGI_ERROR_NOT_FOUND; ++adapterIndex) {
-                DXGI_ADAPTER_DESC1 desc;
-                adapter->GetDesc1(&desc);
-                adapter->Release();
-                if (desc.AdapterLuid.LowPart == adapterLuid.LowPart
-                        && desc.AdapterLuid.HighPart == adapterLuid.HighPart)
-                {
-                    requestedAdapterIndex = adapterIndex;
-                    break;
+        activeAdapter = nullptr;
+
+        if (!g_using_dxgi_1_0) {
+            IDXGIAdapter1 *adapter;
+            int requestedAdapterIndex = -1;
+            if (qEnvironmentVariableIsSet("QT_D3D_ADAPTER_INDEX"))
+                requestedAdapterIndex = qEnvironmentVariableIntValue("QT_D3D_ADAPTER_INDEX");
+
+            const auto dxgiFactory1 = static_cast<IDXGIFactory1 *>(dxgiFactory);
+
+            // The importParams may specify an adapter by the luid, take that into account.
+            if (requestedAdapterIndex < 0 && (adapterLuid.LowPart || adapterLuid.HighPart)) {
+                for (int adapterIndex = 0; dxgiFactory1->EnumAdapters1(UINT(adapterIndex), &adapter) != DXGI_ERROR_NOT_FOUND; ++adapterIndex) {
+                    DXGI_ADAPTER_DESC1 desc;
+                    adapter->GetDesc1(&desc);
+                    adapter->Release();
+                    if (desc.AdapterLuid.LowPart == adapterLuid.LowPart
+                            && desc.AdapterLuid.HighPart == adapterLuid.HighPart)
+                    {
+                        requestedAdapterIndex = adapterIndex;
+                        break;
+                    }
+                }
+            }
+
+            if (requestedAdapterIndex < 0 && rhiFlags.testFlag(QRhi::PreferSoftwareRenderer)) {
+                for (int adapterIndex = 0; dxgiFactory1->EnumAdapters1(UINT(adapterIndex), &adapter) != DXGI_ERROR_NOT_FOUND; ++adapterIndex) {
+                    DXGI_ADAPTER_DESC1 desc;
+                    adapter->GetDesc1(&desc);
+                    adapter->Release();
+                    if (desc.Flags & DXGI_ADAPTER_FLAG_SOFTWARE) {
+                        requestedAdapterIndex = adapterIndex;
+                        break;
+                    }
                 }
             }
-        }
 
-        if (requestedAdapterIndex < 0 && flags.testFlag(QRhi::PreferSoftwareRenderer)) {
-            for (int adapterIndex = 0; dxgiFactory->EnumAdapters1(UINT(adapterIndex), &adapter) != DXGI_ERROR_NOT_FOUND; ++adapterIndex) {
+            for (int adapterIndex = 0; dxgiFactory1->EnumAdapters1(UINT(adapterIndex), &adapter) != DXGI_ERROR_NOT_FOUND; ++adapterIndex) {
                 DXGI_ADAPTER_DESC1 desc;
                 adapter->GetDesc1(&desc);
-                adapter->Release();
-                if (desc.Flags & DXGI_ADAPTER_FLAG_SOFTWARE) {
-                    requestedAdapterIndex = adapterIndex;
-                    break;
+                const QString name = QString::fromUtf16(reinterpret_cast<char16_t *>(desc.Description));
+                qCDebug(QRHI_LOG_INFO, "Adapter %d: '%s' (vendor 0x%X device 0x%X flags 0x%X)",
+                        adapterIndex,
+                        qPrintable(name),
+                        desc.VendorId,
+                        desc.DeviceId,
+                        desc.Flags);
+                if (!activeAdapter && (requestedAdapterIndex < 0 || requestedAdapterIndex == adapterIndex)) {
+                    activeAdapter = adapter;
+                    adapterLuid = desc.AdapterLuid;
+                    driverInfoStruct.deviceName = name.toUtf8();
+                    driverInfoStruct.deviceId = desc.DeviceId;
+                    driverInfoStruct.vendorId = desc.VendorId;
+                    qCDebug(QRHI_LOG_INFO, "  using this adapter");
+                } else {
+                    adapter->Release();
                 }
             }
-        }
-
-        activeAdapter = nullptr;
-        for (int adapterIndex = 0; dxgiFactory->EnumAdapters1(UINT(adapterIndex), &adapter) != DXGI_ERROR_NOT_FOUND; ++adapterIndex) {
-            DXGI_ADAPTER_DESC1 desc;
-            adapter->GetDesc1(&desc);
-            const QString name = QString::fromUtf16(reinterpret_cast<char16_t *>(desc.Description));
-            qCDebug(QRHI_LOG_INFO, "Adapter %d: '%s' (vendor 0x%X device 0x%X flags 0x%X)",
-                    adapterIndex,
-                    qPrintable(name),
-                    desc.VendorId,
-                    desc.DeviceId,
-                    desc.Flags);
-            if (!activeAdapter && (requestedAdapterIndex < 0 || requestedAdapterIndex == adapterIndex)) {
-                activeAdapter = adapter;
-                adapterLuid = desc.AdapterLuid;
-                driverInfoStruct.deviceName = name.toUtf8();
-                driverInfoStruct.deviceId = desc.DeviceId;
-                driverInfoStruct.vendorId = desc.VendorId;
-                qCDebug(QRHI_LOG_INFO, "  using this adapter");
-            } else {
-                adapter->Release();
+            if (!activeAdapter) {
+                qWarning("No adapter");
+                return false;
             }
         }
-        if (!activeAdapter) {
-            qWarning("No adapter");
-            return false;
-        }
 
         // Normally we won't specify a requested feature level list,
         // except when a level was specified in importParams.
@@ -245,27 +312,55 @@ bool QRhiD3D11::create(QRhi::Flags flags)
             requestedFeatureLevels.append(featureLevel);
         }
 
+        const D3D_DRIVER_TYPE driverType =
+                activeAdapter ? D3D_DRIVER_TYPE_UNKNOWN : D3D_DRIVER_TYPE_HARDWARE;
         ID3D11DeviceContext *ctx = nullptr;
-        HRESULT hr = D3D11CreateDevice(activeAdapter, D3D_DRIVER_TYPE_UNKNOWN, nullptr, devFlags,
-                                       requestFeatureLevels ? requestedFeatureLevels.constData() : nullptr,
-                                       requestFeatureLevels ? requestedFeatureLevels.count() : 0,
-                                       D3D11_SDK_VERSION,
-                                       &dev, &featureLevel, &ctx);
+        HRESULT hr = pD3D11CreateDevice(activeAdapter, driverType, nullptr, devFlags,
+                                        requestFeatureLevels ? requestedFeatureLevels.constData() : nullptr,
+                                        requestFeatureLevels ? requestedFeatureLevels.count() : 0,
+                                        D3D11_SDK_VERSION,
+                                        &dev, &featureLevel, &ctx);
         // We cannot assume that D3D11_CREATE_DEVICE_DEBUG is always available. Retry without it, if needed.
         if (hr == DXGI_ERROR_SDK_COMPONENT_MISSING && debugLayer) {
             qCDebug(QRHI_LOG_INFO, "Debug layer was requested but is not available. "
                                    "Attempting to create D3D11 device without it.");
             devFlags &= ~D3D11_CREATE_DEVICE_DEBUG;
-            hr = D3D11CreateDevice(activeAdapter, D3D_DRIVER_TYPE_UNKNOWN, nullptr, devFlags,
-                                   requestFeatureLevels ? requestedFeatureLevels.constData() : nullptr,
-                                   requestFeatureLevels ? requestedFeatureLevels.count() : 0,
-                                   D3D11_SDK_VERSION,
-                                   &dev, &featureLevel, &ctx);
+            hr = pD3D11CreateDevice(activeAdapter, driverType, nullptr, devFlags,
+                                    requestFeatureLevels ? requestedFeatureLevels.constData() : nullptr,
+                                    requestFeatureLevels ? requestedFeatureLevels.count() : 0,
+                                    D3D11_SDK_VERSION,
+                                    &dev, &featureLevel, &ctx);
         }
         if (FAILED(hr)) {
-            qWarning("Failed to create D3D11 device and context: %s",
-                qPrintable(QSystemError::windowsComString(hr)));
-            return false;
+            qWarning().noquote() << "Failed to create D3D11 device:"
+                                 << QSystemError::windowsComString(hr)
+                                 << "\nTry again using WARP instead ...";
+            hr = pD3D11CreateDevice(nullptr, D3D_DRIVER_TYPE_WARP, nullptr, devFlags,
+                                    requestFeatureLevels ? requestedFeatureLevels.constData() : nullptr,
+                                    requestFeatureLevels ? requestedFeatureLevels.count() : 0,
+                                    D3D11_SDK_VERSION,
+                                    &dev, &featureLevel, &ctx);
+            if (FAILED(hr)) {
+                qWarning() << "Failed to create D3D11 device with WARP:"
+                           << QSystemError::windowsComString(hr)
+                           << "\nTry again using Mesa instead ...";
+            }
+            const HMODULE soft = QSystemLibrary::load(L"d3d10sw", false);
+            if (!soft) {
+                qWarning() << "Failed to load d3d10sw.dll. D3D11 is not available.";
+                return false;
+            }
+            hr = pD3D11CreateDevice(nullptr, D3D_DRIVER_TYPE_SOFTWARE, soft, devFlags,
+                                    requestFeatureLevels ? requestedFeatureLevels.constData() : nullptr,
+                                    requestFeatureLevels ? requestedFeatureLevels.count() : 0,
+                                    D3D11_SDK_VERSION,
+                                    &dev, &featureLevel, &ctx);
+            if (FAILED(hr)) {
+                qWarning().noquote() << "Failed to create D3D11 device with Mesa:"
+                                     << QSystemError::windowsComString(hr)
+                                     << "\nD3D11 is not available.";
+                return false;
+            }
         }
 
         // Test if creating a Shader Model 5.0 vertex shader works; we want to
@@ -279,7 +374,7 @@ bool QRhiD3D11::create(QRhi::Flags flags)
             return false;
         }
 
-        const bool supports11_1 = SUCCEEDED(ctx->QueryInterface(__uuidof(ID3D11DeviceContext1), reinterpret_cast<void **>(&context)));
+        const bool supports11_1 = SUCCEEDED(ctx->QueryInterface(IID_PPV_ARGS(&context)));
         ctx->Release();
         if (!supports11_1) {
             qWarning("ID3D11DeviceContext1 not supported");
@@ -289,7 +384,7 @@ bool QRhiD3D11::create(QRhi::Flags flags)
         Q_ASSERT(dev && context);
         featureLevel = dev->GetFeatureLevel();
         IDXGIDevice *dxgiDev = nullptr;
-        if (SUCCEEDED(dev->QueryInterface(__uuidof(IDXGIDevice), reinterpret_cast<void **>(&dxgiDev)))) {
+        if (SUCCEEDED(dev->QueryInterface(IID_PPV_ARGS(&dxgiDev)))) {
             IDXGIAdapter *adapter = nullptr;
             if (SUCCEEDED(dxgiDev->GetAdapter(&adapter))) {
                 DXGI_ADAPTER_DESC desc;
@@ -305,7 +400,7 @@ bool QRhiD3D11::create(QRhi::Flags flags)
         qCDebug(QRHI_LOG_INFO, "Using imported device %p", dev);
     }
 
-    if (FAILED(context->QueryInterface(__uuidof(ID3DUserDefinedAnnotation), reinterpret_cast<void **>(&annotations))))
+    if (FAILED(context->QueryInterface(IID_PPV_ARGS(&annotations))))
         annotations = nullptr;
 
     deviceLost = false;
@@ -374,7 +469,7 @@ void QRhiD3D11::reportLiveObjects(ID3D11Device *device)
 {
     // this works only when params.enableDebugLayer was true
     ID3D11Debug *debug;
-    if (SUCCEEDED(device->QueryInterface(__uuidof(ID3D11Debug), reinterpret_cast<void **>(&debug)))) {
+    if (SUCCEEDED(device->QueryInterface(IID_PPV_ARGS(&debug)))) {
         debug->ReportLiveDeviceObjects(D3D11_RLDO_DETAIL);
         debug->Release();
     }
@@ -2870,7 +2965,7 @@ bool QD3D11Buffer::create()
     }
 
     if (!m_objectName.isEmpty())
-        buffer->SetPrivateData(WKPDID_D3DDebugObjectName, UINT(m_objectName.size()), m_objectName.constData());
+        buffer->SetPrivateData(qWKPDID_D3DDebugObjectNameA, UINT(m_objectName.size()), m_objectName.constData());
 
     generation += 1;
     rhiD->registerResource(this);
@@ -3039,7 +3134,7 @@ bool QD3D11RenderBuffer::create()
     }
 
     if (!m_objectName.isEmpty())
-        tex->SetPrivateData(WKPDID_D3DDebugObjectName, UINT(m_objectName.size()), m_objectName.constData());
+        tex->SetPrivateData(qWKPDID_D3DDebugObjectNameA, UINT(m_objectName.size()), m_objectName.constData());
 
     generation += 1;
     rhiD->registerResource(this);
@@ -3334,7 +3429,7 @@ bool QD3D11Texture::create()
             return false;
         }
         if (!m_objectName.isEmpty())
-            tex->SetPrivateData(WKPDID_D3DDebugObjectName, UINT(m_objectName.size()),
+            tex->SetPrivateData(qWKPDID_D3DDebugObjectNameA, UINT(m_objectName.size()),
                                 m_objectName.constData());
     } else if (!is3D) {
         D3D11_TEXTURE2D_DESC desc = {};
@@ -3355,7 +3450,7 @@ bool QD3D11Texture::create()
             return false;
         }
         if (!m_objectName.isEmpty())
-            tex->SetPrivateData(WKPDID_D3DDebugObjectName, UINT(m_objectName.size()), m_objectName.constData());
+            tex->SetPrivateData(qWKPDID_D3DDebugObjectNameA, UINT(m_objectName.size()), m_objectName.constData());
     } else {
         D3D11_TEXTURE3D_DESC desc = {};
         desc.Width = UINT(size.width());
@@ -3374,7 +3469,7 @@ bool QD3D11Texture::create()
             return false;
         }
         if (!m_objectName.isEmpty())
-            tex3D->SetPrivateData(WKPDID_D3DDebugObjectName, UINT(m_objectName.size()), m_objectName.constData());
+            tex3D->SetPrivateData(qWKPDID_D3DDebugObjectNameA, UINT(m_objectName.size()), m_objectName.constData());
     }
 
     if (!finishCreate())
@@ -4750,7 +4845,7 @@ static bool output6ForWindow(QWindow *w, IDXGIAdapter1 *adapter, IDXGIOutput6 **
         }
     }
     if (currentOutput) {
-        ok = SUCCEEDED(currentOutput->QueryInterface(__uuidof(IDXGIOutput6), reinterpret_cast<void **>(result)));
+        ok = SUCCEEDED(currentOutput->QueryInterface(IID_PPV_ARGS(result)));
         currentOutput->Release();
     }
     return ok;
@@ -4778,6 +4873,8 @@ bool QD3D11SwapChain::isFormatSupported(Format f)
     }
 
     QRHI_RES_RHI(QRhiD3D11);
+    if (!rhiD->activeAdapter)
+        return false;
     DXGI_OUTPUT_DESC1 desc1;
     if (outputDesc1ForWindow(m_window, rhiD->activeAdapter, &desc1))
         return desc1.ColorSpace == DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020;
@@ -4790,6 +4887,8 @@ QRhiSwapChainHdrInfo QD3D11SwapChain::hdrInfo()
     QRhiSwapChainHdrInfo info = QRhiSwapChain::hdrInfo();
     if (m_format != QRhiSwapChain::SDR && m_window) {
         QRHI_RES_RHI(QRhiD3D11);
+        if (!rhiD->activeAdapter)
+            return info;
         DXGI_OUTPUT_DESC1 hdrOutputDesc;
         if (outputDesc1ForWindow(m_window, rhiD->activeAdapter, &hdrOutputDesc)) {
             info.isHardCodedDefaults = false;
@@ -4847,12 +4946,18 @@ static const DXGI_FORMAT DEFAULT_SRGB_FORMAT = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
 
 bool QRhiD3D11::ensureDirectCompositionDevice()
 {
+    static const auto pDCompositionCreateDevice =
+        reinterpret_cast<decltype(&::DCompositionCreateDevice)>(
+            QSystemLibrary::resolve(u"dcomp"_s, "DCompositionCreateDevice"));
+    if (!pDCompositionCreateDevice)
+        return false;
+
     if (dcompDevice)
         return true;
 
     qCDebug(QRHI_LOG_INFO, "Creating Direct Composition device (needed for semi-transparent windows)");
 
-    HRESULT hr = DCompositionCreateDevice(nullptr, __uuidof(IDCompositionDevice), reinterpret_cast<void **>(&dcompDevice));
+    HRESULT hr = pDCompositionCreateDevice(nullptr, IID_PPV_ARGS(&dcompDevice));
     if (FAILED(hr)) {
         qWarning("Failed to Direct Composition device: %s",
             qPrintable(QSystemError::windowsComString(hr)));
@@ -4885,12 +4990,18 @@ bool QD3D11SwapChain::createOrResize()
     HRESULT hr;
 
     QRHI_RES_RHI(QRhiD3D11);
+    bool useFlipModel = rhiD->supportsFlipSwapchain;
 
+    // Take a shortcut for alpha: whatever the platform plugin does to enable
+    // transparency for our QWindow will be sufficient on the legacy (DISCARD)
+    // path. For FLIP_* we'd need to use DirectComposition (create a
+    // IDCompositionDevice/Target/Visual).
     if (m_flags.testFlag(SurfaceHasPreMulAlpha) || m_flags.testFlag(SurfaceHasNonPreMulAlpha)) {
         if (rhiD->ensureDirectCompositionDevice()) {
             if (!dcompTarget) {
                 hr = rhiD->dcompDevice->CreateTargetForHwnd(hwnd, true, &dcompTarget);
                 if (FAILED(hr)) {
+                    useFlipModel = false;
                     qWarning("Failed to create Direct Compsition target for the window: %s",
                              qPrintable(QSystemError::windowsComString(hr)));
                 }
@@ -4898,10 +5009,15 @@ bool QD3D11SwapChain::createOrResize()
             if (dcompTarget && !dcompVisual) {
                 hr = rhiD->dcompDevice->CreateVisual(&dcompVisual);
                 if (FAILED(hr)) {
+                    useFlipModel = false;
                     qWarning("Failed to create DirectComposition visual: %s",
                              qPrintable(QSystemError::windowsComString(hr)));
                 }
             }
+        } else {
+            // Direct Composition is not available, most likely due to we are running
+            // on Windows 7. Fallback to the legacy non-flip model instead.
+            useFlipModel = false;
         }
         // simple consistency check
         if (window->requestedFormat().alphaBufferSize() <= 0)
@@ -4916,7 +5032,7 @@ bool QD3D11SwapChain::createOrResize()
     // ALLOW_TEARING, and ALLOW_TEARING is not compatible with it at all so the
     // flag must not be set then. Whereas for flip we should use it, if
     // supported, to get better results for 'unthrottled' presentation.
-    if (swapInterval == 0 && rhiD->supportsAllowTearing)
+    if (swapInterval == 0 && useFlipModel && rhiD->supportsAllowTearing)
         swapChainFlags |= DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING;
 
     if (!swapChain) {
@@ -4924,121 +5040,145 @@ bool QD3D11SwapChain::createOrResize()
         colorFormat = DEFAULT_FORMAT;
         srgbAdjustedColorFormat = m_flags.testFlag(sRGB) ? DEFAULT_SRGB_FORMAT : DEFAULT_FORMAT;
 
-        DXGI_COLOR_SPACE_TYPE hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709; // SDR
-        DXGI_OUTPUT_DESC1 hdrOutputDesc;
-        if (outputDesc1ForWindow(m_window, rhiD->activeAdapter, &hdrOutputDesc) && m_format != SDR) {
-            // https://docs.microsoft.com/en-us/windows/win32/direct3darticles/high-dynamic-range
-            if (hdrOutputDesc.ColorSpace == DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020) {
-                switch (m_format) {
-                case HDRExtendedSrgbLinear:
-                    colorFormat = DXGI_FORMAT_R16G16B16A16_FLOAT;
-                    hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709;
-                    srgbAdjustedColorFormat = colorFormat;
-                    break;
-                case HDR10:
-                    colorFormat = DXGI_FORMAT_R10G10B10A2_UNORM;
-                    hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020;
-                    srgbAdjustedColorFormat = colorFormat;
-                    break;
-                default:
-                    break;
+        if (useFlipModel) {
+            DXGI_COLOR_SPACE_TYPE hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709; // SDR
+            DXGI_OUTPUT_DESC1 hdrOutputDesc;
+            if (outputDesc1ForWindow(m_window, rhiD->activeAdapter, &hdrOutputDesc) && m_format != SDR) {
+                // https://docs.microsoft.com/en-us/windows/win32/direct3darticles/high-dynamic-range
+                if (hdrOutputDesc.ColorSpace == DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020) {
+                    switch (m_format) {
+                    case HDRExtendedSrgbLinear:
+                        colorFormat = DXGI_FORMAT_R16G16B16A16_FLOAT;
+                        hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709;
+                        srgbAdjustedColorFormat = colorFormat;
+                        break;
+                    case HDR10:
+                        colorFormat = DXGI_FORMAT_R10G10B10A2_UNORM;
+                        hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020;
+                        srgbAdjustedColorFormat = colorFormat;
+                        break;
+                    default:
+                        break;
+                    }
+                } else {
+                    // This happens also when Use HDR is set to Off in the Windows
+                    // Display settings. Show a helpful warning, but continue with the
+                    // default non-HDR format.
+                    qWarning("The output associated with the window is not HDR capable "
+                             "(or Use HDR is Off in the Display Settings), ignoring HDR format request");
                 }
-            } else {
-                // This happens also when Use HDR is set to Off in the Windows
-                // Display settings. Show a helpful warning, but continue with the
-                // default non-HDR format.
-                qWarning("The output associated with the window is not HDR capable "
-                         "(or Use HDR is Off in the Display Settings), ignoring HDR format request");
             }
-        }
 
-        // We use a FLIP model swapchain which implies a buffer count of 2
-        // (as opposed to the old DISCARD with back buffer count == 1).
-        // This makes no difference for the rest of the stuff except that
-        // automatic MSAA is unsupported and needs to be implemented via a
-        // custom multisample render target and an explicit resolve.
-
-        DXGI_SWAP_CHAIN_DESC1 desc = {};
-        desc.Width = UINT(pixelSize.width());
-        desc.Height = UINT(pixelSize.height());
-        desc.Format = colorFormat;
-        desc.SampleDesc.Count = 1;
-        desc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
-        desc.BufferCount = BUFFER_COUNT;
-        desc.Flags = swapChainFlags;
-        desc.Scaling = DXGI_SCALING_NONE;
-        desc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
-
-        if (dcompVisual) {
-            // With DirectComposition setting AlphaMode to STRAIGHT fails the
-            // swapchain creation, whereas the result seems to be identical
-            // with any of the other values, including IGNORE. (?)
-            desc.AlphaMode = DXGI_ALPHA_MODE_PREMULTIPLIED;
-
-            // DirectComposition has its own limitations, cannot use
-            // SCALING_NONE. So with semi-transparency requested we are forced
-            // to SCALING_STRETCH.
-            desc.Scaling = DXGI_SCALING_STRETCH;
-        }
+            // We use a FLIP model swapchain which implies a buffer count of 2
+            // (as opposed to the old DISCARD with back buffer count == 1).
+            // This makes no difference for the rest of the stuff except that
+            // automatic MSAA is unsupported and needs to be implemented via a
+            // custom multisample render target and an explicit resolve.
 
-        IDXGIFactory2 *fac = static_cast<IDXGIFactory2 *>(rhiD->dxgiFactory);
-        IDXGISwapChain1 *sc1;
+            DXGI_SWAP_CHAIN_DESC1 desc = {};
+            desc.Width = UINT(pixelSize.width());
+            desc.Height = UINT(pixelSize.height());
+            desc.Format = colorFormat;
+            desc.SampleDesc.Count = 1;
+            desc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
+            desc.BufferCount = BUFFER_COUNT;
+            desc.Flags = swapChainFlags;
+            desc.Scaling = DXGI_SCALING_NONE;
+            desc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
+
+            if (dcompVisual) {
+                // With DirectComposition setting AlphaMode to STRAIGHT fails the
+                // swapchain creation, whereas the result seems to be identical
+                // with any of the other values, including IGNORE. (?)
+                desc.AlphaMode = DXGI_ALPHA_MODE_PREMULTIPLIED;
+
+                // DirectComposition has its own limitations, cannot use
+                // SCALING_NONE. So with semi-transparency requested we are forced
+                // to SCALING_STRETCH.
+                desc.Scaling = DXGI_SCALING_STRETCH;
+            }
+
+            IDXGIFactory2 *fac = static_cast<IDXGIFactory2 *>(rhiD->dxgiFactory);
+            IDXGISwapChain1 *sc1;
 
-        if (dcompVisual)
-            hr = fac->CreateSwapChainForComposition(rhiD->dev, &desc, nullptr, &sc1);
-        else
-            hr = fac->CreateSwapChainForHwnd(rhiD->dev, hwnd, &desc, nullptr, nullptr, &sc1);
-
-        // If failed and we tried a HDR format, then try with SDR. This
-        // matches other backends, such as Vulkan where if the format is
-        // not supported, the default one is used instead.
-        if (FAILED(hr) && m_format != SDR) {
-            colorFormat = DEFAULT_FORMAT;
-            desc.Format = DEFAULT_FORMAT;
             if (dcompVisual)
                 hr = fac->CreateSwapChainForComposition(rhiD->dev, &desc, nullptr, &sc1);
             else
                 hr = fac->CreateSwapChainForHwnd(rhiD->dev, hwnd, &desc, nullptr, nullptr, &sc1);
-        }
 
-        if (SUCCEEDED(hr)) {
-            swapChain = sc1;
-            if (m_format != SDR) {
-                IDXGISwapChain3 *sc3 = nullptr;
-                if (SUCCEEDED(sc1->QueryInterface(__uuidof(IDXGISwapChain3), reinterpret_cast<void **>(&sc3)))) {
-                    hr = sc3->SetColorSpace1(hdrColorSpace);
-                    if (FAILED(hr))
-                        qWarning("Failed to set color space on swapchain: %s",
-                            qPrintable(QSystemError::windowsComString(hr)));
-                    sc3->Release();
-                } else {
-                    qWarning("IDXGISwapChain3 not available, HDR swapchain will not work as expected");
-                }
+            // If failed and we tried a HDR format, then try with SDR. This
+            // matches other backends, such as Vulkan where if the format is
+            // not supported, the default one is used instead.
+            if (FAILED(hr) && m_format != SDR) {
+                colorFormat = DEFAULT_FORMAT;
+                desc.Format = DEFAULT_FORMAT;
+                if (dcompVisual)
+                    hr = fac->CreateSwapChainForComposition(rhiD->dev, &desc, nullptr, &sc1);
+                else
+                    hr = fac->CreateSwapChainForHwnd(rhiD->dev, hwnd, &desc, nullptr, nullptr, &sc1);
             }
-            if (dcompVisual) {
-                hr = dcompVisual->SetContent(sc1);
-                if (SUCCEEDED(hr)) {
-                    hr = dcompTarget->SetRoot(dcompVisual);
-                    if (FAILED(hr)) {
-                        qWarning("Failed to associate Direct Composition visual with the target: %s",
+
+            if (SUCCEEDED(hr)) {
+                swapChain = sc1;
+                if (m_format != SDR) {
+                    IDXGISwapChain3 *sc3 = nullptr;
+                    if (SUCCEEDED(sc1->QueryInterface(IID_PPV_ARGS(&sc3)))) {
+                        hr = sc3->SetColorSpace1(hdrColorSpace);
+                        if (FAILED(hr)) {
+                            qWarning("Failed to set color space on swapchain: %s",
+                                qPrintable(QSystemError::windowsComString(hr)));
+                        }
+                        sc3->Release();
+                    } else {
+                        qWarning("IDXGISwapChain3 not available, HDR swapchain will not work as expected");
+                    }
+                }
+                if (dcompVisual) {
+                    hr = dcompVisual->SetContent(sc1);
+                    if (SUCCEEDED(hr)) {
+                        hr = dcompTarget->SetRoot(dcompVisual);
+                        if (FAILED(hr)) {
+                            qWarning("Failed to associate Direct Composition visual with the target: %s",
+                                     qPrintable(QSystemError::windowsComString(hr)));
+                        }
+                    } else {
+                        qWarning("Failed to set content for Direct Composition visual: %s",
                                  qPrintable(QSystemError::windowsComString(hr)));
                     }
-                } else {
-                    qWarning("Failed to set content for Direct Composition visual: %s",
-                             qPrintable(QSystemError::windowsComString(hr)));
                 }
             }
+        } else {
+            // Fallback: use DISCARD model. Regardless, keep on using our manual
+            // resolve for symmetry with the FLIP_* code path when MSAA is
+            // requested. This has no HDR support.
+
+            DXGI_SWAP_CHAIN_DESC desc = {};
+            desc.BufferDesc.Width = UINT(pixelSize.width());
+            desc.BufferDesc.Height = UINT(pixelSize.height());
+            desc.BufferDesc.RefreshRate.Numerator = 60;
+            desc.BufferDesc.RefreshRate.Denominator = 1;
+            desc.BufferDesc.Format = colorFormat;
+            desc.SampleDesc.Count = 1;
+            desc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
+            desc.BufferCount = 1;
+            desc.OutputWindow = hwnd;
+            desc.Windowed = TRUE;
+            desc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
+            desc.Flags = swapChainFlags;
+
+            hr = rhiD->dxgiFactory->CreateSwapChain(rhiD->dev, &desc, &swapChain);
         }
         if (FAILED(hr)) {
             qWarning("Failed to create D3D11 swapchain: %s",
                 qPrintable(QSystemError::windowsComString(hr)));
             return false;
         }
-        rhiD->dxgiFactory->MakeWindowAssociation(hwnd, DXGI_MWA_NO_WINDOW_CHANGES);
+        rhiD->dxgiFactory->MakeWindowAssociation(hwnd,
+            DXGI_MWA_NO_WINDOW_CHANGES | DXGI_MWA_NO_ALT_ENTER | DXGI_MWA_NO_PRINT_SCREEN);
     } else {
         releaseBuffers();
-        // flip model -> buffer count is the real buffer count, not 1 like with the legacy modes
-        hr = swapChain->ResizeBuffers(UINT(BUFFER_COUNT), UINT(pixelSize.width()), UINT(pixelSize.height()),
+        const UINT count = useFlipModel ? BUFFER_COUNT : 1;
+        hr = swapChain->ResizeBuffers(count, UINT(pixelSize.width()), UINT(pixelSize.height()),
                                       colorFormat, swapChainFlags);
         if (hr == DXGI_ERROR_DEVICE_REMOVED || hr == DXGI_ERROR_DEVICE_RESET) {
             qWarning("Device loss detected in ResizeBuffers()");
@@ -5065,7 +5205,7 @@ bool QD3D11SwapChain::createOrResize()
     // swapchain."
 
     // So just query index 0 once (per resize) and be done with it.
-    hr = swapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), reinterpret_cast<void **>(&backBufferTex));
+    hr = swapChain->GetBuffer(0, IID_PPV_ARGS(&backBufferTex));
     if (FAILED(hr)) {
         qWarning("Failed to query swapchain backbuffer: %s",
             qPrintable(QSystemError::windowsComString(hr)));
diff --git a/src/gui/rhi/qrhid3d11_p_p.h b/src/gui/rhi/qrhid3d11_p_p.h
index d53f7f80a9..f984786181 100644
--- a/src/gui/rhi/qrhid3d11_p_p.h
+++ b/src/gui/rhi/qrhid3d11_p_p.h
@@ -737,8 +737,9 @@ public:
     LUID adapterLuid = {};
     ID3DUserDefinedAnnotation *annotations = nullptr;
     IDXGIAdapter1 *activeAdapter = nullptr;
-    IDXGIFactory1 *dxgiFactory = nullptr;
+    IDXGIFactory *dxgiFactory = nullptr;
     IDCompositionDevice *dcompDevice = nullptr;
+    bool supportsFlipSwapchain = false;
     bool supportsAllowTearing = false;
     bool deviceLost = false;
     QRhiD3D11NativeHandles nativeHandlesStruct;
diff --git a/src/gui/rhi/qrhid3d12.cpp b/src/gui/rhi/qrhid3d12.cpp
new file mode 100644
index 0000000000..ada9497b37
--- /dev/null
+++ b/src/gui/rhi/qrhid3d12.cpp
@@ -0,0 +1,6079 @@
+// Copyright (C) 2022 The Qt Company Ltd.
+// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
+
+#include "qrhid3d12_p_p.h"
+#include "qshader_p.h"
+#include <QWindow>
+#include <qmath.h>
+#include <private/qsystemlibrary_p.h>
+#include <QtCore/qcryptographichash.h>
+#include <QtCore/private/qsystemerror_p.h>
+
+#include <d3dcompiler.h>
+#include <comdef.h>
+
+#include "cs_mipmap_p.h"
+
+QT_BEGIN_NAMESPACE
+
+/*
+  Direct 3D 12 backend.
+*/
+
+/*!
+    \class QRhiD3D12InitParams
+    \inmodule QtGui
+    \brief Direct3D 12 specific initialization parameters.
+
+    A D3D12-based QRhi needs no special parameters for initialization. If
+    desired, enableDebugLayer can be set to \c true to enable the Direct3D
+    debug layer. This can be useful during development, but should be avoided
+    in production builds.
+
+    \badcode
+        QRhiD3D12InitParams params;
+        params.enableDebugLayer = true;
+        rhi = QRhi::create(QRhi::D3D12, &params);
+    \endcode
+
+    \note QRhiSwapChain should only be used in combination with QWindow
+    instances that have their surface type set to QSurface::Direct3DSurface.
+
+    \section2 Working with existing Direct3D 12 devices
+
+    When interoperating with another graphics engine, it may be necessary to
+    get a QRhi instance that uses the same Direct3D device. This can be
+    achieved by passing a pointer to a QRhiD3D12NativeHandles to
+    QRhi::create(). QRhi does not take ownership of any of the external
+    objects.
+
+    Sometimes, for example when using QRhi in combination with OpenXR, one will
+    want to specify which adapter to use, and optionally, which feature level
+    to request on the device, while leaving the device creation to QRhi. This
+    is achieved by leaving the device pointer set to null, while specifying the
+    adapter LUID and feature level.
+
+    Optionally the ID3D12CommandQueue can be specified as well, by setting \c
+    commandQueue to a non-null value.
+ */
+
+/*!
+    \class QRhiD3D12NativeHandles
+    \inmodule QtGui
+    \brief Holds the D3D12 device used by the QRhi.
+
+    \note The class uses \c{void *} as the type since including the COM-based
+    \c{d3d12.h} headers is not acceptable here. The actual type is
+    \c{ID3D12Device *}.
+ */
+
+/*!
+    \class QRhiD3D12CommandBufferNativeHandles
+    \inmodule QtGui
+    \brief Holds the ID3D12GraphicsCommandList object that is backing a QRhiCommandBuffer.
+
+    \note The command list object is only guaranteed to be valid, and
+    in recording state, while recording a frame. That is, between a
+    \l{QRhi::beginFrame()}{beginFrame()} - \l{QRhi::endFrame()}{endFrame()} or
+    \l{QRhi::beginOffscreenFrame()}{beginOffscreenFrame()} -
+    \l{QRhi::endOffscreenFrame()}{endOffscreenFrame()} pair.
+ */
+
+using namespace Qt::StringLiterals;
+
+// https://learn.microsoft.com/en-us/windows/win32/direct3d12/hardware-feature-levels
+static constexpr const D3D_FEATURE_LEVEL MIN_FEATURE_LEVEL = D3D_FEATURE_LEVEL_11_0;
+
+struct QtD3D12ApiSupport
+{
+    decltype(&::CreateDXGIFactory2) pCreateDXGIFactory2 = nullptr;
+    decltype(&::DCompositionCreateDevice) pDCompositionCreateDevice = nullptr;
+    decltype(&::D3D12CreateDevice) pD3D12CreateDevice = nullptr;
+    decltype(&::D3D12GetDebugInterface) pD3D12GetDebugInterface = nullptr;
+    decltype(&::D3D12SerializeVersionedRootSignature) pD3D12SerializeVersionedRootSignature = nullptr;
+
+    explicit QtD3D12ApiSupport()
+    {
+        pCreateDXGIFactory2 =
+            reinterpret_cast<decltype(pCreateDXGIFactory2)>(
+                QSystemLibrary::resolve(u"dxgi"_s, "CreateDXGIFactory2"));
+        pDCompositionCreateDevice =
+            reinterpret_cast<decltype(pDCompositionCreateDevice)>(
+                QSystemLibrary::resolve(u"dcomp"_s, "DCompositionCreateDevice"));
+        QSystemLibrary d3d12(u"d3d12"_s);
+        pD3D12CreateDevice =
+            reinterpret_cast<decltype(pD3D12CreateDevice)>(
+                d3d12.resolve("D3D12CreateDevice"));
+        pD3D12GetDebugInterface =
+            reinterpret_cast<decltype(pD3D12GetDebugInterface)>(
+                d3d12.resolve("D3D12GetDebugInterface"));
+        pD3D12SerializeVersionedRootSignature =
+            reinterpret_cast<decltype(pD3D12SerializeVersionedRootSignature)>(
+                d3d12.resolve("D3D12SerializeVersionedRootSignature"));
+    }
+
+    ~QtD3D12ApiSupport() = default;
+
+    [[nodiscard]] static QtD3D12ApiSupport *instance()
+    {
+        static QtD3D12ApiSupport support;
+        return &support;
+    }
+
+    [[nodiscard]] bool isAvailable() const
+    {
+        return pCreateDXGIFactory2 && pDCompositionCreateDevice
+                && pD3D12CreateDevice && pD3D12GetDebugInterface
+                && pD3D12SerializeVersionedRootSignature;
+    }
+};
+
+QRhiD3D12::QRhiD3D12(QRhiD3D12InitParams *params, QRhiD3D12NativeHandles *importParams)
+{
+    debugLayer = params->enableDebugLayer;
+    if (importParams) {
+        if (importParams->dev) {
+            dev = reinterpret_cast<ID3D12Device *>(importParams->dev);
+            importedDevice = true;
+        }
+        if (importParams->commandQueue) {
+            cmdQueue = reinterpret_cast<ID3D12CommandQueue *>(importParams->commandQueue);
+            importedCommandQueue = true;
+        }
+        minimumFeatureLevel = D3D_FEATURE_LEVEL(importParams->minimumFeatureLevel);
+        adapterLuid.LowPart = importParams->adapterLuidLow;
+        adapterLuid.HighPart = importParams->adapterLuidHigh;
+    }
+}
+
+template <class Int>
+inline Int aligned(Int v, Int byteAlign)
+{
+    return (v + byteAlign - 1) & ~(byteAlign - 1);
+}
+
+static inline UINT calcSubresource(UINT mipSlice, UINT arraySlice, UINT mipLevels)
+{
+    return mipSlice + arraySlice * mipLevels;
+}
+
+static inline QD3D12RenderTargetData *rtData(QRhiRenderTarget *rt)
+{
+    switch (rt->resourceType()) {
+    case QRhiResource::SwapChainRenderTarget:
+        return &QRHI_RES(QD3D12SwapChainRenderTarget, rt)->d;
+    case QRhiResource::TextureRenderTarget:
+        return &QRHI_RES(QD3D12TextureRenderTarget, rt)->d;
+        break;
+    default:
+        break;
+    }
+    Q_UNREACHABLE_RETURN(nullptr);
+}
+
+bool QRhiD3D12::create(QRhi::Flags flags)
+{
+    if (!QtD3D12ApiSupport::instance()->isAvailable()) {
+        qWarning() << "D3D12 is not available on current platform.";
+        return false;
+    }
+
+    rhiFlags = flags;
+
+    UINT factoryFlags = 0;
+    if (debugLayer)
+        factoryFlags |= DXGI_CREATE_FACTORY_DEBUG;
+    HRESULT hr = QtD3D12ApiSupport::instance()->pCreateDXGIFactory2(
+                factoryFlags, IID_PPV_ARGS(&dxgiFactory));
+    if (FAILED(hr)) {
+        qWarning("CreateDXGIFactory2() failed to create DXGI factory: %s",
+                 qPrintable(QSystemError::windowsComString(hr)));
+        return false;
+    }
+
+    supportsAllowTearing = false;
+    IDXGIFactory5 *factory5 = nullptr;
+    if (SUCCEEDED(dxgiFactory->QueryInterface(IID_PPV_ARGS(&factory5)))) {
+        BOOL allowTearing = false;
+        if (SUCCEEDED(factory5->CheckFeatureSupport(DXGI_FEATURE_PRESENT_ALLOW_TEARING, &allowTearing, sizeof(allowTearing))))
+            supportsAllowTearing = allowTearing;
+        factory5->Release();
+    }
+
+    if (debugLayer) {
+        ID3D12Debug1 *debug = nullptr;
+        if (SUCCEEDED(QtD3D12ApiSupport::instance()->pD3D12GetDebugInterface(IID_PPV_ARGS(&debug)))) {
+            qCDebug(QRHI_LOG_INFO, "Enabling D3D12 debug layer");
+            debug->EnableDebugLayer();
+            debug->Release();
+        }
+    }
+
+    if (!importedDevice) {
+        IDXGIAdapter1 *adapter;
+        int requestedAdapterIndex = -1;
+        if (qEnvironmentVariableIsSet("QT_D3D_ADAPTER_INDEX"))
+            requestedAdapterIndex = qEnvironmentVariableIntValue("QT_D3D_ADAPTER_INDEX");
+
+        // The importParams may specify an adapter by the luid, take that into account.
+        if (requestedAdapterIndex < 0 && (adapterLuid.LowPart || adapterLuid.HighPart)) {
+            for (int adapterIndex = 0; dxgiFactory->EnumAdapters1(UINT(adapterIndex), &adapter) != DXGI_ERROR_NOT_FOUND; ++adapterIndex) {
+                DXGI_ADAPTER_DESC1 desc;
+                adapter->GetDesc1(&desc);
+                adapter->Release();
+                if (desc.AdapterLuid.LowPart == adapterLuid.LowPart
+                        && desc.AdapterLuid.HighPart == adapterLuid.HighPart)
+                {
+                    requestedAdapterIndex = adapterIndex;
+                    break;
+                }
+            }
+        }
+
+        if (requestedAdapterIndex < 0 && flags.testFlag(QRhi::PreferSoftwareRenderer)) {
+            for (int adapterIndex = 0; dxgiFactory->EnumAdapters1(UINT(adapterIndex), &adapter) != DXGI_ERROR_NOT_FOUND; ++adapterIndex) {
+                DXGI_ADAPTER_DESC1 desc;
+                adapter->GetDesc1(&desc);
+                adapter->Release();
+                if (desc.Flags & DXGI_ADAPTER_FLAG_SOFTWARE) {
+                    requestedAdapterIndex = adapterIndex;
+                    break;
+                }
+            }
+        }
+
+        activeAdapter = nullptr;
+        for (int adapterIndex = 0; dxgiFactory->EnumAdapters1(UINT(adapterIndex), &adapter) != DXGI_ERROR_NOT_FOUND; ++adapterIndex) {
+            DXGI_ADAPTER_DESC1 desc;
+            adapter->GetDesc1(&desc);
+            const QString name = QString::fromUtf16(reinterpret_cast<char16_t *>(desc.Description));
+            qCDebug(QRHI_LOG_INFO, "Adapter %d: '%s' (vendor 0x%X device 0x%X flags 0x%X)",
+                    adapterIndex,
+                    qPrintable(name),
+                    desc.VendorId,
+                    desc.DeviceId,
+                    desc.Flags);
+            if (!activeAdapter && (requestedAdapterIndex < 0 || requestedAdapterIndex == adapterIndex)) {
+                activeAdapter = adapter;
+                adapterLuid = desc.AdapterLuid;
+                driverInfoStruct.deviceName = name.toUtf8();
+                driverInfoStruct.deviceId = desc.DeviceId;
+                driverInfoStruct.vendorId = desc.VendorId;
+                qCDebug(QRHI_LOG_INFO, "  using this adapter");
+            } else {
+                adapter->Release();
+            }
+        }
+        if (!activeAdapter) {
+            qWarning("No adapter");
+            return false;
+        }
+
+        if (minimumFeatureLevel == 0)
+            minimumFeatureLevel = MIN_FEATURE_LEVEL;
+
+        hr = QtD3D12ApiSupport::instance()->pD3D12CreateDevice(
+                activeAdapter, minimumFeatureLevel, IID_PPV_ARGS(&dev));
+        if (FAILED(hr)) {
+            qWarning("Failed to create D3D12 device: %s", qPrintable(QSystemError::windowsComString(hr)));
+            return false;
+        }
+    } else {
+        Q_ASSERT(dev);
+        // cannot just get a IDXGIDevice from the ID3D12Device anymore, look up the adapter instead
+        adapterLuid = dev->GetAdapterLuid();
+        IDXGIAdapter1 *adapter;
+        for (int adapterIndex = 0; dxgiFactory->EnumAdapters1(UINT(adapterIndex), &adapter) != DXGI_ERROR_NOT_FOUND; ++adapterIndex) {
+            DXGI_ADAPTER_DESC1 desc;
+            adapter->GetDesc1(&desc);
+            adapter->Release();
+            if (desc.AdapterLuid.LowPart == adapterLuid.LowPart
+                    && desc.AdapterLuid.HighPart == adapterLuid.HighPart)
+            {
+                driverInfoStruct.deviceName = QString::fromUtf16(reinterpret_cast<char16_t *>(desc.Description)).toUtf8();
+                driverInfoStruct.deviceId = desc.DeviceId;
+                driverInfoStruct.vendorId = desc.VendorId;
+                break;
+            }
+        }
+        qCDebug(QRHI_LOG_INFO, "Using imported device %p", dev);
+    }
+
+    if (debugLayer) {
+        ID3D12InfoQueue *infoQueue;
+        if (SUCCEEDED(dev->QueryInterface(IID_PPV_ARGS(&infoQueue)))) {
+            if (qEnvironmentVariableIntValue("QT_D3D_DEBUG_BREAK")) {
+                infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_CORRUPTION, true);
+                infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_ERROR, true);
+                infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_WARNING, true);
+            }
+            D3D12_INFO_QUEUE_FILTER filter = {};
+            D3D12_MESSAGE_ID suppressedMessages[2] = {
+                // there is no way of knowing the clear color upfront
+                D3D12_MESSAGE_ID_CLEARRENDERTARGETVIEW_MISMATCHINGCLEARVALUE,
+                // we have no control over viewport and scissor rects
+                D3D12_MESSAGE_ID_DRAW_EMPTY_SCISSOR_RECTANGLE
+            };
+            filter.DenyList.NumIDs = 2;
+            filter.DenyList.pIDList = suppressedMessages;
+            // Setting the filter would enable Info messages (e.g. about
+            // resource creation) which we don't need.
+            D3D12_MESSAGE_SEVERITY infoSev = D3D12_MESSAGE_SEVERITY_INFO;
+            filter.DenyList.NumSeverities = 1;
+            filter.DenyList.pSeverityList = &infoSev;
+            infoQueue->PushStorageFilter(&filter);
+            infoQueue->Release();
+        }
+    }
+
+    if (!importedCommandQueue) {
+        D3D12_COMMAND_QUEUE_DESC queueDesc = {};
+        queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
+        queueDesc.Priority = D3D12_COMMAND_QUEUE_PRIORITY_NORMAL;
+        hr = dev->CreateCommandQueue(&queueDesc, IID_PPV_ARGS(&cmdQueue));
+        if (FAILED(hr)) {
+            qWarning("Failed to create command queue: %s", qPrintable(QSystemError::windowsComString(hr)));
+            return false;
+        }
+    }
+
+    hr = dev->CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&fullFence));
+    if (FAILED(hr)) {
+        qWarning("Failed to create fence: %s", qPrintable(QSystemError::windowsComString(hr)));
+        return false;
+    }
+    fullFenceEvent = CreateEvent(nullptr, FALSE, FALSE, nullptr);
+    fullFenceCounter = 0;
+
+    for (int i = 0; i < QD3D12_FRAMES_IN_FLIGHT; ++i) {
+        hr = dev->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT,
+                                         IID_PPV_ARGS(&cmdAllocators[i]));
+        if (FAILED(hr)) {
+            qWarning("Failed to create command allocator: %s", qPrintable(QSystemError::windowsComString(hr)));
+            return false;
+        }
+    }
+
+    if (!vma.create(dev, activeAdapter)) {
+        qWarning("Failed to initialize graphics memory suballocator");
+        return false;
+    }
+
+    if (!rtvPool.create(dev, D3D12_DESCRIPTOR_HEAP_TYPE_RTV, "main RTV pool")) {
+        qWarning("Could not create RTV pool");
+        return false;
+    }
+
+    if (!dsvPool.create(dev, D3D12_DESCRIPTOR_HEAP_TYPE_DSV, "main DSV pool")) {
+        qWarning("Could not create DSV pool");
+        return false;
+    }
+
+    if (!cbvSrvUavPool.create(dev, D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV, "main CBV-SRV-UAV pool")) {
+        qWarning("Could not create CBV-SRV-UAV pool");
+        return false;
+    }
+
+    resourcePool.create("main resource pool");
+    pipelinePool.create("main pipeline pool");
+    rootSignaturePool.create("main root signature pool");
+    releaseQueue.create(&resourcePool, &pipelinePool, &rootSignaturePool);
+    barrierGen.create(&resourcePool);
+
+    if (!samplerMgr.create(dev)) {
+        qWarning("Could not create sampler pool and shader-visible sampler heap");
+        return false;
+    }
+
+    if (!mipmapGen.create(this)) {
+        qWarning("Could not initialize mipmap generator");
+        return false;
+    }
+
+    const qint32 smallStagingSize = aligned(SMALL_STAGING_AREA_BYTES_PER_FRAME, QD3D12StagingArea::ALIGNMENT);
+    for (int i = 0; i < QD3D12_FRAMES_IN_FLIGHT; ++i) {
+        if (!smallStagingAreas[i].create(this, smallStagingSize, D3D12_HEAP_TYPE_UPLOAD)) {
+            qWarning("Could not create host-visible staging area");
+            return false;
+        }
+    }
+
+    if (!shaderVisibleCbvSrvUavHeap.create(dev,
+                                           D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV,
+                                           SHADER_VISIBLE_CBV_SRV_UAV_HEAP_PER_FRAME_START_SIZE))
+    {
+        qWarning("Could not create first shader-visible CBV/SRV/UAV heap");
+        return false;
+    }
+
+    deviceLost = false;
+    offscreenActive = false;
+
+    nativeHandlesStruct.dev = dev;
+    nativeHandlesStruct.minimumFeatureLevel = minimumFeatureLevel;
+    nativeHandlesStruct.adapterLuidLow = adapterLuid.LowPart;
+    nativeHandlesStruct.adapterLuidHigh = adapterLuid.HighPart;
+    nativeHandlesStruct.commandQueue = cmdQueue;
+
+    return true;
+}
+
+void QRhiD3D12::destroy()
+{
+    if (!deviceLost && fullFence && fullFenceEvent)
+        waitGpu();
+
+    releaseQueue.releaseAll();
+
+    for (int i = 0; i < QD3D12_FRAMES_IN_FLIGHT; ++i) {
+        if (offscreenCb[i]) {
+            if (offscreenCb[i]->cmdList)
+                offscreenCb[i]->cmdList->Release();
+            delete offscreenCb[i];
+            offscreenCb[i] = nullptr;
+        }
+    }
+
+    shaderVisibleCbvSrvUavHeap.destroy();
+
+    for (int i = 0; i < QD3D12_FRAMES_IN_FLIGHT; ++i)
+        smallStagingAreas[i].destroy();
+
+    mipmapGen.destroy();
+    samplerMgr.destroy();
+    resourcePool.destroy();
+    pipelinePool.destroy();
+    rootSignaturePool.destroy();
+    rtvPool.destroy();
+    dsvPool.destroy();
+    cbvSrvUavPool.destroy();
+
+    for (int i = 0; i < QD3D12_FRAMES_IN_FLIGHT; ++i) {
+        cmdAllocators[i]->Release();
+        cmdAllocators[i] = nullptr;
+    }
+
+    if (fullFenceEvent) {
+        CloseHandle(fullFenceEvent);
+        fullFenceEvent = nullptr;
+    }
+
+    if (fullFence) {
+        fullFence->Release();
+        fullFence = nullptr;
+    }
+
+    if (!importedCommandQueue) {
+        if (cmdQueue) {
+            cmdQueue->Release();
+            cmdQueue = nullptr;
+        }
+    }
+
+    vma.destroy();
+
+    if (!importedDevice) {
+        if (dev) {
+            dev->Release();
+            dev = nullptr;
+        }
+    }
+
+    if (dcompDevice) {
+        dcompDevice->Release();
+        dcompDevice = nullptr;
+    }
+
+    if (activeAdapter) {
+        activeAdapter->Release();
+        activeAdapter = nullptr;
+    }
+
+    if (dxgiFactory) {
+        dxgiFactory->Release();
+        dxgiFactory = nullptr;
+    }
+}
+
+QList<int> QRhiD3D12::supportedSampleCounts() const
+{
+    return { 1, 2, 4, 8 };
+}
+
+QRhiSwapChain *QRhiD3D12::createSwapChain()
+{
+    return new QD3D12SwapChain(this);
+}
+
+QRhiBuffer *QRhiD3D12::createBuffer(QRhiBuffer::Type type, QRhiBuffer::UsageFlags usage, quint32 size)
+{
+    return new QD3D12Buffer(this, type, usage, size);
+}
+
+int QRhiD3D12::ubufAlignment() const
+{
+    return D3D12_CONSTANT_BUFFER_DATA_PLACEMENT_ALIGNMENT; // 256
+}
+
+bool QRhiD3D12::isYUpInFramebuffer() const
+{
+    return false;
+}
+
+bool QRhiD3D12::isYUpInNDC() const
+{
+    return true;
+}
+
+bool QRhiD3D12::isClipDepthZeroToOne() const
+{
+    return true;
+}
+
+QMatrix4x4 QRhiD3D12::clipSpaceCorrMatrix() const
+{
+    // Like with Vulkan, but Y is already good.
+
+    static QMatrix4x4 m;
+    if (m.isIdentity()) {
+        // NB the ctor takes row-major
+        m = QMatrix4x4(1.0f, 0.0f, 0.0f, 0.0f,
+                       0.0f, 1.0f, 0.0f, 0.0f,
+                       0.0f, 0.0f, 0.5f, 0.5f,
+                       0.0f, 0.0f, 0.0f, 1.0f);
+    }
+    return m;
+}
+
+bool QRhiD3D12::isTextureFormatSupported(QRhiTexture::Format format, QRhiTexture::Flags flags) const
+{
+    Q_UNUSED(flags);
+
+    if (format >= QRhiTexture::ETC2_RGB8 && format <= QRhiTexture::ASTC_12x12)
+        return false;
+
+    return true;
+}
+
+bool QRhiD3D12::isFeatureSupported(QRhi::Feature feature) const
+{
+    switch (feature) {
+    case QRhi::MultisampleTexture:
+        return true;
+    case QRhi::MultisampleRenderBuffer:
+        return true;
+    case QRhi::DebugMarkers:
+        return false; // ###
+    case QRhi::Timestamps:
+        return false; // ###
+    case QRhi::Instancing:
+        return true;
+    case QRhi::CustomInstanceStepRate:
+        return true;
+    case QRhi::PrimitiveRestart:
+        return true;
+    case QRhi::NonDynamicUniformBuffers:
+        return false;
+    case QRhi::NonFourAlignedEffectiveIndexBufferOffset:
+        return true;
+    case QRhi::NPOTTextureRepeat:
+        return true;
+    case QRhi::RedOrAlpha8IsRed:
+        return true;
+    case QRhi::ElementIndexUint:
+        return true;
+    case QRhi::Compute:
+        return true;
+    case QRhi::WideLines:
+        return false;
+    case QRhi::VertexShaderPointSize:
+        return false;
+    case QRhi::BaseVertex:
+        return true;
+    case QRhi::BaseInstance:
+        return true;
+    case QRhi::TriangleFanTopology:
+        return false;
+    case QRhi::ReadBackNonUniformBuffer:
+        return true;
+    case QRhi::ReadBackNonBaseMipLevel:
+        return true;
+    case QRhi::TexelFetch:
+        return true;
+    case QRhi::RenderToNonBaseMipLevel:
+        return true;
+    case QRhi::IntAttributes:
+        return true;
+    case QRhi::ScreenSpaceDerivatives:
+        return true;
+    case QRhi::ReadBackAnyTextureFormat:
+        return true;
+    case QRhi::PipelineCacheDataLoadSave:
+        return false; // ###
+    case QRhi::ImageDataStride:
+        return true;
+    case QRhi::RenderBufferImport:
+        return false;
+    case QRhi::ThreeDimensionalTextures:
+        return true;
+    case QRhi::RenderTo3DTextureSlice:
+        return true;
+    case QRhi::TextureArrays:
+        return true;
+    case QRhi::Tessellation:
+        return true;
+    case QRhi::GeometryShader:
+        return true;
+    case QRhi::TextureArrayRange:
+        return true;
+    case QRhi::NonFillPolygonMode:
+        return true;
+    case QRhi::OneDimensionalTextures:
+        return true;
+    case QRhi::OneDimensionalTextureMipmaps:
+        return false; // we generate mipmaps ourselves with compute and this is not implemented
+    case QRhi::HalfAttributes:
+        return true;
+    case QRhi::RenderToOneDimensionalTexture:
+        return true;
+    case QRhi::ThreeDimensionalTextureMipmaps:
+        return false; // we generate mipmaps ourselves with compute and this is not implemented
+    }
+    return false;
+}
+
+int QRhiD3D12::resourceLimit(QRhi::ResourceLimit limit) const
+{
+    switch (limit) {
+    case QRhi::TextureSizeMin:
+        return 1;
+    case QRhi::TextureSizeMax:
+        return 16384;
+    case QRhi::MaxColorAttachments:
+        return 8;
+    case QRhi::FramesInFlight:
+        return QD3D12_FRAMES_IN_FLIGHT;
+    case QRhi::MaxAsyncReadbackFrames:
+        return QD3D12_FRAMES_IN_FLIGHT;
+    case QRhi::MaxThreadGroupsPerDimension:
+        return 65535;
+    case QRhi::MaxThreadsPerThreadGroup:
+        return 1024;
+    case QRhi::MaxThreadGroupX:
+        return 1024;
+    case QRhi::MaxThreadGroupY:
+        return 1024;
+    case QRhi::MaxThreadGroupZ:
+        return 1024;
+    case QRhi::TextureArraySizeMax:
+        return 2048;
+    case QRhi::MaxUniformBufferRange:
+        return 65536;
+    case QRhi::MaxVertexInputs:
+        return 32;
+    case QRhi::MaxVertexOutputs:
+        return 32;
+    }
+    return 0;
+}
+
+const QRhiNativeHandles *QRhiD3D12::nativeHandles()
+{
+    return &nativeHandlesStruct;
+}
+
+QRhiDriverInfo QRhiD3D12::driverInfo() const
+{
+    return driverInfoStruct;
+}
+
+QRhiStats QRhiD3D12::statistics()
+{
+    QRhiStats result;
+    result.totalPipelineCreationTime = totalPipelineCreationTime();
+
+    D3D12MA::Budget budgets[2]; // [gpu, system] with discreet GPU or [shared, nothing] with UMA
+    vma.getBudget(&budgets[0], &budgets[1]);
+    for (int i = 0; i < 2; ++i) {
+        const D3D12MA::Statistics &stats(budgets[i].Stats);
+        result.blockCount += stats.BlockCount;
+        result.allocCount += stats.AllocationCount;
+        result.usedBytes += stats.AllocationBytes;
+        result.unusedBytes += stats.BlockBytes - stats.AllocationBytes;
+        result.totalUsageBytes += budgets[i].UsageBytes;
+    }
+
+    return result;
+}
+
+bool QRhiD3D12::makeThreadLocalNativeContextCurrent()
+{
+    // not applicable
+    return false;
+}
+
+void QRhiD3D12::releaseCachedResources()
+{
+    shaderBytecodeCache.data.clear();
+}
+
+bool QRhiD3D12::isDeviceLost() const
+{
+    return deviceLost;
+}
+
+QByteArray QRhiD3D12::pipelineCacheData()
+{
+    return {};
+}
+
+void QRhiD3D12::setPipelineCacheData(const QByteArray &data)
+{
+    Q_UNUSED(data);
+}
+
+QRhiRenderBuffer *QRhiD3D12::createRenderBuffer(QRhiRenderBuffer::Type type, const QSize &pixelSize,
+                                                int sampleCount, QRhiRenderBuffer::Flags flags,
+                                                QRhiTexture::Format backingFormatHint)
+{
+    return new QD3D12RenderBuffer(this, type, pixelSize, sampleCount, flags, backingFormatHint);
+}
+
+QRhiTexture *QRhiD3D12::createTexture(QRhiTexture::Format format,
+                                      const QSize &pixelSize, int depth, int arraySize,
+                                      int sampleCount, QRhiTexture::Flags flags)
+{
+    return new QD3D12Texture(this, format, pixelSize, depth, arraySize, sampleCount, flags);
+}
+
+QRhiSampler *QRhiD3D12::createSampler(QRhiSampler::Filter magFilter, QRhiSampler::Filter minFilter,
+                                      QRhiSampler::Filter mipmapMode,
+                                      QRhiSampler::AddressMode u, QRhiSampler::AddressMode v, QRhiSampler::AddressMode w)
+{
+    return new QD3D12Sampler(this, magFilter, minFilter, mipmapMode, u, v, w);
+}
+
+QRhiTextureRenderTarget *QRhiD3D12::createTextureRenderTarget(const QRhiTextureRenderTargetDescription &desc,
+                                                              QRhiTextureRenderTarget::Flags flags)
+{
+    return new QD3D12TextureRenderTarget(this, desc, flags);
+}
+
+QRhiGraphicsPipeline *QRhiD3D12::createGraphicsPipeline()
+{
+    return new QD3D12GraphicsPipeline(this);
+}
+
+QRhiComputePipeline *QRhiD3D12::createComputePipeline()
+{
+    return new QD3D12ComputePipeline(this);
+}
+
+QRhiShaderResourceBindings *QRhiD3D12::createShaderResourceBindings()
+{
+    return new QD3D12ShaderResourceBindings(this);
+}
+
+void QRhiD3D12::setGraphicsPipeline(QRhiCommandBuffer *cb, QRhiGraphicsPipeline *ps)
+{
+    QD3D12CommandBuffer *cbD = QRHI_RES(QD3D12CommandBuffer, cb);
+    Q_ASSERT(cbD->recordingPass == QD3D12CommandBuffer::RenderPass);
+    QD3D12GraphicsPipeline *psD = QRHI_RES(QD3D12GraphicsPipeline, ps);
+    const bool pipelineChanged = cbD->currentGraphicsPipeline != psD || cbD->currentPipelineGeneration != psD->generation;
+
+    if (pipelineChanged) {
+        cbD->currentGraphicsPipeline = psD;
+        cbD->currentComputePipeline = nullptr;
+        cbD->currentPipelineGeneration = psD->generation;
+
+        if (QD3D12Pipeline *pipeline = pipelinePool.lookupRef(psD->handle)) {
+            Q_ASSERT(pipeline->type == QD3D12Pipeline::Graphics);
+            cbD->cmdList->SetPipelineState(pipeline->pso);
+            if (QD3D12RootSignature *rs = rootSignaturePool.lookupRef(psD->rootSigHandle))
+                cbD->cmdList->SetGraphicsRootSignature(rs->rootSig);
+        }
+
+        cbD->cmdList->IASetPrimitiveTopology(psD->topology);
+    }
+}
+
+void QRhiD3D12::visitUniformBuffer(QD3D12Stage s,
+                                   const QRhiShaderResourceBinding::Data::UniformBufferData &d,
+                                   int,
+                                   int binding,
+                                   int dynamicOffsetCount,
+                                   const QRhiCommandBuffer::DynamicOffset *dynamicOffsets)
+{
+    QD3D12Buffer *bufD = QRHI_RES(QD3D12Buffer, d.buf);
+    quint32 offset = d.offset;
+    if (d.hasDynamicOffset) {
+        for (int i = 0; i < dynamicOffsetCount; ++i) {
+            const QRhiCommandBuffer::DynamicOffset &dynOfs(dynamicOffsets[i]);
+            if (dynOfs.first == binding) {
+                Q_ASSERT(aligned(dynOfs.second, 256u) == dynOfs.second);
+                offset += dynOfs.second;
+            }
+        }
+    }
+    visitorData.cbufs[s].append({ bufD->handles[currentFrameSlot], offset });
+}
+
+void QRhiD3D12::visitTexture(QD3D12Stage s,
+                             const QRhiShaderResourceBinding::TextureAndSampler &d,
+                             int)
+{
+    QD3D12Texture *texD = QRHI_RES(QD3D12Texture, d.tex);
+    visitorData.srvs[s].append(texD->srv);
+}
+
+void QRhiD3D12::visitSampler(QD3D12Stage s,
+                             const QRhiShaderResourceBinding::TextureAndSampler &d,
+                             int)
+{
+    QD3D12Sampler *samplerD = QRHI_RES(QD3D12Sampler, d.sampler);
+    visitorData.samplers[s].append(samplerD->lookupOrCreateShaderVisibleDescriptor());
+}
+
+void QRhiD3D12::visitStorageBuffer(QD3D12Stage s,
+                                   const QRhiShaderResourceBinding::Data::StorageBufferData &d,
+                                   QD3D12ShaderResourceVisitor::StorageOp,
+                                   int)
+{
+    QD3D12Buffer *bufD = QRHI_RES(QD3D12Buffer, d.buf);
+    // SPIRV-Cross generated HLSL uses RWByteAddressBuffer
+    D3D12_UNORDERED_ACCESS_VIEW_DESC uavDesc = {};
+    uavDesc.Format = DXGI_FORMAT_R32_TYPELESS;
+    uavDesc.ViewDimension = D3D12_UAV_DIMENSION_BUFFER;
+    uavDesc.Buffer.FirstElement = d.offset / 4;
+    uavDesc.Buffer.NumElements = aligned(bufD->m_size - d.offset, 4u) / 4;
+    uavDesc.Buffer.Flags = D3D12_BUFFER_UAV_FLAG_RAW;
+    visitorData.uavs[s].append({ bufD->handles[0], uavDesc });
+}
+
+void QRhiD3D12::visitStorageImage(QD3D12Stage s,
+                                  const QRhiShaderResourceBinding::Data::StorageImageData &d,
+                                  QD3D12ShaderResourceVisitor::StorageOp,
+                                  int)
+{
+    QD3D12Texture *texD = QRHI_RES(QD3D12Texture, d.tex);
+    const bool isCube = texD->m_flags.testFlag(QRhiTexture::CubeMap);
+    const bool isArray = texD->m_flags.testFlag(QRhiTexture::TextureArray);
+    const bool is3D = texD->m_flags.testFlag(QRhiTexture::ThreeDimensional);
+    D3D12_UNORDERED_ACCESS_VIEW_DESC uavDesc = {};
+    uavDesc.Format = texD->dxgiFormat;
+    if (isCube) {
+        uavDesc.ViewDimension = D3D12_UAV_DIMENSION_TEXTURE2DARRAY;
+        uavDesc.Texture2DArray.MipSlice = UINT(d.level);
+        uavDesc.Texture2DArray.FirstArraySlice = 0;
+        uavDesc.Texture2DArray.ArraySize = 6;
+    } else if (isArray) {
+        uavDesc.ViewDimension = D3D12_UAV_DIMENSION_TEXTURE2DARRAY;
+        uavDesc.Texture2DArray.MipSlice = UINT(d.level);
+        uavDesc.Texture2DArray.FirstArraySlice = 0;
+        uavDesc.Texture2DArray.ArraySize = UINT(texD->m_arraySize);
+    } else if (is3D) {
+        uavDesc.ViewDimension = D3D12_UAV_DIMENSION_TEXTURE3D;
+        uavDesc.Texture3D.MipSlice = UINT(d.level);
+    } else {
+        uavDesc.ViewDimension = D3D12_UAV_DIMENSION_TEXTURE2D;
+        uavDesc.Texture2D.MipSlice = UINT(d.level);
+    }
+    visitorData.uavs[s].append({ texD->handle, uavDesc });
+}
+
+void QRhiD3D12::setShaderResources(QRhiCommandBuffer *cb, QRhiShaderResourceBindings *srb,
+                                   int dynamicOffsetCount,
+                                   const QRhiCommandBuffer::DynamicOffset *dynamicOffsets)
+{
+    QD3D12CommandBuffer *cbD = QRHI_RES(QD3D12CommandBuffer, cb);
+    Q_ASSERT(cbD->recordingPass != QD3D12CommandBuffer::NoPass);
+    QD3D12GraphicsPipeline *gfxPsD = QRHI_RES(QD3D12GraphicsPipeline, cbD->currentGraphicsPipeline);
+    QD3D12ComputePipeline *compPsD = QRHI_RES(QD3D12ComputePipeline, cbD->currentComputePipeline);
+
+    if (!srb) {
+        if (gfxPsD)
+            srb = gfxPsD->m_shaderResourceBindings;
+        else
+            srb = compPsD->m_shaderResourceBindings;
+    }
+
+    QD3D12ShaderResourceBindings *srbD = QRHI_RES(QD3D12ShaderResourceBindings, srb);
+
+    for (int i = 0, ie = srbD->sortedBindings.size(); i != ie; ++i) {
+        const QRhiShaderResourceBinding::Data *b = shaderResourceBindingData(srbD->sortedBindings[i]);
+        switch (b->type) {
+        case QRhiShaderResourceBinding::UniformBuffer:
+        {
+            QD3D12Buffer *bufD = QRHI_RES(QD3D12Buffer, b->u.ubuf.buf);
+            Q_ASSERT(bufD->m_usage.testFlag(QRhiBuffer::UniformBuffer));
+            Q_ASSERT(bufD->m_type == QRhiBuffer::Dynamic);
+            bufD->executeHostWritesForFrameSlot(currentFrameSlot);
+        }
+            break;
+        case QRhiShaderResourceBinding::SampledTexture:
+        case QRhiShaderResourceBinding::Texture:
+        case QRhiShaderResourceBinding::Sampler:
+        {
+            const QRhiShaderResourceBinding::Data::TextureAndOrSamplerData *data = &b->u.stex;
+            for (int elem = 0; elem < data->count; ++elem) {
+                QD3D12Texture *texD = QRHI_RES(QD3D12Texture, data->texSamplers[elem].tex);
+                QD3D12Sampler *samplerD = QRHI_RES(QD3D12Sampler, data->texSamplers[elem].sampler);
+                // We use the same code path for both combined and separate
+                // images and samplers, so tex or sampler (but not both) can be
+                // null here.
+                Q_ASSERT(texD || samplerD);
+                if (texD) {
+                    UINT state = 0;
+                    if (b->stage == QRhiShaderResourceBinding::FragmentStage) {
+                        state = D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE;
+                    } else if (b->stage.testFlag(QRhiShaderResourceBinding::FragmentStage)) {
+                        state = D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE | D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
+                    } else {
+                        state = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
+                    }
+                    barrierGen.addTransitionBarrier(texD->handle, D3D12_RESOURCE_STATES(state));
+                    barrierGen.enqueueBufferedTransitionBarriers(cbD);
+                }
+            }
+        }
+            break;
+        case QRhiShaderResourceBinding::ImageLoad:
+        case QRhiShaderResourceBinding::ImageStore:
+        case QRhiShaderResourceBinding::ImageLoadStore:
+        {
+            QD3D12Texture *texD = QRHI_RES(QD3D12Texture, b->u.simage.tex);
+            if (QD3D12Resource *res = resourcePool.lookupRef(texD->handle)) {
+                if (res->uavUsage) {
+                    if (res->uavUsage & QD3D12Resource::UavUsageWrite) {
+                        // RaW or WaW
+                        barrierGen.enqueueUavBarrier(cbD, texD->handle);
+                    } else {
+                        if (b->type == QRhiShaderResourceBinding::ImageStore
+                                || b->type == QRhiShaderResourceBinding::ImageLoadStore)
+                        {
+                            // WaR or WaW
+                            barrierGen.enqueueUavBarrier(cbD, texD->handle);
+                        }
+                    }
+                }
+                res->uavUsage = 0;
+                if (b->type == QRhiShaderResourceBinding::ImageLoad || b->type == QRhiShaderResourceBinding::ImageLoadStore)
+                    res->uavUsage |= QD3D12Resource::UavUsageRead;
+                if (b->type == QRhiShaderResourceBinding::ImageStore || b->type == QRhiShaderResourceBinding::ImageLoadStore)
+                    res->uavUsage |= QD3D12Resource::UavUsageWrite;
+                barrierGen.addTransitionBarrier(texD->handle, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
+                barrierGen.enqueueBufferedTransitionBarriers(cbD);
+            }
+        }
+            break;
+        case QRhiShaderResourceBinding::BufferLoad:
+        case QRhiShaderResourceBinding::BufferStore:
+        case QRhiShaderResourceBinding::BufferLoadStore:
+        {
+            QD3D12Buffer *bufD = QRHI_RES(QD3D12Buffer, b->u.sbuf.buf);
+            Q_ASSERT(bufD->m_usage.testFlag(QRhiBuffer::StorageBuffer));
+            Q_ASSERT(bufD->m_type != QRhiBuffer::Dynamic);
+            if (QD3D12Resource *res = resourcePool.lookupRef(bufD->handles[0])) {
+                if (res->uavUsage) {
+                    if (res->uavUsage & QD3D12Resource::UavUsageWrite) {
+                        // RaW or WaW
+                        barrierGen.enqueueUavBarrier(cbD, bufD->handles[0]);
+                    } else {
+                        if (b->type == QRhiShaderResourceBinding::BufferStore
+                                || b->type == QRhiShaderResourceBinding::BufferLoadStore)
+                        {
+                            // WaR or WaW
+                            barrierGen.enqueueUavBarrier(cbD, bufD->handles[0]);
+                        }
+                    }
+                }
+                res->uavUsage = 0;
+                if (b->type == QRhiShaderResourceBinding::BufferLoad || b->type == QRhiShaderResourceBinding::BufferLoadStore)
+                    res->uavUsage |= QD3D12Resource::UavUsageRead;
+                if (b->type == QRhiShaderResourceBinding::BufferStore || b->type == QRhiShaderResourceBinding::BufferLoadStore)
+                    res->uavUsage |= QD3D12Resource::UavUsageWrite;
+                barrierGen.addTransitionBarrier(bufD->handles[0], D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
+                barrierGen.enqueueBufferedTransitionBarriers(cbD);
+            }
+        }
+            break;
+        }
+    }
+
+    const bool srbChanged = gfxPsD ? (cbD->currentGraphicsSrb != srb) : (cbD->currentComputeSrb != srb);
+    const bool srbRebuilt = cbD->currentSrbGeneration != srbD->generation;
+
+    if (srbChanged || srbRebuilt || srbD->hasDynamicOffset) {
+        const QD3D12ShaderStageData *stageData = gfxPsD ? gfxPsD->stageData.data() : &compPsD->stageData;
+
+        // The order of root parameters must match
+        // QD3D12ShaderResourceBindings::createRootSignature(), meaning the
+        // logic below must mirror that function (uniform buffers first etc.)
+
+        QD3D12ShaderResourceVisitor visitor(srbD, stageData, gfxPsD ? 5 : 1);
+
+        visitorData = {};
+
+        using namespace std::placeholders;
+        visitor.uniformBuffer = std::bind(&QRhiD3D12::visitUniformBuffer, this, _1, _2, _3, _4, dynamicOffsetCount, dynamicOffsets);
+        visitor.texture = std::bind(&QRhiD3D12::visitTexture, this, _1, _2, _3);
+        visitor.sampler = std::bind(&QRhiD3D12::visitSampler, this, _1, _2, _3);
+        visitor.storageBuffer = std::bind(&QRhiD3D12::visitStorageBuffer, this, _1, _2, _3, _4);
+        visitor.storageImage = std::bind(&QRhiD3D12::visitStorageImage, this, _1, _2, _3, _4);
+
+        visitor.visit();
+
+        quint32 cbvSrvUavCount = 0;
+        for (int s = 0; s < 6; ++s) {
+            // CBs use root constant buffer views, no need to count them here
+            cbvSrvUavCount += visitorData.srvs[s].count();
+            cbvSrvUavCount += visitorData.uavs[s].count();
+        }
+
+        bool gotNewHeap = false;
+        if (!ensureShaderVisibleDescriptorHeapCapacity(&shaderVisibleCbvSrvUavHeap,
+                                                       D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV,
+                                                       currentFrameSlot,
+                                                       cbvSrvUavCount,
+                                                       &gotNewHeap))
+        {
+            return;
+        }
+        if (gotNewHeap) {
+            qCDebug(QRHI_LOG_INFO, "Created new shader-visible CBV/SRV/UAV descriptor heap,"
+                    " per-frame slice size is now %u,"
+                    " if this happens frequently then that's not great.",
+                    shaderVisibleCbvSrvUavHeap.perFrameHeapSlice[0].capacity);
+            bindShaderVisibleHeaps(cbD);
+        }
+
+        int rootParamIndex = 0;
+        for (int s = 0; s < 6; ++s) {
+            if (!visitorData.cbufs[s].isEmpty()) {
+                for (int i = 0, count = visitorData.cbufs[s].count(); i < count; ++i) {
+                    const auto &cbuf(visitorData.cbufs[s][i]);
+                    if (QD3D12Resource *res = resourcePool.lookupRef(cbuf.first)) {
+                        quint32 offset = cbuf.second;
+                        D3D12_GPU_VIRTUAL_ADDRESS gpuAddr = res->resource->GetGPUVirtualAddress() + offset;
+                        if (cbD->currentGraphicsPipeline)
+                            cbD->cmdList->SetGraphicsRootConstantBufferView(rootParamIndex, gpuAddr);
+                        else
+                            cbD->cmdList->SetComputeRootConstantBufferView(rootParamIndex, gpuAddr);
+                    }
+                    rootParamIndex += 1;
+                }
+            }
+        }
+        for (int s = 0; s < 6; ++s) {
+            if (!visitorData.srvs[s].isEmpty()) {
+                QD3D12DescriptorHeap &gpuSrvHeap(shaderVisibleCbvSrvUavHeap.perFrameHeapSlice[currentFrameSlot]);
+                QD3D12Descriptor startDesc = gpuSrvHeap.get(visitorData.srvs[s].count());
+                for (int i = 0, count = visitorData.srvs[s].count(); i < count; ++i) {
+                    const auto &srv(visitorData.srvs[s][i]);
+                    dev->CopyDescriptorsSimple(1, gpuSrvHeap.incremented(startDesc, i).cpuHandle, srv.cpuHandle,
+                                               D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
+                }
+
+                if (cbD->currentGraphicsPipeline)
+                    cbD->cmdList->SetGraphicsRootDescriptorTable(rootParamIndex, startDesc.gpuHandle);
+                else if (cbD->currentComputePipeline)
+                    cbD->cmdList->SetComputeRootDescriptorTable(rootParamIndex, startDesc.gpuHandle);
+
+                rootParamIndex += 1;
+            }
+        }
+        for (int s = 0; s < 6; ++s) {
+            // Samplers are one parameter / descriptor table each, and the
+            // descriptor is from the shader visible sampler heap already.
+            for (const QD3D12Descriptor &samplerDescriptor : visitorData.samplers[s]) {
+                if (cbD->currentGraphicsPipeline)
+                    cbD->cmdList->SetGraphicsRootDescriptorTable(rootParamIndex, samplerDescriptor.gpuHandle);
+                else if (cbD->currentComputePipeline)
+                    cbD->cmdList->SetComputeRootDescriptorTable(rootParamIndex, samplerDescriptor.gpuHandle);
+
+                rootParamIndex += 1;
+            }
+        }
+        for (int s = 0; s < 6; ++s) {
+            if (!visitorData.uavs[s].isEmpty()) {
+                QD3D12DescriptorHeap &gpuUavHeap(shaderVisibleCbvSrvUavHeap.perFrameHeapSlice[currentFrameSlot]);
+                QD3D12Descriptor startDesc = gpuUavHeap.get(visitorData.uavs[s].count());
+                for (int i = 0, count = visitorData.uavs[s].count(); i < count; ++i) {
+                    const auto &uav(visitorData.uavs[s][i]);
+                    if (QD3D12Resource *res = resourcePool.lookupRef(uav.first)) {
+                        dev->CreateUnorderedAccessView(res->resource, nullptr, &uav.second,
+                                                       gpuUavHeap.incremented(startDesc, i).cpuHandle);
+                    } else {
+                        dev->CreateUnorderedAccessView(nullptr, nullptr, nullptr,
+                                                       gpuUavHeap.incremented(startDesc, i).cpuHandle);
+                    }
+                }
+
+                if (cbD->currentGraphicsPipeline)
+                    cbD->cmdList->SetGraphicsRootDescriptorTable(rootParamIndex, startDesc.gpuHandle);
+                else if (cbD->currentComputePipeline)
+                    cbD->cmdList->SetComputeRootDescriptorTable(rootParamIndex, startDesc.gpuHandle);
+
+                rootParamIndex += 1;
+            }
+        }
+
+        if (gfxPsD) {
+            cbD->currentGraphicsSrb = srb;
+            cbD->currentComputeSrb = nullptr;
+        } else {
+            cbD->currentGraphicsSrb = nullptr;
+            cbD->currentComputeSrb = srb;
+        }
+        cbD->currentSrbGeneration = srbD->generation;
+    }
+}
+
+void QRhiD3D12::setVertexInput(QRhiCommandBuffer *cb,
+                               int startBinding, int bindingCount, const QRhiCommandBuffer::VertexInput *bindings,
+                               QRhiBuffer *indexBuf, quint32 indexOffset, QRhiCommandBuffer::IndexFormat indexFormat)
+{
+    QD3D12CommandBuffer *cbD = QRHI_RES(QD3D12CommandBuffer, cb);
+    Q_ASSERT(cbD->recordingPass == QD3D12CommandBuffer::RenderPass);
+
+    bool needsBindVBuf = false;
+    for (int i = 0; i < bindingCount; ++i) {
+        const int inputSlot = startBinding + i;
+        QD3D12Buffer *bufD = QRHI_RES(QD3D12Buffer, bindings[i].first);
+        Q_ASSERT(bufD->m_usage.testFlag(QRhiBuffer::VertexBuffer));
+        const bool isDynamic = bufD->m_type == QRhiBuffer::Dynamic;
+        if (isDynamic)
+            bufD->executeHostWritesForFrameSlot(currentFrameSlot);
+
+        if (cbD->currentVertexBuffers[inputSlot] != bufD->handles[isDynamic ? currentFrameSlot : 0]
+                || cbD->currentVertexOffsets[inputSlot] != bindings[i].second)
+        {
+            needsBindVBuf = true;
+            cbD->currentVertexBuffers[inputSlot] = bufD->handles[isDynamic ? currentFrameSlot : 0];
+            cbD->currentVertexOffsets[inputSlot] = bindings[i].second;
+        }
+    }
+
+    if (needsBindVBuf) {
+        QVarLengthArray<D3D12_VERTEX_BUFFER_VIEW, 4> vbv;
+        vbv.reserve(bindingCount);
+
+        QD3D12GraphicsPipeline *psD = cbD->currentGraphicsPipeline;
+        const QRhiVertexInputLayout &inputLayout(psD->m_vertexInputLayout);
+        const int inputBindingCount = inputLayout.cendBindings() - inputLayout.cbeginBindings();
+
+        for (int i = 0, ie = qMin(bindingCount, inputBindingCount); i != ie; ++i) {
+            QD3D12Buffer *bufD = QRHI_RES(QD3D12Buffer, bindings[i].first);
+            const QD3D12ObjectHandle handle = bufD->handles[bufD->m_type == QRhiBuffer::Dynamic ? currentFrameSlot : 0];
+            const quint32 offset = bindings[i].second;
+            const quint32 stride = inputLayout.bindingAt(i)->stride();
+
+            if (bufD->m_type != QRhiBuffer::Dynamic) {
+                barrierGen.addTransitionBarrier(handle, D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER);
+                barrierGen.enqueueBufferedTransitionBarriers(cbD);
+            }
+
+            if (QD3D12Resource *res = resourcePool.lookupRef(handle)) {
+                vbv.append({
+                    res->resource->GetGPUVirtualAddress() + offset,
+                    UINT(res->desc.Width - offset),
+                    stride
+                });
+            }
+        }
+
+        cbD->cmdList->IASetVertexBuffers(UINT(startBinding), vbv.count(), vbv.constData());
+    }
+
+    if (indexBuf) {
+        QD3D12Buffer *ibufD = QRHI_RES(QD3D12Buffer, indexBuf);
+        Q_ASSERT(ibufD->m_usage.testFlag(QRhiBuffer::IndexBuffer));
+        const bool isDynamic = ibufD->m_type == QRhiBuffer::Dynamic;
+        if (isDynamic)
+            ibufD->executeHostWritesForFrameSlot(currentFrameSlot);
+
+        const DXGI_FORMAT dxgiFormat = indexFormat == QRhiCommandBuffer::IndexUInt16 ? DXGI_FORMAT_R16_UINT
+                                                                                     : DXGI_FORMAT_R32_UINT;
+        if (cbD->currentIndexBuffer != ibufD->handles[isDynamic ? currentFrameSlot : 0]
+                || cbD->currentIndexOffset != indexOffset
+                || cbD->currentIndexFormat != dxgiFormat)
+        {
+            cbD->currentIndexBuffer = ibufD->handles[isDynamic ? currentFrameSlot : 0];
+            cbD->currentIndexOffset = indexOffset;
+            cbD->currentIndexFormat = dxgiFormat;
+
+            if (ibufD->m_type != QRhiBuffer::Dynamic) {
+                barrierGen.addTransitionBarrier(cbD->currentIndexBuffer, D3D12_RESOURCE_STATE_INDEX_BUFFER);
+                barrierGen.enqueueBufferedTransitionBarriers(cbD);
+            }
+
+            if (QD3D12Resource *res = resourcePool.lookupRef(cbD->currentIndexBuffer)) {
+                const D3D12_INDEX_BUFFER_VIEW ibv = {
+                    res->resource->GetGPUVirtualAddress() + indexOffset,
+                    UINT(res->desc.Width - indexOffset),
+                    dxgiFormat
+                };
+                cbD->cmdList->IASetIndexBuffer(&ibv);
+            }
+        }
+    }
+}
+
+void QRhiD3D12::setViewport(QRhiCommandBuffer *cb, const QRhiViewport &viewport)
+{
+    QD3D12CommandBuffer *cbD = QRHI_RES(QD3D12CommandBuffer, cb);
+    Q_ASSERT(cbD->recordingPass == QD3D12CommandBuffer::RenderPass);
+    Q_ASSERT(cbD->currentTarget);
+    const QSize outputSize = cbD->currentTarget->pixelSize();
+
+    // D3D expects top-left, QRhiViewport is bottom-left
+    float x, y, w, h;
+    if (!qrhi_toTopLeftRenderTargetRect<UnBounded>(outputSize, viewport.viewport(), &x, &y, &w, &h))
+        return;
+
+    D3D12_VIEWPORT v;
+    v.TopLeftX = x;
+    v.TopLeftY = y;
+    v.Width = w;
+    v.Height = h;
+    v.MinDepth = viewport.minDepth();
+    v.MaxDepth = viewport.maxDepth();
+    cbD->cmdList->RSSetViewports(1, &v);
+
+    if (cbD->currentGraphicsPipeline
+            && !cbD->currentGraphicsPipeline->flags().testFlag(QRhiGraphicsPipeline::UsesScissor))
+    {
+        qrhi_toTopLeftRenderTargetRect<Bounded>(outputSize, viewport.viewport(), &x, &y, &w, &h);
+        D3D12_RECT r;
+        r.left = x;
+        r.top = y;
+        // right and bottom are exclusive
+        r.right = x + w;
+        r.bottom = y + h;
+        cbD->cmdList->RSSetScissorRects(1, &r);
+    }
+}
+
+void QRhiD3D12::setScissor(QRhiCommandBuffer *cb, const QRhiScissor &scissor)
+{
+    QD3D12CommandBuffer *cbD = QRHI_RES(QD3D12CommandBuffer, cb);
+    Q_ASSERT(cbD->recordingPass == QD3D12CommandBuffer::RenderPass);
+    Q_ASSERT(cbD->currentTarget);
+    const QSize outputSize = cbD->currentTarget->pixelSize();
+
+    // D3D expects top-left, QRhiScissor is bottom-left
+    int x, y, w, h;
+    if (!qrhi_toTopLeftRenderTargetRect<Bounded>(outputSize, scissor.scissor(), &x, &y, &w, &h))
+        return;
+
+    D3D12_RECT r;
+    r.left = x;
+    r.top = y;
+    // right and bottom are exclusive
+    r.right = x + w;
+    r.bottom = y + h;
+    cbD->cmdList->RSSetScissorRects(1, &r);
+}
+
+void QRhiD3D12::setBlendConstants(QRhiCommandBuffer *cb, const QColor &c)
+{
+    QD3D12CommandBuffer *cbD = QRHI_RES(QD3D12CommandBuffer, cb);
+    Q_ASSERT(cbD->recordingPass == QD3D12CommandBuffer::RenderPass);
+    float v[4] = { c.redF(), c.greenF(), c.blueF(), c.alphaF() };
+    cbD->cmdList->OMSetBlendFactor(v);
+}
+
+void QRhiD3D12::setStencilRef(QRhiCommandBuffer *cb, quint32 refValue)
+{
+    QD3D12CommandBuffer *cbD = QRHI_RES(QD3D12CommandBuffer, cb);
+    Q_ASSERT(cbD->recordingPass == QD3D12CommandBuffer::RenderPass);
+    cbD->cmdList->OMSetStencilRef(refValue);
+}
+
+void QRhiD3D12::draw(QRhiCommandBuffer *cb, quint32 vertexCount,
+                     quint32 instanceCount, quint32 firstVertex, quint32 firstInstance)
+{
+    QD3D12CommandBuffer *cbD = QRHI_RES(QD3D12CommandBuffer, cb);
+    Q_ASSERT(cbD->recordingPass == QD3D12CommandBuffer::RenderPass);
+    cbD->cmdList->DrawInstanced(vertexCount, instanceCount, firstVertex, firstInstance);
+}
+
+void QRhiD3D12::drawIndexed(QRhiCommandBuffer *cb, quint32 indexCount,
+                            quint32 instanceCount, quint32 firstIndex, qint32 vertexOffset, quint32 firstInstance)
+{
+    QD3D12CommandBuffer *cbD = QRHI_RES(QD3D12CommandBuffer, cb);
+    Q_ASSERT(cbD->recordingPass == QD3D12CommandBuffer::RenderPass);
+    cbD->cmdList->DrawIndexedInstanced(indexCount, instanceCount,
+                                       firstIndex, vertexOffset,
+                                       firstInstance);
+}
+
+void QRhiD3D12::debugMarkBegin(QRhiCommandBuffer *cb, const QByteArray &name)
+{
+    Q_UNUSED(cb);
+    Q_UNUSED(name);
+}
+
+void QRhiD3D12::debugMarkEnd(QRhiCommandBuffer *cb)
+{
+    Q_UNUSED(cb);
+}
+
+void QRhiD3D12::debugMarkMsg(QRhiCommandBuffer *cb, const QByteArray &msg)
+{
+    Q_UNUSED(cb);
+    Q_UNUSED(msg);
+}
+
+const QRhiNativeHandles *QRhiD3D12::nativeHandles(QRhiCommandBuffer *cb)
+{
+    return QRHI_RES(QD3D12CommandBuffer, cb)->nativeHandles();
+}
+
+void QRhiD3D12::beginExternal(QRhiCommandBuffer *cb)
+{
+    Q_UNUSED(cb);
+}
+
+void QRhiD3D12::endExternal(QRhiCommandBuffer *cb)
+{
+    QD3D12CommandBuffer *cbD = QRHI_RES(QD3D12CommandBuffer, cb);
+    cbD->resetPerPassState();
+    bindShaderVisibleHeaps(cbD);
+    if (cbD->currentTarget) { // could be compute, no rendertarget then
+        QD3D12RenderTargetData *rtD = rtData(cbD->currentTarget);
+        cbD->cmdList->OMSetRenderTargets(UINT(rtD->colorAttCount),
+                                         rtD->rtv,
+                                         TRUE,
+                                         rtD->dsAttCount ? &rtD->dsv : nullptr);
+    }
+}
+
+QRhi::FrameOpResult QRhiD3D12::beginFrame(QRhiSwapChain *swapChain, QRhi::BeginFrameFlags flags)
+{
+    Q_UNUSED(flags);
+
+    QD3D12SwapChain *swapChainD = QRHI_RES(QD3D12SwapChain, swapChain);
+    currentSwapChain = swapChainD;
+    currentFrameSlot = swapChainD->currentFrameSlot;
+    QD3D12SwapChain::FrameResources &fr(swapChainD->frameRes[currentFrameSlot]);
+
+    // We could do smarter things but mirror the Vulkan backend for now: Make
+    // sure the previous commands for this same frame slot have finished. Do
+    // this also for any other swapchain's commands with the same frame slot.
+    // While this reduces concurrency in render-to-swapchain-A,
+    // render-to-swapchain-B, repeat kind of scenarios, it keeps resource usage
+    // safe: swapchain A starting its frame 0, followed by swapchain B starting
+    // its own frame 0 will make B wait for A's frame 0 commands. If a resource
+    // is written in B's frame or when B checks for pending resource releases,
+    // that won't mess up A's in-flight commands (as they are guaranteed not to
+    // be in flight anymore). With Qt Quick this situation cannot happen anyway
+    // by design (one QRhi per window).
+    for (QD3D12SwapChain *sc : std::as_const(swapchains))
+        sc->waitCommandCompletionForFrameSlot(sc->currentFrameSlot);
+
+    HRESULT hr = cmdAllocators[currentFrameSlot]->Reset();
+    if (FAILED(hr)) {
+        qWarning("Failed to reset command allocator: %s",
+                 qPrintable(QSystemError::windowsComString(hr)));
+        return QRhi::FrameOpError;
+    }
+
+    if (!startCommandListForCurrentFrameSlot(&fr.cmdList))
+        return QRhi::FrameOpError;
+
+    QD3D12CommandBuffer *cbD = &swapChainD->cbWrapper;
+    cbD->cmdList = fr.cmdList;
+
+    swapChainD->rtWrapper.d.rtv[0] = swapChainD->sampleDesc.Count > 1
+            ? swapChainD->msaaRtvs[swapChainD->currentBackBufferIndex].cpuHandle
+            : swapChainD->rtvs[swapChainD->currentBackBufferIndex].cpuHandle;
+
+    swapChainD->rtWrapper.d.dsv = swapChainD->ds ? swapChainD->ds->dsv.cpuHandle
+                                                 : D3D12_CPU_DESCRIPTOR_HANDLE { 0 };
+
+    // Time to release things that are marked for currentFrameSlot since due to
+    // the wait above we know that the previous commands on the GPU for this
+    // slot must have finished already.
+    releaseQueue.executeDeferredReleases(currentFrameSlot);
+
+    // Full reset of the command buffer data.
+    cbD->resetState();
+
+    // Move the head back to zero for the per-frame shader-visible descriptor heap work areas.
+    shaderVisibleCbvSrvUavHeap.perFrameHeapSlice[currentFrameSlot].head = 0;
+    // Same for the small staging area.
+    smallStagingAreas[currentFrameSlot].head = 0;
+
+    bindShaderVisibleHeaps(cbD);
+
+    finishActiveReadbacks(); // last, in case the readback-completed callback issues rhi calls
+
+    return QRhi::FrameOpSuccess;
+}
+
+QRhi::FrameOpResult QRhiD3D12::endFrame(QRhiSwapChain *swapChain, QRhi::EndFrameFlags flags)
+{
+    QD3D12SwapChain *swapChainD = QRHI_RES(QD3D12SwapChain, swapChain);
+    Q_ASSERT(currentSwapChain == swapChainD);
+    QD3D12CommandBuffer *cbD = &swapChainD->cbWrapper;
+
+    QD3D12ObjectHandle backBufferResourceHandle = swapChainD->colorBuffers[swapChainD->currentBackBufferIndex];
+    if (swapChainD->sampleDesc.Count > 1) {
+        QD3D12ObjectHandle msaaBackBufferResourceHandle = swapChainD->msaaBuffers[swapChainD->currentBackBufferIndex];
+        barrierGen.addTransitionBarrier(msaaBackBufferResourceHandle, D3D12_RESOURCE_STATE_RESOLVE_SOURCE);
+        barrierGen.addTransitionBarrier(backBufferResourceHandle, D3D12_RESOURCE_STATE_RESOLVE_DEST);
+        barrierGen.enqueueBufferedTransitionBarriers(cbD);
+        const QD3D12Resource *src = resourcePool.lookupRef(msaaBackBufferResourceHandle);
+        const QD3D12Resource *dst = resourcePool.lookupRef(backBufferResourceHandle);
+        if (src && dst)
+            cbD->cmdList->ResolveSubresource(dst->resource, 0, src->resource, 0, swapChainD->colorFormat);
+    }
+
+    barrierGen.addTransitionBarrier(backBufferResourceHandle, D3D12_RESOURCE_STATE_PRESENT);
+    barrierGen.enqueueBufferedTransitionBarriers(cbD);
+
+    ID3D12GraphicsCommandList *cmdList = cbD->cmdList;
+    HRESULT hr = cmdList->Close();
+    if (FAILED(hr)) {
+        qWarning("Failed to close command list: %s",
+                 qPrintable(QSystemError::windowsComString(hr)));
+        return QRhi::FrameOpError;
+    }
+
+    ID3D12CommandList *execList[] = { cmdList };
+    cmdQueue->ExecuteCommandLists(1, execList);
+
+    if (!flags.testFlag(QRhi::SkipPresent)) {
+        UINT presentFlags = 0;
+        if (swapChainD->swapInterval == 0
+                && (swapChainD->swapChainFlags & DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING))
+        {
+            presentFlags |= DXGI_PRESENT_ALLOW_TEARING;
+        }
+        HRESULT hr = swapChainD->swapChain->Present(swapChainD->swapInterval, presentFlags);
+        if (hr == DXGI_ERROR_DEVICE_REMOVED || hr == DXGI_ERROR_DEVICE_RESET) {
+            qWarning("Device loss detected in Present()");
+            deviceLost = true;
+            return QRhi::FrameOpDeviceLost;
+        } else if (FAILED(hr)) {
+            qWarning("Failed to present: %s", qPrintable(QSystemError::windowsComString(hr)));
+            return QRhi::FrameOpError;
+        }
+
+        if (dcompDevice && swapChainD->dcompTarget && swapChainD->dcompVisual)
+            dcompDevice->Commit();
+    }
+
+    swapChainD->addCommandCompletionSignalForCurrentFrameSlot();
+
+    // NB! The deferred-release mechanism here differs from the older QRhi
+    // backends. There is no lastActiveFrameSlot tracking. Instead,
+    // currentFrameSlot is written to the registered entries now, and so the
+    // resources will get released in the frames_in_flight'th beginFrame()
+    // counting starting from now.
+    releaseQueue.activatePendingDeferredReleaseRequests(currentFrameSlot);
+
+    if (!flags.testFlag(QRhi::SkipPresent)) {
+        // Only move to the next slot if we presented. Otherwise will block and
+        // wait for completion in the next beginFrame already, but SkipPresent
+        // should be infrequent anyway.
+        swapChainD->currentFrameSlot = (swapChainD->currentFrameSlot + 1) % QD3D12_FRAMES_IN_FLIGHT;
+        swapChainD->currentBackBufferIndex = swapChainD->swapChain->GetCurrentBackBufferIndex();
+    }
+
+    currentSwapChain = nullptr;
+    return QRhi::FrameOpSuccess;
+}
+
+QRhi::FrameOpResult QRhiD3D12::beginOffscreenFrame(QRhiCommandBuffer **cb, QRhi::BeginFrameFlags flags)
+{
+    Q_UNUSED(flags);
+
+    // Switch to the next slot manually. Swapchains do not know about this
+    // which is good. So for example an onscreen, onscreen, offscreen,
+    // onscreen, onscreen, onscreen sequence of frames leads to 0, 1, 0, 0, 1,
+    // 0. (no strict alternation anymore) But this is not different from what
+    // happens when multiple swapchains are involved. Offscreen frames are
+    // synchronous anyway in the sense that they wait for execution to complete
+    // in endOffscreenFrame, so no resources used in that frame are busy
+    // anymore in the next frame.
+
+    currentFrameSlot = (currentFrameSlot + 1) % QD3D12_FRAMES_IN_FLIGHT;
+
+    for (QD3D12SwapChain *sc : std::as_const(swapchains))
+        sc->waitCommandCompletionForFrameSlot(currentFrameSlot); // note: not sc's currentFrameSlot
+
+    if (!offscreenCb[currentFrameSlot])
+        offscreenCb[currentFrameSlot] = new QD3D12CommandBuffer(this);
+    QD3D12CommandBuffer *cbD = offscreenCb[currentFrameSlot];
+    if (!startCommandListForCurrentFrameSlot(&cbD->cmdList))
+        return QRhi::FrameOpError;
+
+    releaseQueue.executeDeferredReleases(currentFrameSlot);
+    cbD->resetState();
+    shaderVisibleCbvSrvUavHeap.perFrameHeapSlice[currentFrameSlot].head = 0;
+    smallStagingAreas[currentFrameSlot].head = 0;
+
+    bindShaderVisibleHeaps(cbD);
+
+    offscreenActive = true;
+    *cb = cbD;
+
+    return QRhi::FrameOpSuccess;
+}
+
+QRhi::FrameOpResult QRhiD3D12::endOffscreenFrame(QRhi::EndFrameFlags flags)
+{
+    Q_UNUSED(flags);
+    Q_ASSERT(offscreenActive);
+    offscreenActive = false;
+
+    QD3D12CommandBuffer *cbD = offscreenCb[currentFrameSlot];
+    ID3D12GraphicsCommandList *cmdList = cbD->cmdList;
+    HRESULT hr = cmdList->Close();
+    if (FAILED(hr)) {
+        qWarning("Failed to close command list: %s",
+                 qPrintable(QSystemError::windowsComString(hr)));
+        return QRhi::FrameOpError;
+    }
+
+    ID3D12CommandList *execList[] = { cmdList };
+    cmdQueue->ExecuteCommandLists(1, execList);
+
+    releaseQueue.activatePendingDeferredReleaseRequests(currentFrameSlot);
+
+    // wait for completion
+    waitGpu();
+
+    // Here we know that executing the host-side reads for this (or any
+    // previous) frame is safe since we waited for completion above.
+    finishActiveReadbacks(true);
+
+    return QRhi::FrameOpSuccess;
+}
+
+QRhi::FrameOpResult QRhiD3D12::finish()
+{
+    if (!inFrame)
+        return QRhi::FrameOpSuccess;
+
+    QD3D12CommandBuffer *cbD = nullptr;
+    if (offscreenActive) {
+        Q_ASSERT(!currentSwapChain);
+        cbD = offscreenCb[currentFrameSlot];
+    } else {
+        Q_ASSERT(currentSwapChain);
+        cbD = &currentSwapChain->cbWrapper;
+    }
+    if (!cbD)
+        return QRhi::FrameOpError;
+
+    Q_ASSERT(cbD->recordingPass == QD3D12CommandBuffer::NoPass);
+
+    ID3D12GraphicsCommandList *cmdList = cbD->cmdList;
+    HRESULT hr = cmdList->Close();
+    if (FAILED(hr)) {
+        qWarning("Failed to close command list: %s",
+                 qPrintable(QSystemError::windowsComString(hr)));
+        return QRhi::FrameOpError;
+    }
+
+    ID3D12CommandList *execList[] = { cmdList };
+    cmdQueue->ExecuteCommandLists(1, execList);
+
+    releaseQueue.activatePendingDeferredReleaseRequests(currentFrameSlot);
+
+    // full blocking wait for everything, frame slots do not matter now
+    waitGpu();
+
+    hr = cmdAllocators[currentFrameSlot]->Reset();
+    if (FAILED(hr)) {
+        qWarning("Failed to reset command allocator: %s",
+                 qPrintable(QSystemError::windowsComString(hr)));
+        return QRhi::FrameOpError;
+    }
+
+    if (!startCommandListForCurrentFrameSlot(&cmdList))
+        return QRhi::FrameOpError;
+
+    cbD->resetState();
+
+    shaderVisibleCbvSrvUavHeap.perFrameHeapSlice[currentFrameSlot].head = 0;
+    smallStagingAreas[currentFrameSlot].head = 0;
+
+    bindShaderVisibleHeaps(cbD);
+
+    releaseQueue.executeDeferredReleases(currentFrameSlot);
+
+    finishActiveReadbacks(true);
+
+    return QRhi::FrameOpSuccess;
+}
+
+void QRhiD3D12::resourceUpdate(QRhiCommandBuffer *cb, QRhiResourceUpdateBatch *resourceUpdates)
+{
+    QD3D12CommandBuffer *cbD = QRHI_RES(QD3D12CommandBuffer, cb);
+    Q_ASSERT(cbD->recordingPass == QD3D12CommandBuffer::NoPass);
+    enqueueResourceUpdates(cbD, resourceUpdates);
+}
+
+void QRhiD3D12::beginPass(QRhiCommandBuffer *cb,
+                          QRhiRenderTarget *rt,
+                          const QColor &colorClearValue,
+                          const QRhiDepthStencilClearValue &depthStencilClearValue,
+                          QRhiResourceUpdateBatch *resourceUpdates,
+                          QRhiCommandBuffer::BeginPassFlags)
+{
+    QD3D12CommandBuffer *cbD = QRHI_RES(QD3D12CommandBuffer, cb);
+    Q_ASSERT(cbD->recordingPass == QD3D12CommandBuffer::NoPass);
+
+    if (resourceUpdates)
+        enqueueResourceUpdates(cbD, resourceUpdates);
+
+    QD3D12RenderTargetData *rtD = rtData(rt);
+    bool wantsColorClear = true;
+    bool wantsDsClear = true;
+    if (rt->resourceType() == QRhiRenderTarget::TextureRenderTarget) {
+        QD3D12TextureRenderTarget *rtTex = QRHI_RES(QD3D12TextureRenderTarget, rt);
+        wantsColorClear = !rtTex->m_flags.testFlag(QRhiTextureRenderTarget::PreserveColorContents);
+        wantsDsClear = !rtTex->m_flags.testFlag(QRhiTextureRenderTarget::PreserveDepthStencilContents);
+        if (!QRhiRenderTargetAttachmentTracker::isUpToDate<QD3D12Texture, QD3D12RenderBuffer>(rtTex->description(), rtD->currentResIdList))
+            rtTex->create();
+
+        for (auto it = rtTex->m_desc.cbeginColorAttachments(), itEnd = rtTex->m_desc.cendColorAttachments(); it != itEnd; ++it) {
+            QD3D12Texture *texD = QRHI_RES(QD3D12Texture, it->texture());
+            QD3D12Texture *resolveTexD = QRHI_RES(QD3D12Texture, it->resolveTexture());
+            QD3D12RenderBuffer *rbD = QRHI_RES(QD3D12RenderBuffer, it->renderBuffer());
+            if (texD)
+                barrierGen.addTransitionBarrier(texD->handle, D3D12_RESOURCE_STATE_RENDER_TARGET);
+            else if (rbD)
+                barrierGen.addTransitionBarrier(rbD->handle, D3D12_RESOURCE_STATE_RENDER_TARGET);
+            if (resolveTexD)
+                barrierGen.addTransitionBarrier(resolveTexD->handle, D3D12_RESOURCE_STATE_RENDER_TARGET);
+        }
+        if (rtTex->m_desc.depthStencilBuffer()) {
+            QD3D12RenderBuffer *rbD = QRHI_RES(QD3D12RenderBuffer, rtTex->m_desc.depthStencilBuffer());
+            Q_ASSERT(rbD->m_type == QRhiRenderBuffer::DepthStencil);
+            barrierGen.addTransitionBarrier(rbD->handle, D3D12_RESOURCE_STATE_DEPTH_WRITE);
+        } else if (rtTex->m_desc.depthTexture()) {
+            QD3D12Texture *depthTexD = QRHI_RES(QD3D12Texture, rtTex->m_desc.depthTexture());
+            barrierGen.addTransitionBarrier(depthTexD->handle, D3D12_RESOURCE_STATE_DEPTH_WRITE);
+        }
+        barrierGen.enqueueBufferedTransitionBarriers(cbD);
+    } else {
+        Q_ASSERT(currentSwapChain);
+        barrierGen.addTransitionBarrier(currentSwapChain->sampleDesc.Count > 1
+                                        ? currentSwapChain->msaaBuffers[currentSwapChain->currentBackBufferIndex]
+                                        : currentSwapChain->colorBuffers[currentSwapChain->currentBackBufferIndex],
+                                        D3D12_RESOURCE_STATE_RENDER_TARGET);
+        barrierGen.enqueueBufferedTransitionBarriers(cbD);
+    }
+
+    cbD->cmdList->OMSetRenderTargets(UINT(rtD->colorAttCount),
+                                     rtD->rtv,
+                                     TRUE,
+                                     rtD->dsAttCount ? &rtD->dsv : nullptr);
+
+    if (rtD->colorAttCount && wantsColorClear) {
+        float clearColor[4] = {
+            colorClearValue.redF(),
+            colorClearValue.greenF(),
+            colorClearValue.blueF(),
+            colorClearValue.alphaF()
+        };
+        for (int i = 0; i < rtD->colorAttCount; ++i)
+            cbD->cmdList->ClearRenderTargetView(rtD->rtv[i], clearColor, 0, nullptr);
+    }
+    if (rtD->dsAttCount && wantsDsClear) {
+        cbD->cmdList->ClearDepthStencilView(rtD->dsv,
+                                            D3D12_CLEAR_FLAGS(D3D12_CLEAR_FLAG_DEPTH | D3D12_CLEAR_FLAG_STENCIL),
+                                            depthStencilClearValue.depthClearValue(),
+                                            UINT8(depthStencilClearValue.stencilClearValue()),
+                                            0,
+                                            nullptr);
+    }
+
+    cbD->recordingPass = QD3D12CommandBuffer::RenderPass;
+    cbD->currentTarget = rt;
+
+    cbD->resetPerPassState();
+}
+
+void QRhiD3D12::endPass(QRhiCommandBuffer *cb, QRhiResourceUpdateBatch *resourceUpdates)
+{
+    QD3D12CommandBuffer *cbD = QRHI_RES(QD3D12CommandBuffer, cb);
+    Q_ASSERT(cbD->recordingPass == QD3D12CommandBuffer::RenderPass);
+
+    if (cbD->currentTarget->resourceType() == QRhiResource::TextureRenderTarget) {
+        QD3D12TextureRenderTarget *rtTex = QRHI_RES(QD3D12TextureRenderTarget, cbD->currentTarget);
+        for (auto it = rtTex->m_desc.cbeginColorAttachments(), itEnd = rtTex->m_desc.cendColorAttachments();
+             it != itEnd; ++it)
+        {
+            const QRhiColorAttachment &colorAtt(*it);
+            if (!colorAtt.resolveTexture())
+                continue;
+
+            QD3D12Texture *dstTexD = QRHI_RES(QD3D12Texture, colorAtt.resolveTexture());
+            QD3D12Resource *dstRes = resourcePool.lookupRef(dstTexD->handle);
+            if (!dstRes)
+                continue;
+
+            QD3D12Texture *srcTexD = QRHI_RES(QD3D12Texture, colorAtt.texture());
+            QD3D12RenderBuffer *srcRbD = QRHI_RES(QD3D12RenderBuffer, colorAtt.renderBuffer());
+            Q_ASSERT(srcTexD || srcRbD);
+            QD3D12Resource *srcRes = resourcePool.lookupRef(srcTexD ? srcTexD->handle : srcRbD->handle);
+            if (!srcRes)
+                continue;
+
+            if (srcTexD) {
+                if (srcTexD->dxgiFormat != dstTexD->dxgiFormat) {
+                    qWarning("Resolve source (%d) and destination (%d) formats do not match",
+                             int(srcTexD->dxgiFormat), int(dstTexD->dxgiFormat));
+                    continue;
+                }
+                if (srcTexD->sampleDesc.Count <= 1) {
+                    qWarning("Cannot resolve a non-multisample texture");
+                    continue;
+                }
+                if (srcTexD->m_pixelSize != dstTexD->m_pixelSize) {
+                    qWarning("Resolve source and destination sizes do not match");
+                    continue;
+                }
+            } else {
+                if (srcRbD->dxgiFormat != dstTexD->dxgiFormat) {
+                    qWarning("Resolve source (%d) and destination (%d) formats do not match",
+                             int(srcRbD->dxgiFormat), int(dstTexD->dxgiFormat));
+                    continue;
+                }
+                if (srcRbD->m_pixelSize != dstTexD->m_pixelSize) {
+                    qWarning("Resolve source and destination sizes do not match");
+                    continue;
+                }
+            }
+
+            barrierGen.addTransitionBarrier(srcTexD ? srcTexD->handle : srcRbD->handle, D3D12_RESOURCE_STATE_RESOLVE_SOURCE);
+            barrierGen.addTransitionBarrier(dstTexD->handle, D3D12_RESOURCE_STATE_RESOLVE_DEST);
+            barrierGen.enqueueBufferedTransitionBarriers(cbD);
+
+            const UINT srcSubresource = calcSubresource(0, UINT(colorAtt.layer()), 1);
+            const UINT dstSubresource = calcSubresource(UINT(colorAtt.resolveLevel()),
+                                                        UINT(colorAtt.resolveLayer()),
+                                                        dstTexD->mipLevelCount);
+            cbD->cmdList->ResolveSubresource(dstRes->resource, dstSubresource,
+                                             srcRes->resource, srcSubresource,
+                                             dstTexD->dxgiFormat);
+        }
+
+    }
+
+    cbD->recordingPass = QD3D12CommandBuffer::NoPass;
+    cbD->currentTarget = nullptr;
+
+    if (resourceUpdates)
+        enqueueResourceUpdates(cbD, resourceUpdates);
+}
+
+void QRhiD3D12::beginComputePass(QRhiCommandBuffer *cb,
+                                 QRhiResourceUpdateBatch *resourceUpdates,
+                                 QRhiCommandBuffer::BeginPassFlags)
+{
+    QD3D12CommandBuffer *cbD = QRHI_RES(QD3D12CommandBuffer, cb);
+    Q_ASSERT(cbD->recordingPass == QD3D12CommandBuffer::NoPass);
+
+    if (resourceUpdates)
+        enqueueResourceUpdates(cbD, resourceUpdates);
+
+    cbD->recordingPass = QD3D12CommandBuffer::ComputePass;
+
+    cbD->resetPerPassState();
+}
+
+void QRhiD3D12::endComputePass(QRhiCommandBuffer *cb, QRhiResourceUpdateBatch *resourceUpdates)
+{
+    QD3D12CommandBuffer *cbD = QRHI_RES(QD3D12CommandBuffer, cb);
+    Q_ASSERT(cbD->recordingPass == QD3D12CommandBuffer::ComputePass);
+
+    cbD->recordingPass = QD3D12CommandBuffer::NoPass;
+
+    if (resourceUpdates)
+        enqueueResourceUpdates(cbD, resourceUpdates);
+}
+
+void QRhiD3D12::setComputePipeline(QRhiCommandBuffer *cb, QRhiComputePipeline *ps)
+{
+    QD3D12CommandBuffer *cbD = QRHI_RES(QD3D12CommandBuffer, cb);
+    Q_ASSERT(cbD->recordingPass == QD3D12CommandBuffer::ComputePass);
+    QD3D12ComputePipeline *psD = QRHI_RES(QD3D12ComputePipeline, ps);
+    const bool pipelineChanged = cbD->currentComputePipeline != psD || cbD->currentPipelineGeneration != psD->generation;
+
+    if (pipelineChanged) {
+        cbD->currentGraphicsPipeline = nullptr;
+        cbD->currentComputePipeline = psD;
+        cbD->currentPipelineGeneration = psD->generation;
+
+        if (QD3D12Pipeline *pipeline = pipelinePool.lookupRef(psD->handle)) {
+            Q_ASSERT(pipeline->type == QD3D12Pipeline::Compute);
+            cbD->cmdList->SetPipelineState(pipeline->pso);
+            if (QD3D12RootSignature *rs = rootSignaturePool.lookupRef(psD->rootSigHandle))
+                cbD->cmdList->SetComputeRootSignature(rs->rootSig);
+        }
+    }
+}
+
+void QRhiD3D12::dispatch(QRhiCommandBuffer *cb, int x, int y, int z)
+{
+    QD3D12CommandBuffer *cbD = QRHI_RES(QD3D12CommandBuffer, cb);
+    Q_ASSERT(cbD->recordingPass == QD3D12CommandBuffer::ComputePass);
+    cbD->cmdList->Dispatch(UINT(x), UINT(y), UINT(z));
+}
+
+bool QD3D12DescriptorHeap::create(ID3D12Device *device,
+                                  quint32 descriptorCount,
+                                  D3D12_DESCRIPTOR_HEAP_TYPE heapType,
+                                  D3D12_DESCRIPTOR_HEAP_FLAGS heapFlags)
+{
+    head = 0;
+    capacity = descriptorCount;
+    this->heapType = heapType;
+    this->heapFlags = heapFlags;
+
+    D3D12_DESCRIPTOR_HEAP_DESC heapDesc = {};
+    heapDesc.Type = heapType;
+    heapDesc.NumDescriptors = capacity;
+    heapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAGS(heapFlags);
+
+    HRESULT hr = device->CreateDescriptorHeap(&heapDesc, IID_PPV_ARGS(&heap));
+    if (FAILED(hr)) {
+        qWarning("Failed to create descriptor heap: %s", qPrintable(QSystemError::windowsComString(hr)));
+        heap = nullptr;
+        capacity = descriptorByteSize = 0;
+        return false;
+    }
+
+    descriptorByteSize = device->GetDescriptorHandleIncrementSize(heapType);
+    heapStart.cpuHandle = heap->GetCPUDescriptorHandleForHeapStart();
+    if (heapFlags & D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE)
+        heapStart.gpuHandle = heap->GetGPUDescriptorHandleForHeapStart();
+
+    return true;
+}
+
+void QD3D12DescriptorHeap::createWithExisting(const QD3D12DescriptorHeap &other,
+                                              quint32 offsetInDescriptors,
+                                              quint32 descriptorCount)
+{
+    heap = nullptr;
+    head = 0;
+    capacity = descriptorCount;
+    heapType = other.heapType;
+    heapFlags = other.heapFlags;
+    descriptorByteSize = other.descriptorByteSize;
+    heapStart = incremented(other.heapStart, offsetInDescriptors);
+}
+
+void QD3D12DescriptorHeap::destroy()
+{
+    if (heap) {
+        heap->Release();
+        heap = nullptr;
+    }
+    capacity = 0;
+}
+
+void QD3D12DescriptorHeap::destroyWithDeferredRelease(QD3D12ReleaseQueue *releaseQueue)
+{
+    if (heap) {
+        releaseQueue->deferredReleaseDescriptorHeap(heap);
+        heap = nullptr;
+    }
+    capacity = 0;
+}
+
+QD3D12Descriptor QD3D12DescriptorHeap::get(quint32 count)
+{
+    Q_ASSERT(count > 0);
+    if (head + count > capacity) {
+        qWarning("Cannot get %u descriptors as that would exceed capacity %u", count, capacity);
+        return {};
+    }
+    head += count;
+    return at(head - count);
+}
+
+QD3D12Descriptor QD3D12DescriptorHeap::at(quint32 index) const
+{
+    const quint32 startOffset = index * descriptorByteSize;
+    QD3D12Descriptor result;
+    result.cpuHandle.ptr = heapStart.cpuHandle.ptr + startOffset;
+    if (heapStart.gpuHandle.ptr != 0)
+        result.gpuHandle.ptr = heapStart.gpuHandle.ptr + startOffset;
+    return result;
+}
+
+bool QD3D12CpuDescriptorPool::create(ID3D12Device *device, D3D12_DESCRIPTOR_HEAP_TYPE heapType, const char *debugName)
+{
+    QD3D12DescriptorHeap firstHeap;
+    if (!firstHeap.create(device, DESCRIPTORS_PER_HEAP, heapType, D3D12_DESCRIPTOR_HEAP_FLAG_NONE))
+        return false;
+    heaps.append(HeapWithMap::init(firstHeap, DESCRIPTORS_PER_HEAP));
+    descriptorByteSize = heaps[0].heap.descriptorByteSize;
+    this->device = device;
+    this->debugName = debugName;
+    return true;
+}
+
+void QD3D12CpuDescriptorPool::destroy()
+{
+#ifndef QT_NO_DEBUG
+    // debug builds: just do it always
+    static bool leakCheck = true;
+#else
+    // release builds: opt-in
+    static bool leakCheck = qEnvironmentVariableIntValue("QT_RHI_LEAK_CHECK");
+#endif
+    if (leakCheck) {
+        for (HeapWithMap &heap : heaps) {
+            const int leakedDescriptorCount = heap.map.count(true);
+            if (leakedDescriptorCount > 0) {
+                qWarning("QD3D12CpuDescriptorPool::destroy(): "
+                         "Heap %p for descriptor pool %p '%s' has %d unreleased descriptors",
+                         &heap.heap, this, debugName, leakedDescriptorCount);
+            }
+        }
+    }
+    for (HeapWithMap &heap : heaps)
+        heap.heap.destroy();
+    heaps.clear();
+}
+
+QD3D12Descriptor QD3D12CpuDescriptorPool::allocate(quint32 count)
+{
+    Q_ASSERT(count > 0 && count <= DESCRIPTORS_PER_HEAP);
+
+    HeapWithMap &last(heaps.last());
+    if (last.heap.head + count <= last.heap.capacity) {
+        quint32 firstIndex = last.heap.head;
+        for (quint32 i = 0; i < count; ++i)
+            last.map.setBit(firstIndex + i);
+        return last.heap.get(count);
+    }
+
+    for (HeapWithMap &heap : heaps) {
+        quint32 freeCount = 0;
+        for (quint32 i = 0; i < DESCRIPTORS_PER_HEAP; ++i) {
+            if (heap.map.testBit(i)) {
+                freeCount = 0;
+            } else {
+                freeCount += 1;
+                if (freeCount == count) {
+                    quint32 firstIndex = i - (freeCount - 1);
+                    for (quint32 j = 0; j < count; ++j) {
+                        heap.map.setBit(firstIndex + j);
+                        return heap.heap.at(firstIndex);
+                    }
+                }
+            }
+        }
+    }
+
+    QD3D12DescriptorHeap newHeap;
+    if (!newHeap.create(device, DESCRIPTORS_PER_HEAP, last.heap.heapType, last.heap.heapFlags))
+        return {};
+
+    heaps.append(HeapWithMap::init(newHeap, DESCRIPTORS_PER_HEAP));
+
+    for (quint32 i = 0; i < count; ++i)
+        heaps.last().map.setBit(i);
+
+    return heaps.last().heap.get(count);
+}
+
+void QD3D12CpuDescriptorPool::release(const QD3D12Descriptor &descriptor, quint32 count)
+{
+    Q_ASSERT(count > 0 && count <= DESCRIPTORS_PER_HEAP);
+    if (!descriptor.isValid())
+        return;
+
+    const SIZE_T addr = descriptor.cpuHandle.ptr;
+    for (HeapWithMap &heap : heaps) {
+        const SIZE_T begin = heap.heap.heapStart.cpuHandle.ptr;
+        const SIZE_T end = begin + heap.heap.descriptorByteSize * heap.heap.capacity;
+        if (addr >= begin && addr < end) {
+            quint32 firstIndex = (addr - begin) / heap.heap.descriptorByteSize;
+            for (quint32 i = 0; i < count; ++i)
+                heap.map.setBit(firstIndex + i, false);
+            return;
+        }
+    }
+
+    qWarning("QD3D12CpuDescriptorPool::release: Descriptor with address %llu is not in any heap",
+             quint64(descriptor.cpuHandle.ptr));
+}
+
+bool QD3D12StagingArea::create(QRhiD3D12 *rhi, quint32 capacity, D3D12_HEAP_TYPE heapType)
+{
+    Q_ASSERT(heapType == D3D12_HEAP_TYPE_UPLOAD || heapType == D3D12_HEAP_TYPE_READBACK);
+    D3D12_RESOURCE_DESC resourceDesc = {};
+    resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
+    resourceDesc.Width = capacity;
+    resourceDesc.Height = 1;
+    resourceDesc.DepthOrArraySize = 1;
+    resourceDesc.MipLevels = 1;
+    resourceDesc.Format = DXGI_FORMAT_UNKNOWN;
+    resourceDesc.SampleDesc = { 1, 0 };
+    resourceDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
+    resourceDesc.Flags = D3D12_RESOURCE_FLAG_NONE;
+    UINT state = heapType == D3D12_HEAP_TYPE_UPLOAD ? D3D12_RESOURCE_STATE_GENERIC_READ : D3D12_RESOURCE_STATE_COPY_DEST;
+    HRESULT hr = rhi->vma.createResource(heapType,
+                                         &resourceDesc,
+                                         D3D12_RESOURCE_STATES(state),
+                                         nullptr,
+                                         &allocation,
+                                         IID_PPV_ARGS(&resource));
+    if (FAILED(hr)) {
+        qWarning("Failed to create buffer for staging area: %s",
+                 qPrintable(QSystemError::windowsComString(hr)));
+        return false;
+    }
+    void *p = nullptr;
+    hr = resource->Map(0, nullptr, &p);
+    if (FAILED(hr)) {
+        qWarning("Failed to map buffer for staging area: %s",
+                 qPrintable(QSystemError::windowsComString(hr)));
+        destroy();
+        return false;
+    }
+
+    mem.p = static_cast<quint8 *>(p);
+    mem.gpuAddr = resource->GetGPUVirtualAddress();
+    mem.buffer = resource;
+    mem.bufferOffset = 0;
+
+    this->capacity = capacity;
+    head = 0;
+
+    return true;
+}
+
+void QD3D12StagingArea::destroy()
+{
+    if (resource) {
+        resource->Release();
+        resource = nullptr;
+    }
+    if (allocation) {
+        allocation->Release();
+        allocation = nullptr;
+    }
+    mem = {};
+}
+
+void QD3D12StagingArea::destroyWithDeferredRelease(QD3D12ReleaseQueue *releaseQueue)
+{
+    if (resource)
+        releaseQueue->deferredReleaseResourceAndAllocation(resource, allocation);
+    mem = {};
+}
+
+QD3D12StagingArea::Allocation QD3D12StagingArea::get(quint32 byteSize)
+{
+    const quint32 allocSize = aligned(byteSize, ALIGNMENT);
+    if (head + allocSize > capacity) {
+        qWarning("Failed to allocate %u (%u) bytes from staging area of size %u with %u bytes left",
+                 allocSize, byteSize, capacity, remainingCapacity());
+        return {};
+    }
+    const quint32 offset = head;
+    head += allocSize;
+    return {
+        mem.p + offset,
+        mem.gpuAddr + offset,
+        mem.buffer,
+        offset
+    };
+}
+
+// Can be called inside and outside of begin-endFrame. Removes from the pool
+// and releases the underlying native resource only in the frames_in_flight'th
+// beginFrame() counted starting from the next endFrame().
+void QD3D12ReleaseQueue::deferredReleaseResource(const QD3D12ObjectHandle &handle)
+{
+    DeferredReleaseEntry e;
+    e.handle = handle;
+    queue.append(e);
+}
+
+void QD3D12ReleaseQueue::deferredReleaseResourceWithViews(const QD3D12ObjectHandle &handle,
+                                                          QD3D12CpuDescriptorPool *pool,
+                                                          const QD3D12Descriptor &viewsStart,
+                                                          int viewCount)
+{
+    DeferredReleaseEntry e;
+    e.type = DeferredReleaseEntry::Resource;
+    e.handle = handle;
+    e.poolForViews = pool;
+    e.viewsStart = viewsStart;
+    e.viewCount = viewCount;
+    queue.append(e);
+}
+
+void QD3D12ReleaseQueue::deferredReleasePipeline(const QD3D12ObjectHandle &handle)
+{
+    DeferredReleaseEntry e;
+    e.type = DeferredReleaseEntry::Pipeline;
+    e.handle = handle;
+    queue.append(e);
+}
+
+void QD3D12ReleaseQueue::deferredReleaseRootSignature(const QD3D12ObjectHandle &handle)
+{
+    DeferredReleaseEntry e;
+    e.type = DeferredReleaseEntry::RootSignature;
+    e.handle = handle;
+    queue.append(e);
+}
+
+void QD3D12ReleaseQueue::deferredReleaseCallback(std::function<void(void*)> callback, void *userData)
+{
+    DeferredReleaseEntry e;
+    e.type = DeferredReleaseEntry::Callback;
+    e.callback = callback;
+    e.callbackUserData = userData;
+    queue.append(e);
+}
+
+void QD3D12ReleaseQueue::deferredReleaseResourceAndAllocation(ID3D12Resource *resource,
+                                                              D3D12MA::Allocation *allocation)
+{
+    DeferredReleaseEntry e;
+    e.type = DeferredReleaseEntry::ResourceAndAllocation;
+    e.resourceAndAllocation = { resource, allocation };
+    queue.append(e);
+}
+
+void QD3D12ReleaseQueue::deferredReleaseDescriptorHeap(ID3D12DescriptorHeap *heap)
+{
+    DeferredReleaseEntry e;
+    e.type = DeferredReleaseEntry::DescriptorHeap;
+    e.descriptorHeap = heap;
+    queue.append(e);
+}
+
+void QD3D12ReleaseQueue::deferredReleaseViews(QD3D12CpuDescriptorPool *pool,
+                                              const QD3D12Descriptor &viewsStart,
+                                              int viewCount)
+{
+    DeferredReleaseEntry e;
+    e.type = DeferredReleaseEntry::Views;
+    e.poolForViews = pool;
+    e.viewsStart = viewsStart;
+    e.viewCount = viewCount;
+    queue.append(e);
+}
+
+void QD3D12ReleaseQueue::activatePendingDeferredReleaseRequests(int frameSlot)
+{
+    for (DeferredReleaseEntry &e : queue) {
+        if (!e.frameSlotToBeReleasedIn.has_value())
+            e.frameSlotToBeReleasedIn = frameSlot;
+    }
+}
+
+void QD3D12ReleaseQueue::executeDeferredReleases(int frameSlot, bool forced)
+{
+    for (int i = queue.count() - 1; i >= 0; --i) {
+        const DeferredReleaseEntry &e(queue[i]);
+        if (forced || (e.frameSlotToBeReleasedIn.has_value() && e.frameSlotToBeReleasedIn.value() == frameSlot)) {
+            switch (e.type) {
+            case DeferredReleaseEntry::Resource:
+                resourcePool->remove(e.handle);
+                if (e.poolForViews && e.viewsStart.isValid() && e.viewCount > 0)
+                    e.poolForViews->release(e.viewsStart, e.viewCount);
+                break;
+            case DeferredReleaseEntry::Pipeline:
+                pipelinePool->remove(e.handle);
+                break;
+            case DeferredReleaseEntry::RootSignature:
+                rootSignaturePool->remove(e.handle);
+                break;
+            case DeferredReleaseEntry::Callback:
+                e.callback(e.callbackUserData);
+                break;
+            case DeferredReleaseEntry::ResourceAndAllocation:
+                // order matters: resource first, then the allocation (which
+                // may be null)
+                e.resourceAndAllocation.first->Release();
+                if (e.resourceAndAllocation.second)
+                    e.resourceAndAllocation.second->Release();
+                break;
+            case DeferredReleaseEntry::DescriptorHeap:
+                e.descriptorHeap->Release();
+                break;
+            case DeferredReleaseEntry::Views:
+                e.poolForViews->release(e.viewsStart, e.viewCount);
+                break;
+            }
+            queue.removeAt(i);
+        }
+    }
+}
+
+void QD3D12ReleaseQueue::releaseAll()
+{
+    executeDeferredReleases(0, true);
+}
+
+void QD3D12ResourceBarrierGenerator::addTransitionBarrier(const QD3D12ObjectHandle &resourceHandle,
+                                                          D3D12_RESOURCE_STATES stateAfter)
+{
+    if (QD3D12Resource *res = resourcePool->lookupRef(resourceHandle)) {
+        if (stateAfter != res->state) {
+            transitionResourceBarriers.append({ resourceHandle, res->state, stateAfter });
+            res->state = stateAfter;
+        }
+    }
+}
+
+void QD3D12ResourceBarrierGenerator::enqueueBufferedTransitionBarriers(QD3D12CommandBuffer *cbD)
+{
+    QVarLengthArray<D3D12_RESOURCE_BARRIER, PREALLOC> barriers;
+    for (const TransitionResourceBarrier &trb : transitionResourceBarriers) {
+        if (QD3D12Resource *res = resourcePool->lookupRef(trb.resourceHandle)) {
+            D3D12_RESOURCE_BARRIER barrier = {};
+            barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
+            barrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
+            barrier.Transition.pResource = res->resource;
+            barrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
+            barrier.Transition.StateBefore = trb.stateBefore;
+            barrier.Transition.StateAfter = trb.stateAfter;
+            barriers.append(barrier);
+        }
+    }
+    transitionResourceBarriers.clear();
+    if (!barriers.isEmpty())
+        cbD->cmdList->ResourceBarrier(barriers.count(), barriers.constData());
+}
+
+void QD3D12ResourceBarrierGenerator::enqueueSubresourceTransitionBarrier(QD3D12CommandBuffer *cbD,
+                                                                         const QD3D12ObjectHandle &resourceHandle,
+                                                                         UINT subresource,
+                                                                         D3D12_RESOURCE_STATES stateBefore,
+                                                                         D3D12_RESOURCE_STATES stateAfter)
+{
+    if (QD3D12Resource *res = resourcePool->lookupRef(resourceHandle)) {
+        D3D12_RESOURCE_BARRIER barrier = {};
+        barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
+        barrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
+        barrier.Transition.pResource = res->resource;
+        barrier.Transition.Subresource = subresource;
+        barrier.Transition.StateBefore = stateBefore;
+        barrier.Transition.StateAfter = stateAfter;
+        cbD->cmdList->ResourceBarrier(1, &barrier);
+    }
+}
+
+void QD3D12ResourceBarrierGenerator::enqueueUavBarrier(QD3D12CommandBuffer *cbD,
+                                                       const QD3D12ObjectHandle &resourceHandle)
+{
+    if (QD3D12Resource *res = resourcePool->lookupRef(resourceHandle)) {
+        D3D12_RESOURCE_BARRIER barrier = {};
+        barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_UAV;
+        barrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
+        barrier.UAV.pResource = res->resource;
+        cbD->cmdList->ResourceBarrier(1, &barrier);
+    }
+}
+
+void QD3D12ShaderBytecodeCache::insertWithCapacityLimit(const QRhiShaderStage &key, const Shader &s)
+{
+    if (data.count() >= QRhiD3D12::MAX_SHADER_CACHE_ENTRIES)
+        data.clear();
+    data.insert(key, s);
+}
+
+bool QD3D12ShaderVisibleDescriptorHeap::create(ID3D12Device *device,
+                                               D3D12_DESCRIPTOR_HEAP_TYPE type,
+                                               quint32 perFrameDescriptorCount)
+{
+    Q_ASSERT(type == D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV || type == D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER);
+
+    quint32 size = perFrameDescriptorCount * QD3D12_FRAMES_IN_FLIGHT;
+
+    // https://learn.microsoft.com/en-us/windows/win32/direct3d12/hardware-support
+    const quint32 CBV_SRV_UAV_MAX = 1000000;
+    const quint32 SAMPLER_MAX = 2048;
+    if (type == D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV)
+        size = qMin(size, CBV_SRV_UAV_MAX);
+    else if (type == D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER)
+        size = qMin(size, SAMPLER_MAX);
+
+    if (!heap.create(device, size, type, D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE)) {
+        qWarning("Failed to create shader-visible descriptor heap of size %u", size);
+        return false;
+    }
+
+    perFrameDescriptorCount = size / QD3D12_FRAMES_IN_FLIGHT;
+    quint32 currentOffsetInDescriptors = 0;
+    for (int i = 0; i < QD3D12_FRAMES_IN_FLIGHT; ++i) {
+        perFrameHeapSlice[i].createWithExisting(heap, currentOffsetInDescriptors, perFrameDescriptorCount);
+        currentOffsetInDescriptors += perFrameDescriptorCount;
+    }
+
+    return true;
+}
+
+void QD3D12ShaderVisibleDescriptorHeap::destroy()
+{
+    heap.destroy();
+}
+
+void QD3D12ShaderVisibleDescriptorHeap::destroyWithDeferredRelease(QD3D12ReleaseQueue *releaseQueue)
+{
+    heap.destroyWithDeferredRelease(releaseQueue);
+}
+
+static inline QPair<int, int> mapBinding(int binding, const QShader::NativeResourceBindingMap &map)
+{
+    if (map.isEmpty())
+        return { binding, binding }; // assume 1:1 mapping
+
+    auto it = map.constFind(binding);
+    if (it != map.cend())
+        return *it;
+
+    // Hitting this path is normal too. It is not given that the resource is
+    // present in the shaders for all the stages specified by the visibility
+    // mask in the QRhiShaderResourceBinding.
+    return { -1, -1 };
+}
+
+void QD3D12ShaderResourceVisitor::visit()
+{
+    for (int bindingIdx = 0, bindingCount = srb->sortedBindings.count(); bindingIdx != bindingCount; ++bindingIdx) {
+        const QRhiShaderResourceBinding &b(srb->sortedBindings[bindingIdx]);
+        const QRhiShaderResourceBinding::Data *bd = QRhiImplementation::shaderResourceBindingData(b);
+
+        for (int stageIdx = 0; stageIdx < stageCount; ++stageIdx) {
+            const QD3D12ShaderStageData *sd = &stageData[stageIdx];
+            if (!sd->valid)
+                continue;
+
+            if (!bd->stage.testFlag(qd3d12_stageToSrb(sd->stage)))
+                continue;
+
+            switch (bd->type) {
+            case QRhiShaderResourceBinding::UniformBuffer:
+            {
+                const int shaderRegister = mapBinding(bd->binding, sd->nativeResourceBindingMap).first;
+                if (shaderRegister >= 0 && uniformBuffer)
+                    uniformBuffer(sd->stage, bd->u.ubuf, shaderRegister, bd->binding);
+            }
+                break;
+            case QRhiShaderResourceBinding::SampledTexture:
+            {
+                Q_ASSERT(bd->u.stex.count > 0);
+                const int textureBaseShaderRegister = mapBinding(bd->binding, sd->nativeResourceBindingMap).first;
+                const int samplerBaseShaderRegister = mapBinding(bd->binding, sd->nativeResourceBindingMap).second;
+                for (int i = 0; i < bd->u.stex.count; ++i) {
+                    if (textureBaseShaderRegister >= 0 && texture)
+                        texture(sd->stage, bd->u.stex.texSamplers[i], textureBaseShaderRegister + i);
+                    if (samplerBaseShaderRegister >= 0 && sampler)
+                        sampler(sd->stage, bd->u.stex.texSamplers[i], samplerBaseShaderRegister + i);
+                }
+            }
+                break;
+            case QRhiShaderResourceBinding::Texture:
+            {
+                Q_ASSERT(bd->u.stex.count > 0);
+                const int baseShaderRegister = mapBinding(bd->binding, sd->nativeResourceBindingMap).first;
+                if (baseShaderRegister >= 0 && texture) {
+                    for (int i = 0; i < bd->u.stex.count; ++i)
+                        texture(sd->stage, bd->u.stex.texSamplers[i], baseShaderRegister + i);
+                }
+            }
+                break;
+            case QRhiShaderResourceBinding::Sampler:
+            {
+                Q_ASSERT(bd->u.stex.count > 0);
+                const int baseShaderRegister = mapBinding(bd->binding, sd->nativeResourceBindingMap).first;
+                if (baseShaderRegister >= 0 && sampler) {
+                    for (int i = 0; i < bd->u.stex.count; ++i)
+                        sampler(sd->stage, bd->u.stex.texSamplers[i], baseShaderRegister + i);
+                }
+            }
+                break;
+            case QRhiShaderResourceBinding::ImageLoad:
+            {
+                const int shaderRegister = mapBinding(bd->binding, sd->nativeResourceBindingMap).first;
+                if (shaderRegister >= 0 && storageImage)
+                    storageImage(sd->stage, bd->u.simage, Load, shaderRegister);
+            }
+                break;
+            case QRhiShaderResourceBinding::ImageStore:
+            {
+                const int shaderRegister = mapBinding(bd->binding, sd->nativeResourceBindingMap).first;
+                if (shaderRegister >= 0 && storageImage)
+                    storageImage(sd->stage, bd->u.simage, Store, shaderRegister);
+            }
+                break;
+            case QRhiShaderResourceBinding::ImageLoadStore:
+            {
+                const int shaderRegister = mapBinding(bd->binding, sd->nativeResourceBindingMap).first;
+                if (shaderRegister >= 0 && storageImage)
+                    storageImage(sd->stage, bd->u.simage, LoadStore, shaderRegister);
+            }
+                break;
+            case QRhiShaderResourceBinding::BufferLoad:
+            {
+                const int shaderRegister = mapBinding(bd->binding, sd->nativeResourceBindingMap).first;
+                if (shaderRegister >= 0 && storageBuffer)
+                    storageBuffer(sd->stage, bd->u.sbuf, Load, shaderRegister);
+            }
+                break;
+            case QRhiShaderResourceBinding::BufferStore:
+            {
+                const int shaderRegister = mapBinding(bd->binding, sd->nativeResourceBindingMap).first;
+                if (shaderRegister >= 0 && storageBuffer)
+                    storageBuffer(sd->stage, bd->u.sbuf, Store, shaderRegister);
+            }
+                break;
+            case QRhiShaderResourceBinding::BufferLoadStore:
+            {
+                const int shaderRegister = mapBinding(bd->binding, sd->nativeResourceBindingMap).first;
+                if (shaderRegister >= 0 && storageBuffer)
+                    storageBuffer(sd->stage, bd->u.sbuf, LoadStore, shaderRegister);
+            }
+                break;
+            }
+        }
+    }
+}
+
+bool QD3D12SamplerManager::create(ID3D12Device *device)
+{
+    // This does not need to be per-frame slot, just grab space for MAX_SAMPLERS samplers.
+    if (!shaderVisibleSamplerHeap.create(device,
+                                         D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER,
+                                         MAX_SAMPLERS / QD3D12_FRAMES_IN_FLIGHT))
+    {
+        qWarning("Could not create shader-visible SAMPLER heap");
+        return false;
+    }
+
+    this->device = device;
+    return true;
+}
+
+void QD3D12SamplerManager::destroy()
+{
+    if (device) {
+        shaderVisibleSamplerHeap.destroy();
+        device = nullptr;
+    }
+}
+
+QD3D12Descriptor QD3D12SamplerManager::getShaderVisibleDescriptor(const D3D12_SAMPLER_DESC &desc)
+{
+    auto it = gpuMap.constFind({desc});
+    if (it != gpuMap.cend())
+        return *it;
+
+    QD3D12Descriptor descriptor = shaderVisibleSamplerHeap.heap.get(1);
+    if (descriptor.isValid()) {
+        device->CreateSampler(&desc, descriptor.cpuHandle);
+        gpuMap.insert({desc}, descriptor);
+    } else {
+        qWarning("Out of shader-visible SAMPLER descriptor heap space,"
+                 " this should not happen, maximum number of unique samplers is %u",
+                 shaderVisibleSamplerHeap.heap.capacity);
+    }
+
+    return descriptor;
+}
+
+bool QD3D12MipmapGenerator::create(QRhiD3D12 *rhiD)
+{
+    if (!QtD3D12ApiSupport::instance()->isAvailable())
+        return false;
+
+    this->rhiD = rhiD;
+
+    D3D12_ROOT_PARAMETER1 rootParams[3] = {};
+    D3D12_DESCRIPTOR_RANGE1 descriptorRanges[2] = {};
+
+    // b0
+    rootParams[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
+    rootParams[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;
+
+    // t0
+    descriptorRanges[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
+    descriptorRanges[0].NumDescriptors = 1;
+    descriptorRanges[0].Flags = D3D12_DESCRIPTOR_RANGE_FLAG_DATA_VOLATILE;
+    rootParams[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
+    rootParams[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;
+    rootParams[1].DescriptorTable.NumDescriptorRanges = 1;
+    rootParams[1].DescriptorTable.pDescriptorRanges = &descriptorRanges[0];
+
+    // u0..3
+    descriptorRanges[1].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_UAV;
+    descriptorRanges[1].NumDescriptors = 4;
+    rootParams[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
+    rootParams[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;
+    rootParams[2].DescriptorTable.NumDescriptorRanges = 1;
+    rootParams[2].DescriptorTable.pDescriptorRanges = &descriptorRanges[1];
+
+    // s0
+    D3D12_STATIC_SAMPLER_DESC samplerDesc = {};
+    samplerDesc.Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;
+    samplerDesc.AddressU = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
+    samplerDesc.AddressV = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
+    samplerDesc.AddressW = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
+    samplerDesc.MaxLOD = 10000.0f;
+    samplerDesc.ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;
+
+    D3D12_VERSIONED_ROOT_SIGNATURE_DESC rsDesc = {};
+    rsDesc.Version = D3D_ROOT_SIGNATURE_VERSION_1_1;
+    rsDesc.Desc_1_1.NumParameters = 3;
+    rsDesc.Desc_1_1.pParameters = rootParams;
+    rsDesc.Desc_1_1.NumStaticSamplers = 1;
+    rsDesc.Desc_1_1.pStaticSamplers = &samplerDesc;
+
+    ID3DBlob *signature = nullptr;
+    HRESULT hr = QtD3D12ApiSupport::instance()->pD3D12SerializeVersionedRootSignature(&rsDesc, &signature, nullptr);
+    if (FAILED(hr)) {
+        qWarning("Failed to serialize root signature: %s", qPrintable(QSystemError::windowsComString(hr)));
+        return false;
+    }
+    ID3D12RootSignature *rootSig = nullptr;
+    hr = rhiD->dev->CreateRootSignature(0,
+                                        signature->GetBufferPointer(),
+                                        signature->GetBufferSize(),
+                                        IID_PPV_ARGS(&rootSig));
+    signature->Release();
+    if (FAILED(hr)) {
+        qWarning("Failed to create root signature: %s",
+                 qPrintable(QSystemError::windowsComString(hr)));
+        return false;
+    }
+
+    rootSigHandle = QD3D12RootSignature::addToPool(&rhiD->rootSignaturePool, rootSig);
+
+    D3D12_COMPUTE_PIPELINE_STATE_DESC psoDesc = {};
+    psoDesc.pRootSignature = rootSig;
+    psoDesc.CS.pShaderBytecode = g_csMipmap;
+    psoDesc.CS.BytecodeLength = sizeof(g_csMipmap);
+    ID3D12PipelineState *pso = nullptr;
+    hr = rhiD->dev->CreateComputePipelineState(&psoDesc, IID_PPV_ARGS(&pso));
+    if (FAILED(hr)) {
+        qWarning("Failed to create compute pipeline state: %s",
+                 qPrintable(QSystemError::windowsComString(hr)));
+        rhiD->rootSignaturePool.remove(rootSigHandle);
+        rootSigHandle = {};
+        return false;
+    }
+
+    pipelineHandle = QD3D12Pipeline::addToPool(&rhiD->pipelinePool, QD3D12Pipeline::Compute, pso);
+
+    return true;
+}
+
+void QD3D12MipmapGenerator::destroy()
+{
+    rhiD->pipelinePool.remove(pipelineHandle);
+    pipelineHandle = {};
+    rhiD->rootSignaturePool.remove(rootSigHandle);
+    rootSigHandle = {};
+}
+
+void QD3D12MipmapGenerator::generate(QD3D12CommandBuffer *cbD, const QD3D12ObjectHandle &textureHandle)
+{
+    QD3D12Pipeline *pipeline = rhiD->pipelinePool.lookupRef(pipelineHandle);
+    if (!pipeline)
+        return;
+    QD3D12RootSignature *rootSig = rhiD->rootSignaturePool.lookupRef(rootSigHandle);
+    if (!rootSig)
+        return;
+    QD3D12Resource *res = rhiD->resourcePool.lookupRef(textureHandle);
+    if (!res)
+        return;
+
+    const quint32 mipLevelCount = res->desc.MipLevels;
+    if (mipLevelCount < 2)
+        return;
+
+    if (res->desc.SampleDesc.Count > 1) {
+        qWarning("Cannot generate mipmaps for MSAA texture");
+        return;
+    }
+
+    const bool is1D = res->desc.Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE1D;
+    if (is1D) {
+        qWarning("Cannot generate mipmaps for 1D texture");
+        return;
+    }
+
+    const bool is3D = res->desc.Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE3D;
+    const bool isCubeOrArray = res->desc.Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE2D
+            && res->desc.DepthOrArraySize > 1;
+    const quint32 layerCount = isCubeOrArray ? res->desc.DepthOrArraySize : 1;
+
+    if (is3D) {
+        // ### needs its own shader and maybe a different solution
+        qWarning("3D texture mipmapping is not implemented for D3D12 atm");
+        return;
+    }
+
+    rhiD->barrierGen.addTransitionBarrier(textureHandle, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
+    rhiD->barrierGen.enqueueBufferedTransitionBarriers(cbD);
+
+    cbD->cmdList->SetPipelineState(pipeline->pso);
+    cbD->cmdList->SetComputeRootSignature(rootSig->rootSig);
+
+    const quint32 descriptorByteSize = rhiD->shaderVisibleCbvSrvUavHeap.perFrameHeapSlice[rhiD->currentFrameSlot].descriptorByteSize;
+
+    struct CBufData {
+        quint32 srcMipLevel;
+        quint32 numMipLevels;
+        float texelWidth;
+        float texelHeight;
+    };
+
+    const quint32 allocSize = QD3D12StagingArea::allocSizeForArray(sizeof(CBufData), mipLevelCount * layerCount);
+    std::optional<QD3D12StagingArea> ownStagingArea;
+    if (rhiD->smallStagingAreas[rhiD->currentFrameSlot].remainingCapacity() < allocSize) {
+        ownStagingArea = QD3D12StagingArea();
+        if (!ownStagingArea->create(rhiD, allocSize, D3D12_HEAP_TYPE_UPLOAD)) {
+            qWarning("Could not create staging area for mipmap generation");
+            return;
+        }
+    }
+    QD3D12StagingArea *workArea = ownStagingArea.has_value()
+            ? &ownStagingArea.value()
+            : &rhiD->smallStagingAreas[rhiD->currentFrameSlot];
+
+    bool gotNewHeap = false;
+    if (!rhiD->ensureShaderVisibleDescriptorHeapCapacity(&rhiD->shaderVisibleCbvSrvUavHeap,
+                                                         D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV,
+                                                         rhiD->currentFrameSlot,
+                                                         (1 + 4) * mipLevelCount * layerCount,
+                                                         &gotNewHeap))
+    {
+        qWarning("Could not ensure enough space in descriptor heap for mipmap generation");
+        return;
+    }
+    if (gotNewHeap)
+        rhiD->bindShaderVisibleHeaps(cbD);
+
+    for (quint32 layer = 0; layer < layerCount; ++layer) {
+        for (quint32 level = 0; level < mipLevelCount ;) {
+            UINT subresource = calcSubresource(level, layer, res->desc.MipLevels);
+            rhiD->barrierGen.enqueueSubresourceTransitionBarrier(cbD, textureHandle, subresource,
+                                                                 D3D12_RESOURCE_STATE_UNORDERED_ACCESS,
+                                                                 D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE);
+
+            quint32 levelPlusOneMipWidth = res->desc.Width >> (level + 1);
+            quint32 levelPlusOneMipHeight = res->desc.Height >> (level + 1);
+            const quint32 dw = levelPlusOneMipWidth == 1 ? levelPlusOneMipHeight : levelPlusOneMipWidth;
+            const quint32 dh = levelPlusOneMipHeight == 1 ? levelPlusOneMipWidth : levelPlusOneMipHeight;
+            // number of times the size can be halved while still resulting in an even dimension
+            const quint32 additionalMips = qCountTrailingZeroBits(dw | dh);
+            const quint32 numGenMips = qMin(1u + qMin(3u, additionalMips), res->desc.MipLevels - level);
+            levelPlusOneMipWidth = qMax(1u, levelPlusOneMipWidth);
+            levelPlusOneMipHeight = qMax(1u, levelPlusOneMipHeight);
+
+            CBufData cbufData = {
+                level,
+                numGenMips,
+                1.0f / float(levelPlusOneMipWidth),
+                1.0f / float(levelPlusOneMipHeight)
+            };
+
+            QD3D12StagingArea::Allocation cbuf = workArea->get(sizeof(cbufData));
+            memcpy(cbuf.p, &cbufData, sizeof(cbufData));
+            cbD->cmdList->SetComputeRootConstantBufferView(0, cbuf.gpuAddr);
+
+            QD3D12Descriptor srv = rhiD->shaderVisibleCbvSrvUavHeap.perFrameHeapSlice[rhiD->currentFrameSlot].get(1);
+            D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
+            srvDesc.Format = res->desc.Format;
+            srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
+            if (isCubeOrArray) {
+                srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2DARRAY;
+                srvDesc.Texture2DArray.MostDetailedMip = level;
+                srvDesc.Texture2DArray.MipLevels = 1;
+                srvDesc.Texture2DArray.FirstArraySlice = layer;
+                srvDesc.Texture2DArray.ArraySize = 1;
+            } else if (is3D) {
+                srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE3D;
+                srvDesc.Texture3D.MostDetailedMip = level;
+                srvDesc.Texture3D.MipLevels = 1;
+            } else {
+                srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
+                srvDesc.Texture2D.MostDetailedMip = level;
+                srvDesc.Texture2D.MipLevels = 1;
+            }
+            rhiD->dev->CreateShaderResourceView(res->resource, &srvDesc, srv.cpuHandle);
+            cbD->cmdList->SetComputeRootDescriptorTable(1, srv.gpuHandle);
+
+            QD3D12Descriptor uavStart = rhiD->shaderVisibleCbvSrvUavHeap.perFrameHeapSlice[rhiD->currentFrameSlot].get(4);
+            D3D12_CPU_DESCRIPTOR_HANDLE uavCpuHandle = uavStart.cpuHandle;
+            // if level is N, then need UAVs for levels N+1, ..., N+4
+            for (quint32 uavIdx = 0; uavIdx < 4; ++uavIdx) {
+                const quint32 uavMipLevel = qMin(level + 1u + uavIdx, res->desc.MipLevels - 1u);
+                D3D12_UNORDERED_ACCESS_VIEW_DESC uavDesc = {};
+                uavDesc.Format = res->desc.Format;
+                if (isCubeOrArray) {
+                    uavDesc.ViewDimension = D3D12_UAV_DIMENSION_TEXTURE2DARRAY;
+                    uavDesc.Texture2DArray.MipSlice = uavMipLevel;
+                    uavDesc.Texture2DArray.FirstArraySlice = layer;
+                    uavDesc.Texture2DArray.ArraySize = 1;
+                } else if (is3D) {
+                    uavDesc.ViewDimension = D3D12_UAV_DIMENSION_TEXTURE3D;
+                    uavDesc.Texture3D.MipSlice = uavMipLevel;
+                    uavDesc.Texture3D.FirstWSlice = 0; // depth etc. not implemented yet
+                    uavDesc.Texture3D.WSize = 1;
+                } else {
+                    uavDesc.ViewDimension = D3D12_UAV_DIMENSION_TEXTURE2D;
+                    uavDesc.Texture2D.MipSlice = uavMipLevel;
+                }
+                rhiD->dev->CreateUnorderedAccessView(res->resource, nullptr, &uavDesc, uavCpuHandle);
+                uavCpuHandle.ptr += descriptorByteSize;
+            }
+            cbD->cmdList->SetComputeRootDescriptorTable(2, uavStart.gpuHandle);
+
+            cbD->cmdList->Dispatch(levelPlusOneMipWidth, levelPlusOneMipHeight, 1);
+
+            rhiD->barrierGen.enqueueUavBarrier(cbD, textureHandle);
+            rhiD->barrierGen.enqueueSubresourceTransitionBarrier(cbD, textureHandle, subresource,
+                                                                 D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE,
+                                                                 D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
+
+            level += numGenMips;
+        }
+    }
+
+    if (ownStagingArea.has_value())
+        ownStagingArea->destroyWithDeferredRelease(&rhiD->releaseQueue);
+}
+
+bool QD3D12MemoryAllocator::create(ID3D12Device *device, IDXGIAdapter1 *adapter)
+{
+    this->device = device;
+
+    // We can function with and without D3D12MA: CreateCommittedResource is
+    // just fine for our purposes and not any complicated API-wise; the memory
+    // allocator is interesting for efficiency mainly since it can suballocate
+    // instead of making everything a committed resource allocation.
+
+    static bool disableMA = qEnvironmentVariableIntValue("QT_D3D_NO_SUBALLOC");
+    if (disableMA)
+        return true;
+
+    DXGI_ADAPTER_DESC1 desc;
+    adapter->GetDesc1(&desc);
+    if (desc.Flags & DXGI_ADAPTER_FLAG_SOFTWARE)
+        return true;
+
+    D3D12MA::ALLOCATOR_DESC allocatorDesc = {};
+    allocatorDesc.pDevice = device;
+    allocatorDesc.pAdapter = adapter;
+    // A QRhi is supposed to be used from one single thread only. Disable
+    // the allocator's own mutexes. This may give a performance boost.
+    allocatorDesc.Flags = D3D12MA::ALLOCATOR_FLAG_SINGLETHREADED;
+    HRESULT hr = D3D12MA::CreateAllocator(&allocatorDesc, &allocator);
+    if (FAILED(hr)) {
+        qWarning("Failed to initialize D3D12 Memory Allocator: %s",
+                 qPrintable(QSystemError::windowsComString(hr)));
+        return false;
+    }
+    return true;
+}
+
+void QD3D12MemoryAllocator::destroy()
+{
+    if (allocator) {
+        allocator->Release();
+        allocator = nullptr;
+    }
+}
+
+HRESULT QD3D12MemoryAllocator::createResource(D3D12_HEAP_TYPE heapType,
+                                              const D3D12_RESOURCE_DESC *resourceDesc,
+                                              D3D12_RESOURCE_STATES initialState,
+                                              const D3D12_CLEAR_VALUE *optimizedClearValue,
+                                              D3D12MA::Allocation **maybeAllocation,
+                                              REFIID riidResource,
+                                              void **ppvResource)
+{
+    if (allocator) {
+        D3D12MA::ALLOCATION_DESC allocDesc = {};
+        allocDesc.HeapType = heapType;
+        return allocator->CreateResource(&allocDesc,
+                                         resourceDesc,
+                                         initialState,
+                                         optimizedClearValue,
+                                         maybeAllocation,
+                                         riidResource,
+                                         ppvResource);
+    } else {
+        *maybeAllocation = nullptr;
+        D3D12_HEAP_PROPERTIES heapProps = {};
+        heapProps.Type = heapType;
+        return device->CreateCommittedResource(&heapProps,
+                                               D3D12_HEAP_FLAG_NONE,
+                                               resourceDesc,
+                                               initialState,
+                                               optimizedClearValue,
+                                               riidResource,
+                                               ppvResource);
+    }
+}
+
+void QD3D12MemoryAllocator::getBudget(D3D12MA::Budget *localBudget, D3D12MA::Budget *nonLocalBudget)
+{
+    if (allocator) {
+        allocator->GetBudget(localBudget, nonLocalBudget);
+    } else {
+        *localBudget = {};
+        *nonLocalBudget = {};
+    }
+}
+
+void QRhiD3D12::waitGpu()
+{
+    fullFenceCounter += 1u;
+    if (SUCCEEDED(cmdQueue->Signal(fullFence, fullFenceCounter))) {
+        if (SUCCEEDED(fullFence->SetEventOnCompletion(fullFenceCounter, fullFenceEvent)))
+            WaitForSingleObject(fullFenceEvent, INFINITE);
+    }
+}
+
+DXGI_SAMPLE_DESC QRhiD3D12::effectiveSampleCount(int sampleCount, DXGI_FORMAT format) const
+{
+    DXGI_SAMPLE_DESC desc;
+    desc.Count = 1;
+    desc.Quality = 0;
+
+    // Stay compatible with QSurfaceFormat and friends where samples == 0 means the same as 1.
+    int s = qBound(1, sampleCount, 64);
+
+    if (!supportedSampleCounts().contains(s)) {
+        qWarning("Attempted to set unsupported sample count %d", sampleCount);
+        return desc;
+    }
+
+    if (s > 1) {
+        D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS msaaInfo = {};
+        msaaInfo.Format = format;
+        msaaInfo.SampleCount = s;
+        if (SUCCEEDED(dev->CheckFeatureSupport(D3D12_FEATURE_MULTISAMPLE_QUALITY_LEVELS, &msaaInfo, sizeof(msaaInfo)))) {
+            if (msaaInfo.NumQualityLevels > 0) {
+                desc.Count = UINT(s);
+                desc.Quality = msaaInfo.NumQualityLevels - 1;
+            } else {
+                qWarning("No quality levels for multisampling with sample count %d", s);
+            }
+        }
+    }
+
+    return desc;
+}
+
+bool QRhiD3D12::startCommandListForCurrentFrameSlot(ID3D12GraphicsCommandList **cmdList)
+{
+    ID3D12CommandAllocator *cmdAlloc = cmdAllocators[currentFrameSlot];
+    if (!*cmdList) {
+        HRESULT hr = dev->CreateCommandList(0,
+                                            D3D12_COMMAND_LIST_TYPE_DIRECT,
+                                            cmdAlloc,
+                                            nullptr,
+                                            IID_PPV_ARGS(cmdList));
+        if (FAILED(hr)) {
+            qWarning("Failed to create command list: %s", qPrintable(QSystemError::windowsComString(hr)));
+            return false;
+        }
+    } else {
+        HRESULT hr = (*cmdList)->Reset(cmdAlloc, nullptr);
+        if (FAILED(hr)) {
+            qWarning("Failed to reset command list: %s", qPrintable(QSystemError::windowsComString(hr)));
+            return false;
+        }
+    }
+    return true;
+}
+
+static inline QRhiTexture::Format swapchainReadbackTextureFormat(DXGI_FORMAT format, QRhiTexture::Flags *flags)
+{
+    switch (format) {
+    case DXGI_FORMAT_R8G8B8A8_UNORM:
+        return QRhiTexture::RGBA8;
+    case DXGI_FORMAT_R8G8B8A8_UNORM_SRGB:
+        if (flags)
+            (*flags) |= QRhiTexture::sRGB;
+        return QRhiTexture::RGBA8;
+    case DXGI_FORMAT_B8G8R8A8_UNORM:
+        return QRhiTexture::BGRA8;
+    case DXGI_FORMAT_B8G8R8A8_UNORM_SRGB:
+        if (flags)
+            (*flags) |= QRhiTexture::sRGB;
+        return QRhiTexture::BGRA8;
+    case DXGI_FORMAT_R16G16B16A16_FLOAT:
+        return QRhiTexture::RGBA16F;
+    case DXGI_FORMAT_R32G32B32A32_FLOAT:
+        return QRhiTexture::RGBA32F;
+    case DXGI_FORMAT_R10G10B10A2_UNORM:
+        return QRhiTexture::RGB10A2;
+    default:
+        qWarning("DXGI_FORMAT %d cannot be read back", format);
+        break;
+    }
+    return QRhiTexture::UnknownFormat;
+}
+
+void QRhiD3D12::enqueueResourceUpdates(QD3D12CommandBuffer *cbD, QRhiResourceUpdateBatch *resourceUpdates)
+{
+    QRhiResourceUpdateBatchPrivate *ud = QRhiResourceUpdateBatchPrivate::get(resourceUpdates);
+
+    for (int opIdx = 0; opIdx < ud->activeBufferOpCount; ++opIdx) {
+        const QRhiResourceUpdateBatchPrivate::BufferOp &u(ud->bufferOps[opIdx]);
+        if (u.type == QRhiResourceUpdateBatchPrivate::BufferOp::DynamicUpdate) {
+            QD3D12Buffer *bufD = QRHI_RES(QD3D12Buffer, u.buf);
+            Q_ASSERT(bufD->m_type == QRhiBuffer::Dynamic);
+            for (int i = 0; i < QD3D12_FRAMES_IN_FLIGHT; ++i) {
+                if (u.offset == 0 && u.data.size() == bufD->m_size)
+                    bufD->pendingHostWrites[i].clear();
+                bufD->pendingHostWrites[i].append({ u.offset, u.data });
+            }
+        } else if (u.type == QRhiResourceUpdateBatchPrivate::BufferOp::StaticUpload) {
+            QD3D12Buffer *bufD = QRHI_RES(QD3D12Buffer, u.buf);
+            Q_ASSERT(bufD->m_type != QRhiBuffer::Dynamic);
+            Q_ASSERT(u.offset + u.data.size() <= bufD->m_size);
+
+            // The general approach to staging upload data is to first try
+            // using the per-frame "small" staging area, which is a very simple
+            // linear allocator; if that's not big enough then create a
+            // dedicated StagingArea and then deferred-release it to make sure
+            // if stays alive while the frame is possibly still in flight.
+
+            QD3D12StagingArea::Allocation stagingAlloc;
+            const quint32 allocSize = QD3D12StagingArea::allocSizeForArray(bufD->m_size, 1);
+            if (smallStagingAreas[currentFrameSlot].remainingCapacity() >= allocSize)
+                stagingAlloc = smallStagingAreas[currentFrameSlot].get(bufD->m_size);
+
+            std::optional<QD3D12StagingArea> ownStagingArea;
+            if (!stagingAlloc.isValid()) {
+                ownStagingArea = QD3D12StagingArea();
+                if (!ownStagingArea->create(this, allocSize, D3D12_HEAP_TYPE_UPLOAD))
+                    continue;
+                stagingAlloc = ownStagingArea->get(allocSize);
+                if (!stagingAlloc.isValid()) {
+                    ownStagingArea->destroy();
+                    continue;
+                }
+            }
+
+            memcpy(stagingAlloc.p + u.offset, u.data.constData(), u.data.size());
+
+            barrierGen.addTransitionBarrier(bufD->handles[0], D3D12_RESOURCE_STATE_COPY_DEST);
+            barrierGen.enqueueBufferedTransitionBarriers(cbD);
+
+            if (QD3D12Resource *res = resourcePool.lookupRef(bufD->handles[0])) {
+                cbD->cmdList->CopyBufferRegion(res->resource,
+                                               u.offset,
+                                               stagingAlloc.buffer,
+                                               stagingAlloc.bufferOffset + u.offset,
+                                               u.data.size());
+            }
+
+            if (ownStagingArea.has_value())
+                ownStagingArea->destroyWithDeferredRelease(&releaseQueue);
+        } else if (u.type == QRhiResourceUpdateBatchPrivate::BufferOp::Read) {
+            QD3D12Buffer *bufD = QRHI_RES(QD3D12Buffer, u.buf);
+            if (bufD->m_type == QRhiBuffer::Dynamic) {
+                bufD->executeHostWritesForFrameSlot(currentFrameSlot);
+                if (QD3D12Resource *res = resourcePool.lookupRef(bufD->handles[currentFrameSlot])) {
+                    Q_ASSERT(res->cpuMapPtr);
+                    u.result->data.resize(u.readSize);
+                    memcpy(u.result->data.data(), reinterpret_cast<char *>(res->cpuMapPtr) + u.offset, u.readSize);
+                }
+                if (u.result->completed)
+                    u.result->completed();
+            } else {
+                QD3D12Readback readback;
+                readback.frameSlot = currentFrameSlot;
+                readback.result = u.result;
+                readback.byteSize = u.readSize;
+                const quint32 allocSize = aligned(u.readSize, QD3D12StagingArea::ALIGNMENT);
+                if (!readback.staging.create(this, allocSize, D3D12_HEAP_TYPE_READBACK)) {
+                    if (u.result->completed)
+                        u.result->completed();
+                    continue;
+                }
+                QD3D12StagingArea::Allocation stagingAlloc = readback.staging.get(u.readSize);
+                if (!stagingAlloc.isValid()) {
+                    readback.staging.destroy();
+                    if (u.result->completed)
+                        u.result->completed();
+                    continue;
+                }
+                Q_ASSERT(stagingAlloc.bufferOffset == 0);
+                barrierGen.addTransitionBarrier(bufD->handles[0], D3D12_RESOURCE_STATE_COPY_SOURCE);
+                barrierGen.enqueueBufferedTransitionBarriers(cbD);
+                if (QD3D12Resource *res = resourcePool.lookupRef(bufD->handles[0])) {
+                    cbD->cmdList->CopyBufferRegion(stagingAlloc.buffer, 0, res->resource, u.offset, u.readSize);
+                    activeReadbacks.append(readback);
+                } else {
+                    readback.staging.destroy();
+                    if (u.result->completed)
+                        u.result->completed();
+                }
+            }
+        }
+    }
+
+    for (int opIdx = 0; opIdx < ud->activeTextureOpCount; ++opIdx) {
+        const QRhiResourceUpdateBatchPrivate::TextureOp &u(ud->textureOps[opIdx]);
+        if (u.type == QRhiResourceUpdateBatchPrivate::TextureOp::Upload) {
+            QD3D12Texture *texD = QRHI_RES(QD3D12Texture, u.dst);
+            const bool is3D = texD->m_flags.testFlag(QRhiTexture::ThreeDimensional);
+            QD3D12Resource *res = resourcePool.lookupRef(texD->handle);
+            if (!res)
+                continue;
+            barrierGen.addTransitionBarrier(texD->handle, D3D12_RESOURCE_STATE_COPY_DEST);
+            barrierGen.enqueueBufferedTransitionBarriers(cbD);
+            for (int layer = 0, maxLayer = u.subresDesc.size(); layer < maxLayer; ++layer) {
+                for (int level = 0; level < QRhi::MAX_MIP_LEVELS; ++level) {
+                    for (const QRhiTextureSubresourceUploadDescription &subresDesc : std::as_const(u.subresDesc[layer][level])) {
+                        const UINT subresource = calcSubresource(UINT(level), is3D ? 0u : UINT(layer), texD->mipLevelCount);
+                        D3D12_PLACED_SUBRESOURCE_FOOTPRINT layout;
+                        UINT64 totalBytes = 0;
+                        D3D12_RESOURCE_DESC desc = res->desc;
+                        if (is3D) {
+                            desc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
+                            desc.DepthOrArraySize = 1;
+                        }
+                        dev->GetCopyableFootprints(&desc, subresource, 1, 0,
+                                                   &layout, nullptr, nullptr, &totalBytes);
+
+                        const quint32 allocSize = QD3D12StagingArea::allocSizeForArray(quint32(totalBytes), 1);
+                        QD3D12StagingArea::Allocation stagingAlloc;
+                        if (smallStagingAreas[currentFrameSlot].remainingCapacity() >= allocSize)
+                            stagingAlloc = smallStagingAreas[currentFrameSlot].get(allocSize);
+
+                        std::optional<QD3D12StagingArea> ownStagingArea;
+                        if (!stagingAlloc.isValid()) {
+                            ownStagingArea = QD3D12StagingArea();
+                            if (!ownStagingArea->create(this, allocSize, D3D12_HEAP_TYPE_UPLOAD))
+                                continue;
+                            stagingAlloc = ownStagingArea->get(allocSize);
+                            if (!stagingAlloc.isValid()) {
+                                ownStagingArea->destroy();
+                                continue;
+                            }
+                        }
+
+                        const UINT requiredBytesPerLine = layout.Footprint.RowPitch; // multiple of 256
+                        const QSize subresSize = subresDesc.sourceSize().isEmpty() ? q->sizeForMipLevel(level, texD->m_pixelSize)
+                                                                                   : subresDesc.sourceSize();
+                        const QPoint srcPos = subresDesc.sourceTopLeft();
+                        QPoint dstPos = subresDesc.destinationTopLeft();
+
+                        D3D12_TEXTURE_COPY_LOCATION dst;
+                        dst.pResource = res->resource;
+                        dst.Type = D3D12_TEXTURE_COPY_TYPE_SUBRESOURCE_INDEX;
+                        dst.SubresourceIndex = subresource;
+                        D3D12_TEXTURE_COPY_LOCATION src;
+                        src.pResource = stagingAlloc.buffer;
+                        src.Type = D3D12_TEXTURE_COPY_TYPE_PLACED_FOOTPRINT;
+                        src.PlacedFootprint.Offset = stagingAlloc.bufferOffset;
+                        src.PlacedFootprint.Footprint = layout.Footprint;
+
+                        D3D12_BOX srcBox; // back, right, bottom are exclusive
+
+                        if (!subresDesc.image().isNull()) {
+                            QImage img = subresDesc.image();
+                            const int bpc = qMax(1, img.depth() / 8);
+                            const int bpl = img.bytesPerLine();
+
+                            QSize size = subresDesc.sourceSize().isEmpty() ? img.size() : subresDesc.sourceSize();
+                            size.setWidth(qMin(size.width(), img.width() - srcPos.x()));
+                            size.setHeight(qMin(size.height(), img.height() - srcPos.y()));
+                            srcBox.left = 0;
+                            srcBox.top = 0;
+                            srcBox.right = UINT(size.width());
+                            srcBox.bottom = UINT(size.height());
+                            srcBox.front = 0;
+                            srcBox.back = 1;
+
+                            const uchar *imgPtr = img.constBits();
+                            const quint32 lineBytes = size.width() * bpc;
+                            for (int y = 0, h = size.height(); y < h; ++y) {
+                                memcpy(stagingAlloc.p + y * requiredBytesPerLine,
+                                       imgPtr + srcPos.x() * bpc + (y + srcPos.y()) * bpl,
+                                       lineBytes);
+                            }
+                        } else if (!subresDesc.data().isEmpty() && isCompressedFormat(texD->m_format)) {
+                            QSize blockDim;
+                            quint32 bpl = 0;
+                            compressedFormatInfo(texD->m_format, subresSize, &bpl, nullptr, &blockDim);
+                            // x and y must be multiples of the block width and height
+                            dstPos.setX(aligned(dstPos.x(), blockDim.width()));
+                            dstPos.setY(aligned(dstPos.y(), blockDim.height()));
+
+                            srcBox.left = 0;
+                            srcBox.top = 0;
+                            // width and height must be multiples of the block width and height
+                            srcBox.right = aligned(subresSize.width(), blockDim.width());
+                            srcBox.bottom = aligned(subresSize.height(), blockDim.height());
+                            srcBox.front = 0;
+                            srcBox.back = 1;
+
+                            const quint32 copyBytes = qMin(bpl, requiredBytesPerLine);
+                            const QByteArray imgData = subresDesc.data();
+                            const char *imgPtr = imgData.constData();
+                            const int rowCount = aligned(subresSize.height(), blockDim.height()) / blockDim.height();
+                            for (int y = 0; y < rowCount; ++y)
+                                memcpy(stagingAlloc.p + y * requiredBytesPerLine, imgPtr + y * bpl, copyBytes);
+                        } else if (!subresDesc.data().isEmpty()) {
+                            srcBox.left = 0;
+                            srcBox.top = 0;
+                            srcBox.right = subresSize.width();
+                            srcBox.bottom = subresSize.height();
+                            srcBox.front = 0;
+                            srcBox.back = 1;
+
+                            quint32 bpl = 0;
+                            if (subresDesc.dataStride())
+                                bpl = subresDesc.dataStride();
+                            else
+                                textureFormatInfo(texD->m_format, subresSize, &bpl, nullptr, nullptr);
+
+                            const quint32 copyBytes = qMin(bpl, requiredBytesPerLine);
+                            const QByteArray data = subresDesc.data();
+                            const char *imgPtr = data.constData();
+                            for (int y = 0, h = subresSize.height(); y < h; ++y)
+                                memcpy(stagingAlloc.p + y * requiredBytesPerLine, imgPtr + y * bpl, copyBytes);
+                        } else {
+                            qWarning("Invalid texture upload for %p layer=%d mip=%d", texD, layer, level);
+                            if (ownStagingArea.has_value())
+                                ownStagingArea->destroyWithDeferredRelease(&releaseQueue);
+                            continue;
+                        }
+
+                        cbD->cmdList->CopyTextureRegion(&dst,
+                                                        UINT(dstPos.x()),
+                                                        UINT(dstPos.y()),
+                                                        is3D ? UINT(layer) : 0u,
+                                                        &src,
+                                                        &srcBox);
+
+                        if (ownStagingArea.has_value())
+                            ownStagingArea->destroyWithDeferredRelease(&releaseQueue);
+                    }
+                }
+            }
+        } else if (u.type == QRhiResourceUpdateBatchPrivate::TextureOp::Copy) {
+            Q_ASSERT(u.src && u.dst);
+            QD3D12Texture *srcD = QRHI_RES(QD3D12Texture, u.src);
+            QD3D12Texture *dstD = QRHI_RES(QD3D12Texture, u.dst);
+            const bool srcIs3D = srcD->m_flags.testFlag(QRhiTexture::ThreeDimensional);
+            const bool dstIs3D = dstD->m_flags.testFlag(QRhiTexture::ThreeDimensional);
+            QD3D12Resource *srcRes = resourcePool.lookupRef(srcD->handle);
+            QD3D12Resource *dstRes = resourcePool.lookupRef(dstD->handle);
+            if (!srcRes || !dstRes)
+                continue;
+
+            barrierGen.addTransitionBarrier(srcD->handle, D3D12_RESOURCE_STATE_COPY_SOURCE);
+            barrierGen.addTransitionBarrier(dstD->handle, D3D12_RESOURCE_STATE_COPY_DEST);
+            barrierGen.enqueueBufferedTransitionBarriers(cbD);
+
+            const UINT srcSubresource = calcSubresource(UINT(u.desc.sourceLevel()),
+                                                        srcIs3D ? 0u : UINT(u.desc.sourceLayer()),
+                                                        srcD->mipLevelCount);
+            const UINT dstSubresource = calcSubresource(UINT(u.desc.destinationLevel()),
+                                                        dstIs3D ? 0u : UINT(u.desc.destinationLayer()),
+                                                        dstD->mipLevelCount);
+            const QPoint dp = u.desc.destinationTopLeft();
+            const QSize mipSize = q->sizeForMipLevel(u.desc.sourceLevel(), srcD->m_pixelSize);
+            const QSize copySize = u.desc.pixelSize().isEmpty() ? mipSize : u.desc.pixelSize();
+            const QPoint sp = u.desc.sourceTopLeft();
+
+            D3D12_BOX srcBox;
+            srcBox.left = UINT(sp.x());
+            srcBox.top = UINT(sp.y());
+            srcBox.front = srcIs3D ? UINT(u.desc.sourceLayer()) : 0u;
+            // back, right, bottom are exclusive
+            srcBox.right = srcBox.left + UINT(copySize.width());
+            srcBox.bottom = srcBox.top + UINT(copySize.height());
+            srcBox.back = srcBox.front + 1;
+
+            D3D12_TEXTURE_COPY_LOCATION src;
+            src.pResource = srcRes->resource;
+            src.Type = D3D12_TEXTURE_COPY_TYPE_SUBRESOURCE_INDEX;
+            src.SubresourceIndex = srcSubresource;
+            D3D12_TEXTURE_COPY_LOCATION dst;
+            dst.pResource = dstRes->resource;
+            dst.Type = D3D12_TEXTURE_COPY_TYPE_SUBRESOURCE_INDEX;
+            dst.SubresourceIndex = dstSubresource;
+
+            cbD->cmdList->CopyTextureRegion(&dst,
+                                            UINT(dp.x()),
+                                            UINT(dp.y()),
+                                            dstIs3D ? UINT(u.desc.destinationLayer()) : 0u,
+                                            &src,
+                                            &srcBox);
+        } else if (u.type == QRhiResourceUpdateBatchPrivate::TextureOp::Read) {
+            QD3D12Readback readback;
+            readback.frameSlot = currentFrameSlot;
+            readback.result = u.result;
+
+            QD3D12ObjectHandle srcHandle;
+            bool is3D = false;
+            if (u.rb.texture()) {
+                QD3D12Texture *texD = QRHI_RES(QD3D12Texture, u.rb.texture());
+                if (texD->sampleDesc.Count > 1) {
+                    qWarning("Multisample texture cannot be read back");
+                    continue;
+                }
+                is3D = texD->m_flags.testFlag(QRhiTexture::ThreeDimensional);
+                readback.pixelSize = q->sizeForMipLevel(u.rb.level(), texD->m_pixelSize);
+                readback.format = texD->m_format;
+                srcHandle = texD->handle;
+            } else {
+                Q_ASSERT(currentSwapChain);
+                readback.pixelSize = currentSwapChain->pixelSize;
+                readback.format = swapchainReadbackTextureFormat(currentSwapChain->colorFormat, nullptr);
+                if (readback.format == QRhiTexture::UnknownFormat)
+                    continue;
+                srcHandle = currentSwapChain->colorBuffers[currentSwapChain->currentBackBufferIndex];
+            }
+
+            textureFormatInfo(readback.format,
+                              readback.pixelSize,
+                              &readback.bytesPerLine,
+                              &readback.byteSize,
+                              nullptr);
+
+            QD3D12Resource *srcRes = resourcePool.lookupRef(srcHandle);
+            if (!srcRes)
+                continue;
+
+            const UINT subresource = calcSubresource(UINT(u.rb.level()),
+                                                     is3D ? 0u : UINT(u.rb.layer()),
+                                                     srcRes->desc.MipLevels);
+            D3D12_PLACED_SUBRESOURCE_FOOTPRINT layout;
+            // totalBytes is what we get from D3D, with the 256 aligned stride,
+            // readback.byteSize is the final result that's not relevant here yet
+            UINT64 totalBytes = 0;
+            dev->GetCopyableFootprints(&srcRes->desc, subresource, 1, 0,
+                                       &layout, nullptr, nullptr, &totalBytes);
+            readback.stagingRowPitch = layout.Footprint.RowPitch;
+
+            const quint32 allocSize = aligned<quint32>(totalBytes, QD3D12StagingArea::ALIGNMENT);
+            if (!readback.staging.create(this, allocSize, D3D12_HEAP_TYPE_READBACK)) {
+                if (u.result->completed)
+                    u.result->completed();
+                continue;
+            }
+            QD3D12StagingArea::Allocation stagingAlloc = readback.staging.get(totalBytes);
+            if (!stagingAlloc.isValid()) {
+                readback.staging.destroy();
+                if (u.result->completed)
+                    u.result->completed();
+                continue;
+            }
+            Q_ASSERT(stagingAlloc.bufferOffset == 0);
+
+            barrierGen.addTransitionBarrier(srcHandle, D3D12_RESOURCE_STATE_COPY_SOURCE);
+            barrierGen.enqueueBufferedTransitionBarriers(cbD);
+
+            D3D12_TEXTURE_COPY_LOCATION dst;
+            dst.pResource = stagingAlloc.buffer;
+            dst.Type = D3D12_TEXTURE_COPY_TYPE_PLACED_FOOTPRINT;
+            dst.PlacedFootprint.Offset = 0;
+            dst.PlacedFootprint.Footprint = layout.Footprint;
+
+            D3D12_TEXTURE_COPY_LOCATION src;
+            src.pResource = srcRes->resource;
+            src.Type = D3D12_TEXTURE_COPY_TYPE_SUBRESOURCE_INDEX;
+            src.SubresourceIndex = subresource;
+
+            D3D12_BOX srcBox = {};
+            if (is3D) {
+                srcBox.front = UINT(u.rb.layer());
+                srcBox.back = srcBox.front + 1;
+                srcBox.right = readback.pixelSize.width(); // exclusive
+                srcBox.bottom = readback.pixelSize.height();
+            }
+            cbD->cmdList->CopyTextureRegion(&dst, 0, 0, 0, &src, is3D ? &srcBox : nullptr);
+            activeReadbacks.append(readback);
+        } else if (u.type == QRhiResourceUpdateBatchPrivate::TextureOp::GenMips) {
+            QD3D12Texture *texD = QRHI_RES(QD3D12Texture, u.dst);
+            Q_ASSERT(texD->flags().testFlag(QRhiTexture::UsedWithGenerateMips));
+            mipmapGen.generate(cbD, texD->handle);
+        }
+    }
+
+    ud->free();
+}
+
+void QRhiD3D12::finishActiveReadbacks(bool forced)
+{
+    QVarLengthArray<std::function<void()>, 4> completedCallbacks;
+
+    for (int i = activeReadbacks.size() - 1; i >= 0; --i) {
+        QD3D12Readback &readback(activeReadbacks[i]);
+        if (forced || currentFrameSlot == readback.frameSlot || readback.frameSlot < 0) {
+            readback.result->format = readback.format;
+            readback.result->pixelSize = readback.pixelSize;
+            readback.result->data.resize(int(readback.byteSize));
+
+            if (readback.format != QRhiTexture::UnknownFormat) {
+                quint8 *dstPtr = reinterpret_cast<quint8 *>(readback.result->data.data());
+                const quint8 *srcPtr = readback.staging.mem.p;
+                const quint32 lineSize = qMin(readback.bytesPerLine, readback.stagingRowPitch);
+                for (int y = 0, h = readback.pixelSize.height(); y < h; ++y)
+                    memcpy(dstPtr + y * readback.bytesPerLine, srcPtr + y * readback.stagingRowPitch, lineSize);
+            } else {
+                memcpy(readback.result->data.data(), readback.staging.mem.p, readback.byteSize);
+            }
+
+            readback.staging.destroy();
+
+            if (readback.result->completed)
+                completedCallbacks.append(readback.result->completed);
+
+            activeReadbacks.removeLast();
+        }
+    }
+
+    for (auto f : completedCallbacks)
+        f();
+}
+
+bool QRhiD3D12::ensureShaderVisibleDescriptorHeapCapacity(QD3D12ShaderVisibleDescriptorHeap *h,
+                                                          D3D12_DESCRIPTOR_HEAP_TYPE type,
+                                                          int frameSlot,
+                                                          quint32 neededDescriptorCount,
+                                                          bool *gotNew)
+{
+    // Gets a new heap if needed. Note that the capacity we get is clamped
+    // automatically (e.g. to 1 million, or 2048 for samplers), so * 2 does not
+    // mean we can grow indefinitely, then again even using the same size would
+    // work (because we what we are after here is a new heap for the rest of
+    // the commands, not affecting what's already recorded).
+    if (h->perFrameHeapSlice[frameSlot].remainingCapacity() < neededDescriptorCount) {
+        const quint32 newPerFrameSize = qMax(h->perFrameHeapSlice[frameSlot].capacity * 2,
+                                             neededDescriptorCount);
+        QD3D12ShaderVisibleDescriptorHeap newHeap;
+        if (!newHeap.create(dev, type, newPerFrameSize)) {
+            qWarning("Could not create new shader-visible descriptor heap");
+            return false;
+        }
+        h->destroyWithDeferredRelease(&releaseQueue);
+        *h = newHeap;
+        *gotNew = true;
+    }
+    return true;
+}
+
+void QRhiD3D12::bindShaderVisibleHeaps(QD3D12CommandBuffer *cbD)
+{
+    ID3D12DescriptorHeap *heaps[] = {
+        shaderVisibleCbvSrvUavHeap.heap.heap,
+        samplerMgr.shaderVisibleSamplerHeap.heap.heap
+    };
+    cbD->cmdList->SetDescriptorHeaps(2, heaps);
+}
+
+QD3D12Buffer::QD3D12Buffer(QRhiImplementation *rhi, Type type, UsageFlags usage, quint32 size)
+    : QRhiBuffer(rhi, type, usage, size)
+{
+}
+
+QD3D12Buffer::~QD3D12Buffer()
+{
+    destroy();
+}
+
+void QD3D12Buffer::destroy()
+{
+    if (handles[0].isNull())
+        return;
+
+    QRHI_RES_RHI(QRhiD3D12);
+
+    // destroy() implementations, unlike other functions, are expected to test
+    // for m_rhi (rhiD) being null, to allow surviving in case one attempts to
+    // destroy a (leaked) resource after the QRhi.
+    //
+    // If there is no QRhi anymore, we do not deferred-release but that's fine
+    // since the QRhi already released everything that was in the resourcePool.
+
+    for (int i = 0; i < QD3D12_FRAMES_IN_FLIGHT; ++i) {
+        if (rhiD)
+            rhiD->releaseQueue.deferredReleaseResource(handles[i]);
+        handles[i] = {};
+        pendingHostWrites[i].clear();
+    }
+
+    if (rhiD)
+        rhiD->unregisterResource(this);
+}
+
+bool QD3D12Buffer::create()
+{
+    if (!handles[0].isNull())
+        destroy();
+
+    if (m_usage.testFlag(QRhiBuffer::UniformBuffer) && m_type != Dynamic) {
+        qWarning("UniformBuffer must always be Dynamic");
+        return false;
+    }
+
+    if (m_usage.testFlag(QRhiBuffer::StorageBuffer) && m_type == Dynamic) {
+        qWarning("StorageBuffer cannot be combined with Dynamic");
+        return false;
+    }
+
+    const quint32 nonZeroSize = m_size <= 0 ? 256 : m_size;
+    const quint32 roundedSize = aligned(nonZeroSize, m_usage.testFlag(QRhiBuffer::UniformBuffer) ? 256u : 4u);
+
+    UINT resourceFlags = D3D12_RESOURCE_FLAG_NONE;
+    if (m_usage.testFlag(QRhiBuffer::StorageBuffer))
+        resourceFlags |= D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS;
+
+    QRHI_RES_RHI(QRhiD3D12);
+    HRESULT hr = 0;
+    for (int i = 0; i < QD3D12_FRAMES_IN_FLIGHT; ++i) {
+        if (i == 0 || m_type == Dynamic) {
+            D3D12_RESOURCE_DESC resourceDesc = {};
+            resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
+            resourceDesc.Width = roundedSize;
+            resourceDesc.Height = 1;
+            resourceDesc.DepthOrArraySize = 1;
+            resourceDesc.MipLevels = 1;
+            resourceDesc.Format = DXGI_FORMAT_UNKNOWN;
+            resourceDesc.SampleDesc = { 1, 0 };
+            resourceDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
+            resourceDesc.Flags = D3D12_RESOURCE_FLAGS(resourceFlags);
+            ID3D12Resource *resource = nullptr;
+            D3D12MA::Allocation *allocation = nullptr;
+            // Dynamic == host (CPU) visible
+            D3D12_HEAP_TYPE heapType = m_type == Dynamic
+                    ? D3D12_HEAP_TYPE_UPLOAD
+                    : D3D12_HEAP_TYPE_DEFAULT;
+            D3D12_RESOURCE_STATES resourceState = m_type == Dynamic
+                    ? D3D12_RESOURCE_STATE_GENERIC_READ
+                    : D3D12_RESOURCE_STATE_COMMON;
+            hr = rhiD->vma.createResource(heapType,
+                                          &resourceDesc,
+                                          resourceState,
+                                          nullptr,
+                                          &allocation,
+                                          IID_PPV_ARGS(&resource));
+            if (FAILED(hr))
+                break;
+            if (!m_objectName.isEmpty()) {
+                QString decoratedName = QString::fromUtf8(m_objectName);
+                if (m_type == Dynamic) {
+                    decoratedName += QLatin1Char('/');
+                    decoratedName += QString::number(i);
+                }
+                resource->SetName(reinterpret_cast<LPCWSTR>(decoratedName.utf16()));
+            }
+            void *cpuMemPtr = nullptr;
+            if (m_type == Dynamic) {
+                // will be mapped for ever on the CPU, this makes future host write operations very simple
+                hr = resource->Map(0, nullptr, &cpuMemPtr);
+                if (FAILED(hr)) {
+                    qWarning("Map() failed to dynamic buffer");
+                    resource->Release();
+                    if (allocation)
+                        allocation->Release();
+                    break;
+                }
+            }
+            handles[i] = QD3D12Resource::addToPool(&rhiD->resourcePool,
+                                                   resource,
+                                                   resourceState,
+                                                   allocation,
+                                                   cpuMemPtr);
+        }
+    }
+    if (FAILED(hr)) {
+        qWarning("Failed to create buffer: '%s' Type was %d, size was %u, using D3D12MA was %d.",
+                 qPrintable(QSystemError::windowsComString(hr)),
+                 int(m_type),
+                 roundedSize,
+                 int(rhiD->vma.isUsingD3D12MA()));
+        return false;
+    }
+
+    rhiD->registerResource(this);
+    return true;
+}
+
+QRhiBuffer::NativeBuffer QD3D12Buffer::nativeBuffer()
+{
+    NativeBuffer b;
+    Q_ASSERT(sizeof(b.objects) / sizeof(b.objects[0]) >= size_t(QD3D12_FRAMES_IN_FLIGHT));
+    QRHI_RES_RHI(QRhiD3D12);
+    if (m_type == Dynamic) {
+        for (int i = 0; i < QD3D12_FRAMES_IN_FLIGHT; ++i) {
+            executeHostWritesForFrameSlot(i);
+            if (QD3D12Resource *res = rhiD->resourcePool.lookupRef(handles[i]))
+                b.objects[i] = res->resource;
+            else
+                b.objects[i] = nullptr;
+        }
+        b.slotCount = QD3D12_FRAMES_IN_FLIGHT;
+        return b;
+    }
+    if (QD3D12Resource *res = rhiD->resourcePool.lookupRef(handles[0]))
+        b.objects[0] = res->resource;
+    else
+        b.objects[0] = nullptr;
+    b.slotCount = 1;
+    return b;
+}
+
+char *QD3D12Buffer::beginFullDynamicBufferUpdateForCurrentFrame()
+{
+    // Shortcut the entire buffer update mechanism and allow the client to do
+    // the host writes directly to the buffer. This will lead to unexpected
+    // results when combined with QRhiResourceUpdateBatch-based updates for the
+    // buffer, but provides a fast path for dynamic buffers that have all their
+    // content changed in every frame.
+
+    Q_ASSERT(m_type == Dynamic);
+    QRHI_RES_RHI(QRhiD3D12);
+    Q_ASSERT(rhiD->inFrame);
+    if (QD3D12Resource *res = rhiD->resourcePool.lookupRef(handles[rhiD->currentFrameSlot]))
+        return static_cast<char *>(res->cpuMapPtr);
+
+    return nullptr;
+}
+
+void QD3D12Buffer::endFullDynamicBufferUpdateForCurrentFrame()
+{
+    // nothing to do here
+}
+
+void QD3D12Buffer::executeHostWritesForFrameSlot(int frameSlot)
+{
+    if (pendingHostWrites[frameSlot].isEmpty())
+        return;
+
+    Q_ASSERT(m_type == QRhiBuffer::Dynamic);
+    QRHI_RES_RHI(QRhiD3D12);
+    if (QD3D12Resource *res = rhiD->resourcePool.lookupRef(handles[frameSlot])) {
+        Q_ASSERT(res->cpuMapPtr);
+        for (const QD3D12Buffer::HostWrite &u : std::as_const(pendingHostWrites[frameSlot]))
+            memcpy(static_cast<char *>(res->cpuMapPtr) + u.offset, u.data.constData(), u.data.size());
+    }
+    pendingHostWrites[frameSlot].clear();
+}
+
+static inline DXGI_FORMAT toD3DTextureFormat(QRhiTexture::Format format, QRhiTexture::Flags flags)
+{
+    const bool srgb = flags.testFlag(QRhiTexture::sRGB);
+    switch (format) {
+    case QRhiTexture::RGBA8:
+        return srgb ? DXGI_FORMAT_R8G8B8A8_UNORM_SRGB : DXGI_FORMAT_R8G8B8A8_UNORM;
+    case QRhiTexture::BGRA8:
+        return srgb ? DXGI_FORMAT_B8G8R8A8_UNORM_SRGB : DXGI_FORMAT_B8G8R8A8_UNORM;
+    case QRhiTexture::R8:
+        return DXGI_FORMAT_R8_UNORM;
+    case QRhiTexture::RG8:
+        return DXGI_FORMAT_R8G8_UNORM;
+    case QRhiTexture::R16:
+        return DXGI_FORMAT_R16_UNORM;
+    case QRhiTexture::RG16:
+        return DXGI_FORMAT_R16G16_UNORM;
+    case QRhiTexture::RED_OR_ALPHA8:
+        return DXGI_FORMAT_R8_UNORM;
+
+    case QRhiTexture::RGBA16F:
+        return DXGI_FORMAT_R16G16B16A16_FLOAT;
+    case QRhiTexture::RGBA32F:
+        return DXGI_FORMAT_R32G32B32A32_FLOAT;
+    case QRhiTexture::R16F:
+        return DXGI_FORMAT_R16_FLOAT;
+    case QRhiTexture::R32F:
+        return DXGI_FORMAT_R32_FLOAT;
+
+    case QRhiTexture::RGB10A2:
+        return DXGI_FORMAT_R10G10B10A2_UNORM;
+
+    case QRhiTexture::D16:
+        return DXGI_FORMAT_R16_TYPELESS;
+    case QRhiTexture::D24:
+        return DXGI_FORMAT_R24G8_TYPELESS;
+    case QRhiTexture::D24S8:
+        return DXGI_FORMAT_R24G8_TYPELESS;
+    case QRhiTexture::D32F:
+        return DXGI_FORMAT_R32_TYPELESS;
+
+    case QRhiTexture::BC1:
+        return srgb ? DXGI_FORMAT_BC1_UNORM_SRGB : DXGI_FORMAT_BC1_UNORM;
+    case QRhiTexture::BC2:
+        return srgb ? DXGI_FORMAT_BC2_UNORM_SRGB : DXGI_FORMAT_BC2_UNORM;
+    case QRhiTexture::BC3:
+        return srgb ? DXGI_FORMAT_BC3_UNORM_SRGB : DXGI_FORMAT_BC3_UNORM;
+    case QRhiTexture::BC4:
+        return DXGI_FORMAT_BC4_UNORM;
+    case QRhiTexture::BC5:
+        return DXGI_FORMAT_BC5_UNORM;
+    case QRhiTexture::BC6H:
+        return DXGI_FORMAT_BC6H_UF16;
+    case QRhiTexture::BC7:
+        return srgb ? DXGI_FORMAT_BC7_UNORM_SRGB : DXGI_FORMAT_BC7_UNORM;
+
+    case QRhiTexture::ETC2_RGB8:
+    case QRhiTexture::ETC2_RGB8A1:
+    case QRhiTexture::ETC2_RGBA8:
+        qWarning("QRhiD3D12 does not support ETC2 textures");
+        return DXGI_FORMAT_R8G8B8A8_UNORM;
+
+    case QRhiTexture::ASTC_4x4:
+    case QRhiTexture::ASTC_5x4:
+    case QRhiTexture::ASTC_5x5:
+    case QRhiTexture::ASTC_6x5:
+    case QRhiTexture::ASTC_6x6:
+    case QRhiTexture::ASTC_8x5:
+    case QRhiTexture::ASTC_8x6:
+    case QRhiTexture::ASTC_8x8:
+    case QRhiTexture::ASTC_10x5:
+    case QRhiTexture::ASTC_10x6:
+    case QRhiTexture::ASTC_10x8:
+    case QRhiTexture::ASTC_10x10:
+    case QRhiTexture::ASTC_12x10:
+    case QRhiTexture::ASTC_12x12:
+        qWarning("QRhiD3D12 does not support ASTC textures");
+        return DXGI_FORMAT_R8G8B8A8_UNORM;
+
+    default:
+        break;
+    }
+    return DXGI_FORMAT_R8G8B8A8_UNORM;
+}
+
+QD3D12RenderBuffer::QD3D12RenderBuffer(QRhiImplementation *rhi,
+                                       Type type,
+                                       const QSize &pixelSize,
+                                       int sampleCount,
+                                       Flags flags,
+                                       QRhiTexture::Format backingFormatHint)
+    : QRhiRenderBuffer(rhi, type, pixelSize, sampleCount, flags, backingFormatHint)
+{
+}
+
+QD3D12RenderBuffer::~QD3D12RenderBuffer()
+{
+    destroy();
+}
+
+void QD3D12RenderBuffer::destroy()
+{
+    if (handle.isNull())
+        return;
+
+    QRHI_RES_RHI(QRhiD3D12);
+    if (rhiD) {
+        if (rtv.isValid())
+            rhiD->releaseQueue.deferredReleaseResourceWithViews(handle, &rhiD->rtvPool, rtv, 1);
+        else if (dsv.isValid())
+            rhiD->releaseQueue.deferredReleaseResourceWithViews(handle, &rhiD->dsvPool, dsv, 1);
+    }
+
+    handle = {};
+    rtv = {};
+    dsv = {};
+
+    if (rhiD)
+        rhiD->unregisterResource(this);
+}
+
+bool QD3D12RenderBuffer::create()
+{
+    if (!handle.isNull())
+        destroy();
+
+    if (m_pixelSize.isEmpty())
+        return false;
+
+    QRHI_RES_RHI(QRhiD3D12);
+
+    switch (m_type) {
+    case QRhiRenderBuffer::Color:
+    {
+        dxgiFormat = toD3DTextureFormat(backingFormat(), {});
+        sampleDesc = rhiD->effectiveSampleCount(m_sampleCount, dxgiFormat);
+        D3D12_RESOURCE_DESC resourceDesc = {};
+        resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
+        resourceDesc.Width = UINT64(m_pixelSize.width());
+        resourceDesc.Height = UINT(m_pixelSize.height());
+        resourceDesc.DepthOrArraySize = 1;
+        resourceDesc.MipLevels = 1;
+        resourceDesc.Format = dxgiFormat;
+        resourceDesc.SampleDesc = sampleDesc;
+        resourceDesc.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;
+        resourceDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET;
+        D3D12_CLEAR_VALUE clearValue = {};
+        clearValue.Format = dxgiFormat;
+        // have a separate allocation and resource object (meaning both will need its own Release())
+        ID3D12Resource *resource = nullptr;
+        D3D12MA::Allocation *allocation = nullptr;
+        HRESULT hr = rhiD->vma.createResource(D3D12_HEAP_TYPE_DEFAULT,
+                                              &resourceDesc,
+                                              D3D12_RESOURCE_STATE_RENDER_TARGET,
+                                              &clearValue,
+                                              &allocation,
+                                              IID_PPV_ARGS(&resource));
+        if (FAILED(hr)) {
+            qWarning("Failed to create color buffer: %s", qPrintable(QSystemError::windowsComString(hr)));
+            return false;
+        }
+        handle = QD3D12Resource::addToPool(&rhiD->resourcePool, resource, D3D12_RESOURCE_STATE_RENDER_TARGET, allocation);
+        rtv = rhiD->rtvPool.allocate(1);
+        if (!rtv.isValid())
+            return false;
+        D3D12_RENDER_TARGET_VIEW_DESC rtvDesc = {};
+        rtvDesc.Format = dxgiFormat;
+        rtvDesc.ViewDimension = sampleDesc.Count > 1 ? D3D12_RTV_DIMENSION_TEXTURE2DMS
+                                                     : D3D12_RTV_DIMENSION_TEXTURE2D;
+        rhiD->dev->CreateRenderTargetView(resource, &rtvDesc, rtv.cpuHandle);
+    }
+        break;
+    case QRhiRenderBuffer::DepthStencil:
+    {
+        dxgiFormat = DS_FORMAT;
+        sampleDesc = rhiD->effectiveSampleCount(m_sampleCount, dxgiFormat);
+        D3D12_RESOURCE_DESC resourceDesc = {};
+        resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
+        resourceDesc.Width = UINT64(m_pixelSize.width());
+        resourceDesc.Height = UINT(m_pixelSize.height());
+        resourceDesc.DepthOrArraySize = 1;
+        resourceDesc.MipLevels = 1;
+        resourceDesc.Format = dxgiFormat;
+        resourceDesc.SampleDesc = sampleDesc;
+        resourceDesc.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;
+        resourceDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;
+        if (m_flags.testFlag(UsedWithSwapChainOnly))
+            resourceDesc.Flags |= D3D12_RESOURCE_FLAG_DENY_SHADER_RESOURCE;
+        D3D12_CLEAR_VALUE clearValue = {};
+        clearValue.Format = dxgiFormat;
+        clearValue.DepthStencil.Depth = 1.0f;
+        clearValue.DepthStencil.Stencil = 0;
+        ID3D12Resource *resource = nullptr;
+        D3D12MA::Allocation *allocation = nullptr;
+        HRESULT hr = rhiD->vma.createResource(D3D12_HEAP_TYPE_DEFAULT,
+                                              &resourceDesc,
+                                              D3D12_RESOURCE_STATE_DEPTH_WRITE,
+                                              &clearValue,
+                                              &allocation,
+                                              IID_PPV_ARGS(&resource));
+        if (FAILED(hr)) {
+            qWarning("Failed to create depth-stencil buffer: %s", qPrintable(QSystemError::windowsComString(hr)));
+            return false;
+        }
+        handle = QD3D12Resource::addToPool(&rhiD->resourcePool, resource, D3D12_RESOURCE_STATE_DEPTH_WRITE, allocation);
+        dsv = rhiD->dsvPool.allocate(1);
+        if (!dsv.isValid())
+            return false;
+        D3D12_DEPTH_STENCIL_VIEW_DESC dsvDesc = {};
+        dsvDesc.Format = dxgiFormat;
+        dsvDesc.ViewDimension = sampleDesc.Count > 1 ? D3D12_DSV_DIMENSION_TEXTURE2DMS
+                                                     : D3D12_DSV_DIMENSION_TEXTURE2D;
+        rhiD->dev->CreateDepthStencilView(resource, &dsvDesc, dsv.cpuHandle);
+    }
+        break;
+    }
+
+    if (!m_objectName.isEmpty()) {
+        if (QD3D12Resource *res = rhiD->resourcePool.lookupRef(handle)) {
+            const QString name = QString::fromUtf8(m_objectName);
+            res->resource->SetName(reinterpret_cast<LPCWSTR>(name.utf16()));
+        }
+    }
+
+    generation += 1;
+    rhiD->registerResource(this);
+    return true;
+}
+
+QRhiTexture::Format QD3D12RenderBuffer::backingFormat() const
+{
+    if (m_backingFormatHint != QRhiTexture::UnknownFormat)
+        return m_backingFormatHint;
+    else
+        return m_type == Color ? QRhiTexture::RGBA8 : QRhiTexture::UnknownFormat;
+}
+
+QD3D12Texture::QD3D12Texture(QRhiImplementation *rhi, Format format, const QSize &pixelSize, int depth,
+                             int arraySize, int sampleCount, Flags flags)
+    : QRhiTexture(rhi, format, pixelSize, depth, arraySize, sampleCount, flags)
+{
+}
+
+QD3D12Texture::~QD3D12Texture()
+{
+    destroy();
+}
+
+void QD3D12Texture::destroy()
+{
+    if (handle.isNull())
+        return;
+
+    QRHI_RES_RHI(QRhiD3D12);
+    if (rhiD)
+        rhiD->releaseQueue.deferredReleaseResourceWithViews(handle, &rhiD->cbvSrvUavPool, srv, 1);
+
+    handle = {};
+    srv = {};
+
+    if (rhiD)
+        rhiD->unregisterResource(this);
+}
+
+static inline DXGI_FORMAT toD3DDepthTextureSRVFormat(QRhiTexture::Format format)
+{
+    switch (format) {
+    case QRhiTexture::Format::D16:
+        return DXGI_FORMAT_R16_FLOAT;
+    case QRhiTexture::Format::D24:
+        return DXGI_FORMAT_R24_UNORM_X8_TYPELESS;
+    case QRhiTexture::Format::D24S8:
+        return DXGI_FORMAT_R24_UNORM_X8_TYPELESS;
+    case QRhiTexture::Format::D32F:
+        return DXGI_FORMAT_R32_FLOAT;
+    default:
+        break;
+    }
+    Q_UNREACHABLE_RETURN(DXGI_FORMAT_R32_FLOAT);
+}
+
+static inline DXGI_FORMAT toD3DDepthTextureDSVFormat(QRhiTexture::Format format)
+{
+    // here the result cannot be typeless
+    switch (format) {
+    case QRhiTexture::Format::D16:
+        return DXGI_FORMAT_D16_UNORM;
+    case QRhiTexture::Format::D24:
+        return DXGI_FORMAT_D24_UNORM_S8_UINT;
+    case QRhiTexture::Format::D24S8:
+        return DXGI_FORMAT_D24_UNORM_S8_UINT;
+    case QRhiTexture::Format::D32F:
+        return DXGI_FORMAT_D32_FLOAT;
+    default:
+        break;
+    }
+    Q_UNREACHABLE_RETURN(DXGI_FORMAT_D32_FLOAT);
+}
+
+static inline bool isDepthTextureFormat(QRhiTexture::Format format)
+{
+    switch (format) {
+    case QRhiTexture::Format::D16:
+    case QRhiTexture::Format::D24:
+    case QRhiTexture::Format::D24S8:
+    case QRhiTexture::Format::D32F:
+        return true;
+    default:
+        return false;
+    }
+}
+
+bool QD3D12Texture::prepareCreate(QSize *adjustedSize)
+{
+    if (!handle.isNull())
+        destroy();
+
+    const bool isDepth = isDepthTextureFormat(m_format);
+    const bool isCube = m_flags.testFlag(CubeMap);
+    const bool is3D = m_flags.testFlag(ThreeDimensional);
+    const bool isArray = m_flags.testFlag(TextureArray);
+    const bool hasMipMaps = m_flags.testFlag(MipMapped);
+    const bool is1D = m_flags.testFlag(OneDimensional);
+
+    const QSize size = is1D ? QSize(qMax(1, m_pixelSize.width()), 1)
+                            : (m_pixelSize.isEmpty() ? QSize(1, 1) : m_pixelSize);
+
+    QRHI_RES_RHI(QRhiD3D12);
+    dxgiFormat = toD3DTextureFormat(m_format, m_flags);
+    mipLevelCount = uint(hasMipMaps ? rhiD->q->mipLevelsForSize(size) : 1);
+    sampleDesc = rhiD->effectiveSampleCount(m_sampleCount, dxgiFormat);
+    if (sampleDesc.Count > 1) {
+        if (isCube) {
+            qWarning("Cubemap texture cannot be multisample");
+            return false;
+        }
+        if (is3D) {
+            qWarning("3D texture cannot be multisample");
+            return false;
+        }
+        if (hasMipMaps) {
+            qWarning("Multisample texture cannot have mipmaps");
+            return false;
+        }
+    }
+    if (isDepth && hasMipMaps) {
+        qWarning("Depth texture cannot have mipmaps");
+        return false;
+    }
+    if (isCube && is3D) {
+        qWarning("Texture cannot be both cube and 3D");
+        return false;
+    }
+    if (isArray && is3D) {
+        qWarning("Texture cannot be both array and 3D");
+        return false;
+    }
+    if (isCube && is1D) {
+        qWarning("Texture cannot be both cube and 1D");
+        return false;
+    }
+    if (is1D && is3D) {
+        qWarning("Texture cannot be both 1D and 3D");
+        return false;
+    }
+    m_depth = qMax(1, m_depth);
+    if (m_depth > 1 && !is3D) {
+        qWarning("Texture cannot have a depth of %d when it is not 3D", m_depth);
+        return false;
+    }
+    m_arraySize = qMax(0, m_arraySize);
+    if (m_arraySize > 0 && !isArray) {
+        qWarning("Texture cannot have an array size of %d when it is not an array", m_arraySize);
+        return false;
+    }
+    if (m_arraySize < 1 && isArray) {
+        qWarning("Texture is an array but array size is %d", m_arraySize);
+        return false;
+    }
+
+    if (adjustedSize)
+        *adjustedSize = size;
+
+    return true;
+}
+
+bool QD3D12Texture::finishCreate()
+{
+    QRHI_RES_RHI(QRhiD3D12);
+    const bool isDepth = isDepthTextureFormat(m_format);
+    const bool isCube = m_flags.testFlag(CubeMap);
+    const bool is3D = m_flags.testFlag(ThreeDimensional);
+    const bool isArray = m_flags.testFlag(TextureArray);
+    const bool is1D = m_flags.testFlag(OneDimensional);
+
+    D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
+    srvDesc.Format = isDepth ? toD3DDepthTextureSRVFormat(m_format) : dxgiFormat;
+    srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
+
+    if (isCube) {
+        srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURECUBE;
+        srvDesc.TextureCube.MipLevels = mipLevelCount;
+    } else {
+        if (is1D) {
+            if (isArray) {
+                srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE1DARRAY;
+                srvDesc.Texture1DArray.MipLevels = mipLevelCount;
+                if (m_arrayRangeStart >= 0 && m_arrayRangeLength >= 0) {
+                    srvDesc.Texture1DArray.FirstArraySlice = UINT(m_arrayRangeStart);
+                    srvDesc.Texture1DArray.ArraySize = UINT(m_arrayRangeLength);
+                } else {
+                    srvDesc.Texture1DArray.FirstArraySlice = 0;
+                    srvDesc.Texture1DArray.ArraySize = UINT(m_arraySize);
+                }
+            } else {
+                srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE1D;
+                srvDesc.Texture1D.MipLevels = mipLevelCount;
+            }
+        } else if (isArray) {
+            if (sampleDesc.Count > 1) {
+                srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2DMSARRAY;
+                if (m_arrayRangeStart >= 0 && m_arrayRangeLength >= 0) {
+                    srvDesc.Texture2DMSArray.FirstArraySlice = UINT(m_arrayRangeStart);
+                    srvDesc.Texture2DMSArray.ArraySize = UINT(m_arrayRangeLength);
+                } else {
+                    srvDesc.Texture2DMSArray.FirstArraySlice = 0;
+                    srvDesc.Texture2DMSArray.ArraySize = UINT(m_arraySize);
+                }
+            } else {
+                srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2DARRAY;
+                srvDesc.Texture2DArray.MipLevels = mipLevelCount;
+                if (m_arrayRangeStart >= 0 && m_arrayRangeLength >= 0) {
+                    srvDesc.Texture2DArray.FirstArraySlice = UINT(m_arrayRangeStart);
+                    srvDesc.Texture2DArray.ArraySize = UINT(m_arrayRangeLength);
+                } else {
+                    srvDesc.Texture2DArray.FirstArraySlice = 0;
+                    srvDesc.Texture2DArray.ArraySize = UINT(m_arraySize);
+                }
+            }
+        } else {
+            if (sampleDesc.Count > 1) {
+                srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2DMS;
+            } else if (is3D) {
+                srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE3D;
+                srvDesc.Texture3D.MipLevels = mipLevelCount;
+            } else {
+                srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
+                srvDesc.Texture2D.MipLevels = mipLevelCount;
+            }
+        }
+    }
+
+    srv = rhiD->cbvSrvUavPool.allocate(1);
+    if (!srv.isValid())
+        return false;
+
+    if (QD3D12Resource *res = rhiD->resourcePool.lookupRef(handle)) {
+        rhiD->dev->CreateShaderResourceView(res->resource, &srvDesc, srv.cpuHandle);
+        if (!m_objectName.isEmpty()) {
+            const QString name = QString::fromUtf8(m_objectName);
+            res->resource->SetName(reinterpret_cast<LPCWSTR>(name.utf16()));
+        }
+    } else {
+        return false;
+    }
+
+    generation += 1;
+    return true;
+}
+
+bool QD3D12Texture::create()
+{
+    QSize size;
+    if (!prepareCreate(&size))
+        return false;
+
+    const bool isDepth = isDepthTextureFormat(m_format);
+    const bool isCube = m_flags.testFlag(CubeMap);
+    const bool is3D = m_flags.testFlag(ThreeDimensional);
+    const bool isArray = m_flags.testFlag(TextureArray);
+    const bool is1D = m_flags.testFlag(OneDimensional);
+
+    QRHI_RES_RHI(QRhiD3D12);
+
+    bool needsOptimizedClearValueSpecified = false;
+    UINT resourceFlags = 0;
+    if (m_flags.testFlag(RenderTarget)) {
+        if (isDepth)
+            resourceFlags |= D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;
+        else
+            resourceFlags |= D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET;
+        needsOptimizedClearValueSpecified = true;
+    }
+    if (m_flags.testFlag(UsedWithGenerateMips)) {
+        if (isDepth) {
+            qWarning("Depth texture cannot have mipmaps generated");
+            return false;
+        }
+        resourceFlags |= D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS;
+    }
+    if (m_flags.testFlag(UsedWithLoadStore))
+        resourceFlags |= D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS;
+
+    D3D12_RESOURCE_DESC resourceDesc = {};
+    resourceDesc.Dimension = is1D ? D3D12_RESOURCE_DIMENSION_TEXTURE1D
+                                  : (is3D ? D3D12_RESOURCE_DIMENSION_TEXTURE3D
+                                          : D3D12_RESOURCE_DIMENSION_TEXTURE2D);
+    resourceDesc.Width = UINT64(size.width());
+    resourceDesc.Height = UINT(size.height());
+    resourceDesc.DepthOrArraySize = isCube ? 6 : (isArray ? UINT(m_arraySize) : (is3D ? m_depth : 1));
+    resourceDesc.MipLevels = mipLevelCount;
+    resourceDesc.Format = dxgiFormat;
+    resourceDesc.SampleDesc = sampleDesc;
+    resourceDesc.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;
+    resourceDesc.Flags = D3D12_RESOURCE_FLAGS(resourceFlags);
+    D3D12_CLEAR_VALUE clearValue = {};
+    clearValue.Format = dxgiFormat;
+    if (isDepth) {
+        clearValue.Format = toD3DDepthTextureDSVFormat(m_format);
+        clearValue.DepthStencil.Depth = 1.0f;
+        clearValue.DepthStencil.Stencil = 0;
+    }
+    ID3D12Resource *resource = nullptr;
+    D3D12MA::Allocation *allocation = nullptr;
+    HRESULT hr = rhiD->vma.createResource(D3D12_HEAP_TYPE_DEFAULT,
+                                          &resourceDesc,
+                                          D3D12_RESOURCE_STATE_COMMON,
+                                          needsOptimizedClearValueSpecified ? &clearValue : nullptr,
+                                          &allocation,
+                                          IID_PPV_ARGS(&resource));
+    if (FAILED(hr)) {
+        qWarning("Failed to create texture: '%s'"
+                 " Dim was %d Size was %ux%u Depth/ArraySize was %u MipLevels was %u Format was %d Sample count was %d",
+                 qPrintable(QSystemError::windowsComString(hr)),
+                 int(resourceDesc.Dimension),
+                 uint(resourceDesc.Width),
+                 uint(resourceDesc.Height),
+                 uint(resourceDesc.DepthOrArraySize),
+                 uint(resourceDesc.MipLevels),
+                 int(resourceDesc.Format),
+                 int(resourceDesc.SampleDesc.Count));
+        return false;
+    }
+
+    handle = QD3D12Resource::addToPool(&rhiD->resourcePool, resource, D3D12_RESOURCE_STATE_COMMON, allocation);
+
+    if (!finishCreate())
+        return false;
+
+    rhiD->registerResource(this);
+    return true;
+}
+
+bool QD3D12Texture::createFrom(QRhiTexture::NativeTexture src)
+{
+    if (!src.object)
+        return false;
+
+    if (!prepareCreate())
+        return false;
+
+    ID3D12Resource *resource = reinterpret_cast<ID3D12Resource *>(src.object);
+    D3D12_RESOURCE_STATES state = D3D12_RESOURCE_STATES(src.layout);
+
+    QRHI_RES_RHI(QRhiD3D12);
+    handle = QD3D12Resource::addNonOwningToPool(&rhiD->resourcePool, resource, state);
+
+    if (!finishCreate())
+        return false;
+
+    rhiD->registerResource(this);
+    return true;
+}
+
+QRhiTexture::NativeTexture QD3D12Texture::nativeTexture()
+{
+    QRHI_RES_RHI(QRhiD3D12);
+    if (QD3D12Resource *res = rhiD->resourcePool.lookupRef(handle))
+        return { quint64(res->resource), int(res->state) };
+
+    return {};
+}
+
+void QD3D12Texture::setNativeLayout(int layout)
+{
+    QRHI_RES_RHI(QRhiD3D12);
+    if (QD3D12Resource *res = rhiD->resourcePool.lookupRef(handle))
+        res->state = D3D12_RESOURCE_STATES(layout);
+}
+
+QD3D12Sampler::QD3D12Sampler(QRhiImplementation *rhi, Filter magFilter, Filter minFilter, Filter mipmapMode,
+                             AddressMode u, AddressMode v, AddressMode w)
+    : QRhiSampler(rhi, magFilter, minFilter, mipmapMode, u, v, w)
+{
+}
+
+QD3D12Sampler::~QD3D12Sampler()
+{
+    destroy();
+}
+
+void QD3D12Sampler::destroy()
+{
+    shaderVisibleDescriptor = {};
+}
+
+static inline D3D12_FILTER toD3DFilter(QRhiSampler::Filter minFilter, QRhiSampler::Filter magFilter, QRhiSampler::Filter mipFilter)
+{
+    if (minFilter == QRhiSampler::Nearest) {
+        if (magFilter == QRhiSampler::Nearest) {
+            if (mipFilter == QRhiSampler::Linear)
+                return D3D12_FILTER_MIN_MAG_POINT_MIP_LINEAR;
+            else
+                return D3D12_FILTER_MIN_MAG_MIP_POINT;
+        } else {
+            if (mipFilter == QRhiSampler::Linear)
+                return D3D12_FILTER_MIN_POINT_MAG_MIP_LINEAR;
+            else
+                return D3D12_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT;
+        }
+    } else {
+        if (magFilter == QRhiSampler::Nearest) {
+            if (mipFilter == QRhiSampler::Linear)
+                return D3D12_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR;
+            else
+                return D3D12_FILTER_MIN_LINEAR_MAG_MIP_POINT;
+        } else {
+            if (mipFilter == QRhiSampler::Linear)
+                return D3D12_FILTER_MIN_MAG_MIP_LINEAR;
+            else
+                return D3D12_FILTER_MIN_MAG_LINEAR_MIP_POINT;
+        }
+    }
+    Q_UNREACHABLE_RETURN(D3D12_FILTER_MIN_MAG_MIP_LINEAR);
+}
+
+static inline D3D12_TEXTURE_ADDRESS_MODE toD3DAddressMode(QRhiSampler::AddressMode m)
+{
+    switch (m) {
+    case QRhiSampler::Repeat:
+        return D3D12_TEXTURE_ADDRESS_MODE_WRAP;
+    case QRhiSampler::ClampToEdge:
+        return D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
+    case QRhiSampler::Mirror:
+        return D3D12_TEXTURE_ADDRESS_MODE_MIRROR;
+    }
+    Q_UNREACHABLE_RETURN(D3D12_TEXTURE_ADDRESS_MODE_CLAMP);
+}
+
+static inline D3D12_COMPARISON_FUNC toD3DTextureComparisonFunc(QRhiSampler::CompareOp op)
+{
+    switch (op) {
+    case QRhiSampler::Never:
+        return D3D12_COMPARISON_FUNC_NEVER;
+    case QRhiSampler::Less:
+        return D3D12_COMPARISON_FUNC_LESS;
+    case QRhiSampler::Equal:
+        return D3D12_COMPARISON_FUNC_EQUAL;
+    case QRhiSampler::LessOrEqual:
+        return D3D12_COMPARISON_FUNC_LESS_EQUAL;
+    case QRhiSampler::Greater:
+        return D3D12_COMPARISON_FUNC_GREATER;
+    case QRhiSampler::NotEqual:
+        return D3D12_COMPARISON_FUNC_NOT_EQUAL;
+    case QRhiSampler::GreaterOrEqual:
+        return D3D12_COMPARISON_FUNC_GREATER_EQUAL;
+    case QRhiSampler::Always:
+        return D3D12_COMPARISON_FUNC_ALWAYS;
+    }
+    Q_UNREACHABLE_RETURN(D3D12_COMPARISON_FUNC_NEVER);
+}
+
+bool QD3D12Sampler::create()
+{
+    desc = {};
+    desc.Filter = toD3DFilter(m_minFilter, m_magFilter, m_mipmapMode);
+    if (m_compareOp != Never)
+        desc.Filter = D3D12_FILTER(desc.Filter | 0x80);
+    desc.AddressU = toD3DAddressMode(m_addressU);
+    desc.AddressV = toD3DAddressMode(m_addressV);
+    desc.AddressW = toD3DAddressMode(m_addressW);
+    desc.MaxAnisotropy = 1.0f;
+    desc.ComparisonFunc = toD3DTextureComparisonFunc(m_compareOp);
+    desc.MaxLOD = m_mipmapMode == None ? 0.0f : 10000.0f;
+    return true;
+}
+
+QD3D12Descriptor QD3D12Sampler::lookupOrCreateShaderVisibleDescriptor()
+{
+    if (!shaderVisibleDescriptor.isValid()) {
+        QRHI_RES_RHI(QRhiD3D12);
+        shaderVisibleDescriptor = rhiD->samplerMgr.getShaderVisibleDescriptor(desc);
+    }
+    return shaderVisibleDescriptor;
+}
+
+QD3D12TextureRenderTarget::QD3D12TextureRenderTarget(QRhiImplementation *rhi,
+                                                     const QRhiTextureRenderTargetDescription &desc,
+                                                     Flags flags)
+    : QRhiTextureRenderTarget(rhi, desc, flags),
+      d(rhi)
+{
+}
+
+QD3D12TextureRenderTarget::~QD3D12TextureRenderTarget()
+{
+    destroy();
+}
+
+void QD3D12TextureRenderTarget::destroy()
+{
+    if (!rtv[0].isValid() && !dsv.isValid())
+        return;
+
+    QRHI_RES_RHI(QRhiD3D12);
+    if (dsv.isValid()) {
+        if (ownsDsv && rhiD)
+            rhiD->releaseQueue.deferredReleaseViews(&rhiD->dsvPool, dsv, 1);
+        dsv = {};
+    }
+
+    for (int i = 0; i < QD3D12RenderTargetData::MAX_COLOR_ATTACHMENTS; ++i) {
+        if (rtv[i].isValid()) {
+            if (ownsRtv[i] && rhiD)
+                rhiD->releaseQueue.deferredReleaseViews(&rhiD->rtvPool, rtv[i], 1);
+            rtv[i] = {};
+        }
+    }
+
+    if (rhiD)
+        rhiD->unregisterResource(this);
+}
+
+QRhiRenderPassDescriptor *QD3D12TextureRenderTarget::newCompatibleRenderPassDescriptor()
+{
+    // not yet built so cannot rely on data computed in create()
+
+    QD3D12RenderPassDescriptor *rpD = new QD3D12RenderPassDescriptor(m_rhi);
+
+    rpD->colorAttachmentCount = 0;
+    for (auto it = m_desc.cbeginColorAttachments(), itEnd = m_desc.cendColorAttachments(); it != itEnd; ++it) {
+        QD3D12Texture *texD = QRHI_RES(QD3D12Texture, it->texture());
+        QD3D12RenderBuffer *rbD = QRHI_RES(QD3D12RenderBuffer, it->renderBuffer());
+        if (texD)
+            rpD->colorFormat[rpD->colorAttachmentCount] = texD->dxgiFormat;
+        else if (rbD)
+            rpD->colorFormat[rpD->colorAttachmentCount] = rbD->dxgiFormat;
+        rpD->colorAttachmentCount += 1;
+    }
+
+    rpD->hasDepthStencil = false;
+    if (m_desc.depthStencilBuffer()) {
+        rpD->hasDepthStencil = true;
+        rpD->dsFormat = QD3D12RenderBuffer::DS_FORMAT;
+    } else if (m_desc.depthTexture()) {
+        QD3D12Texture *depthTexD = QRHI_RES(QD3D12Texture, m_desc.depthTexture());
+        rpD->hasDepthStencil = true;
+        rpD->dsFormat = toD3DDepthTextureDSVFormat(depthTexD->format()); // cannot be a typeless format
+    }
+
+    rpD->updateSerializedFormat();
+
+    return rpD;
+}
+
+bool QD3D12TextureRenderTarget::create()
+{
+    if (rtv[0].isValid() || dsv.isValid())
+        destroy();
+
+    QRHI_RES_RHI(QRhiD3D12);
+    Q_ASSERT(m_desc.colorAttachmentCount() > 0 || m_desc.depthTexture());
+    Q_ASSERT(!m_desc.depthStencilBuffer() || !m_desc.depthTexture());
+    const bool hasDepthStencil = m_desc.depthStencilBuffer() || m_desc.depthTexture();
+    d.colorAttCount = 0;
+    int attIndex = 0;
+
+    for (auto it = m_desc.cbeginColorAttachments(), itEnd = m_desc.cendColorAttachments(); it != itEnd; ++it, ++attIndex) {
+        d.colorAttCount += 1;
+        const QRhiColorAttachment &colorAtt(*it);
+        QRhiTexture *texture = colorAtt.texture();
+        QRhiRenderBuffer *rb = colorAtt.renderBuffer();
+        Q_ASSERT(texture || rb);
+        if (texture) {
+            QD3D12Texture *texD = QRHI_RES(QD3D12Texture, texture);
+            QD3D12Resource *res = rhiD->resourcePool.lookupRef(texD->handle);
+            if (!res) {
+                qWarning("Could not look up texture handle for render target");
+                return false;
+            }
+            D3D12_RENDER_TARGET_VIEW_DESC rtvDesc = {};
+            rtvDesc.Format = toD3DTextureFormat(texD->format(), texD->flags());
+            if (texD->flags().testFlag(QRhiTexture::CubeMap)) {
+                rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2DARRAY;
+                rtvDesc.Texture2DArray.MipSlice = UINT(colorAtt.level());
+                rtvDesc.Texture2DArray.FirstArraySlice = UINT(colorAtt.layer());
+                rtvDesc.Texture2DArray.ArraySize = 1;
+            } else if (texD->flags().testFlag(QRhiTexture::OneDimensional)) {
+                if (texD->flags().testFlag(QRhiTexture::TextureArray)) {
+                    rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE1DARRAY;
+                    rtvDesc.Texture1DArray.MipSlice = UINT(colorAtt.level());
+                    rtvDesc.Texture1DArray.FirstArraySlice = UINT(colorAtt.layer());
+                    rtvDesc.Texture1DArray.ArraySize = 1;
+                } else {
+                    rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE1D;
+                    rtvDesc.Texture1D.MipSlice = UINT(colorAtt.level());
+                }
+            } else if (texD->flags().testFlag(QRhiTexture::TextureArray)) {
+                if (texD->sampleDesc.Count > 1) {
+                    rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2DMSARRAY;
+                    rtvDesc.Texture2DMSArray.FirstArraySlice = UINT(colorAtt.layer());
+                    rtvDesc.Texture2DMSArray.ArraySize = 1;
+                } else {
+                    rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2DARRAY;
+                    rtvDesc.Texture2DArray.MipSlice = UINT(colorAtt.level());
+                    rtvDesc.Texture2DArray.FirstArraySlice = UINT(colorAtt.layer());
+                    rtvDesc.Texture2DArray.ArraySize = 1;
+                }
+            } else if (texD->flags().testFlag(QRhiTexture::ThreeDimensional)) {
+                rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE3D;
+                rtvDesc.Texture3D.MipSlice = UINT(colorAtt.level());
+                rtvDesc.Texture3D.FirstWSlice = UINT(colorAtt.layer());
+                rtvDesc.Texture3D.WSize = 1;
+            } else {
+                if (texD->sampleDesc.Count > 1) {
+                    rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2DMS;
+                } else {
+                    rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2D;
+                    rtvDesc.Texture2D.MipSlice = UINT(colorAtt.level());
+                }
+            }
+            rtv[attIndex] = rhiD->rtvPool.allocate(1);
+            if (!rtv[attIndex].isValid()) {
+                qWarning("Failed to allocate RTV for texture render target");
+                return false;
+            }
+            rhiD->dev->CreateRenderTargetView(res->resource, &rtvDesc, rtv[attIndex].cpuHandle);
+            ownsRtv[attIndex] = true;
+            if (attIndex == 0) {
+                d.pixelSize = rhiD->q->sizeForMipLevel(colorAtt.level(), texD->pixelSize());
+                d.sampleCount = int(texD->sampleDesc.Count);
+            }
+        } else if (rb) {
+            QD3D12RenderBuffer *rbD = QRHI_RES(QD3D12RenderBuffer, rb);
+            ownsRtv[attIndex] = false;
+            rtv[attIndex] = rbD->rtv;
+            if (attIndex == 0) {
+                d.pixelSize = rbD->pixelSize();
+                d.sampleCount = int(rbD->sampleDesc.Count);
+            }
+        }
+    }
+
+    d.dpr = 1;
+
+    if (hasDepthStencil) {
+        if (m_desc.depthTexture()) {
+            ownsDsv = true;
+            QD3D12Texture *depthTexD = QRHI_RES(QD3D12Texture, m_desc.depthTexture());
+            QD3D12Resource *res = rhiD->resourcePool.lookupRef(depthTexD->handle);
+            if (!res) {
+                qWarning("Could not look up depth texture handle");
+                return false;
+            }
+            D3D12_DEPTH_STENCIL_VIEW_DESC dsvDesc = {};
+            dsvDesc.Format = toD3DDepthTextureDSVFormat(depthTexD->format());
+            dsvDesc.ViewDimension = depthTexD->sampleDesc.Count > 1 ? D3D12_DSV_DIMENSION_TEXTURE2DMS
+                                                                    : D3D12_DSV_DIMENSION_TEXTURE2D;
+            dsv = rhiD->dsvPool.allocate(1);
+            if (!dsv.isValid()) {
+                qWarning("Failed to allocate DSV for texture render target");
+                return false;
+            }
+            rhiD->dev->CreateDepthStencilView(res->resource, &dsvDesc, dsv.cpuHandle);
+            if (d.colorAttCount == 0) {
+                d.pixelSize = depthTexD->pixelSize();
+                d.sampleCount = int(depthTexD->sampleDesc.Count);
+            }
+        } else {
+            ownsDsv = false;
+            QD3D12RenderBuffer *depthRbD = QRHI_RES(QD3D12RenderBuffer, m_desc.depthStencilBuffer());
+            dsv = depthRbD->dsv;
+            if (d.colorAttCount == 0) {
+                d.pixelSize = m_desc.depthStencilBuffer()->pixelSize();
+                d.sampleCount = int(depthRbD->sampleDesc.Count);
+            }
+        }
+        d.dsAttCount = 1;
+    } else {
+        d.dsAttCount = 0;
+    }
+
+    D3D12_CPU_DESCRIPTOR_HANDLE nullDescHandle = { 0 };
+    for (int i = 0; i < QD3D12RenderTargetData::MAX_COLOR_ATTACHMENTS; ++i)
+        d.rtv[i] = i < d.colorAttCount ? rtv[i].cpuHandle : nullDescHandle;
+    d.dsv = dsv.cpuHandle;
+    d.rp = QRHI_RES(QD3D12RenderPassDescriptor, m_renderPassDesc);
+
+    QRhiRenderTargetAttachmentTracker::updateResIdList<QD3D12Texture, QD3D12RenderBuffer>(m_desc, &d.currentResIdList);
+
+    rhiD->registerResource(this);
+    return true;
+}
+
+QSize QD3D12TextureRenderTarget::pixelSize() const
+{
+    if (!QRhiRenderTargetAttachmentTracker::isUpToDate<QD3D12Texture, QD3D12RenderBuffer>(m_desc, d.currentResIdList))
+        const_cast<QD3D12TextureRenderTarget *>(this)->create();
+
+    return d.pixelSize;
+}
+
+float QD3D12TextureRenderTarget::devicePixelRatio() const
+{
+    return d.dpr;
+}
+
+int QD3D12TextureRenderTarget::sampleCount() const
+{
+    return d.sampleCount;
+}
+
+QD3D12ShaderResourceBindings::QD3D12ShaderResourceBindings(QRhiImplementation *rhi)
+    : QRhiShaderResourceBindings(rhi)
+{
+}
+
+QD3D12ShaderResourceBindings::~QD3D12ShaderResourceBindings()
+{
+    destroy();
+}
+
+void QD3D12ShaderResourceBindings::destroy()
+{
+    sortedBindings.clear();
+}
+
+bool QD3D12ShaderResourceBindings::create()
+{
+    if (!sortedBindings.isEmpty())
+        destroy();
+
+    QRHI_RES_RHI(QRhiD3D12);
+    if (!rhiD->sanityCheckShaderResourceBindings(this))
+        return false;
+
+    rhiD->updateLayoutDesc(this);
+
+    std::copy(m_bindings.cbegin(), m_bindings.cend(), std::back_inserter(sortedBindings));
+    std::sort(sortedBindings.begin(), sortedBindings.end(), QRhiImplementation::sortedBindingLessThan);
+
+    hasDynamicOffset = false;
+    for (const QRhiShaderResourceBinding &b : sortedBindings) {
+        const QRhiShaderResourceBinding::Data *bd = QRhiImplementation::shaderResourceBindingData(b);
+        if (bd->type == QRhiShaderResourceBinding::UniformBuffer && bd->u.ubuf.hasDynamicOffset) {
+            hasDynamicOffset = true;
+            break;
+        }
+    }
+
+    // The root signature is not part of the srb. Unintuitive, but the shader
+    // translation pipeline ties our hands: as long as the per-shader (so per
+    // stage!) nativeResourceBindingMap exist, meaning f.ex. that a SPIR-V
+    // combined image sampler binding X passed in here may map to the tY and sY
+    // HLSL registers, where Y is known only once the mapping table from the
+    // shader is looked up. Creating a root parameters at this stage is
+    // therefore impossible.
+
+    generation += 1;
+    return true;
+}
+
+void QD3D12ShaderResourceBindings::updateResources(UpdateFlags flags)
+{
+    sortedBindings.clear();
+    std::copy(m_bindings.cbegin(), m_bindings.cend(), std::back_inserter(sortedBindings));
+    if (!flags.testFlag(BindingsAreSorted))
+        std::sort(sortedBindings.begin(), sortedBindings.end(), QRhiImplementation::sortedBindingLessThan);
+
+    generation += 1;
+}
+
+// Accessing the QRhiBuffer/Texture/Sampler resources must be avoided in the
+// callbacks; that would only be possible if the srb had those specified, and
+// that's not required at the time of srb and pipeline create() time, and
+// createRootSignature is called from the pipeline create().
+
+void QD3D12ShaderResourceBindings::visitUniformBuffer(QD3D12Stage s,
+                                                      const QRhiShaderResourceBinding::Data::UniformBufferData &,
+                                                      int shaderRegister,
+                                                      int)
+{
+    D3D12_ROOT_PARAMETER1 rootParam = {};
+    rootParam.ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
+    rootParam.ShaderVisibility = qd3d12_stageToVisibility(s);
+    rootParam.Descriptor.ShaderRegister = shaderRegister;
+    visitorData.cbParams[s].append(rootParam);
+}
+
+void QD3D12ShaderResourceBindings::visitTexture(QD3D12Stage s,
+                                                const QRhiShaderResourceBinding::TextureAndSampler &,
+                                                int shaderRegister)
+{
+    D3D12_DESCRIPTOR_RANGE1 range = {};
+    range.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
+    range.NumDescriptors = 1;
+    range.BaseShaderRegister = shaderRegister;
+    range.OffsetInDescriptorsFromTableStart = visitorData.currentSrvRangeOffset[s];
+    visitorData.currentSrvRangeOffset[s] += 1;
+    visitorData.srvRanges[s].append(range);
+    if (visitorData.srvRanges[s].count() == 1) {
+        visitorData.srvTables[s].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
+        visitorData.srvTables[s].ShaderVisibility = qd3d12_stageToVisibility(s);
+    }
+}
+
+void QD3D12ShaderResourceBindings::visitSampler(QD3D12Stage s,
+                                                const QRhiShaderResourceBinding::TextureAndSampler &,
+                                                int shaderRegister)
+{
+    // Unlike SRVs and UAVs, samplers are handled so that each sampler becomes
+    // a root parameter with its own descriptor table.
+
+    int &rangeStoreIdx(visitorData.samplerRangeHeads[s]);
+    if (rangeStoreIdx == 16) {
+        qWarning("Sampler count in QD3D12Stage %d exceeds the limit of 16, this is disallowed by QRhi", s);
+        return;
+    }
+    D3D12_DESCRIPTOR_RANGE1 range = {};
+    range.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SAMPLER;
+    range.NumDescriptors = 1;
+    range.BaseShaderRegister = shaderRegister;
+    visitorData.samplerRanges[s][rangeStoreIdx] = range;
+    D3D12_ROOT_PARAMETER1 param = {};
+    param.ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
+    param.ShaderVisibility = qd3d12_stageToVisibility(s);
+    param.DescriptorTable.NumDescriptorRanges = 1;
+    param.DescriptorTable.pDescriptorRanges = &visitorData.samplerRanges[s][rangeStoreIdx];
+    rangeStoreIdx += 1;
+    visitorData.samplerTables[s].append(param);
+}
+
+void QD3D12ShaderResourceBindings::visitStorageBuffer(QD3D12Stage s,
+                                                      const QRhiShaderResourceBinding::Data::StorageBufferData &,
+                                                      QD3D12ShaderResourceVisitor::StorageOp,
+                                                      int shaderRegister)
+{
+    D3D12_DESCRIPTOR_RANGE1 range = {};
+    range.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_UAV;
+    range.NumDescriptors = 1;
+    range.BaseShaderRegister = shaderRegister;
+    range.OffsetInDescriptorsFromTableStart = visitorData.currentUavRangeOffset[s];
+    visitorData.currentUavRangeOffset[s] += 1;
+    visitorData.uavRanges[s].append(range);
+    if (visitorData.uavRanges[s].count() == 1) {
+        visitorData.uavTables[s].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
+        visitorData.uavTables[s].ShaderVisibility = qd3d12_stageToVisibility(s);
+    }
+}
+
+void QD3D12ShaderResourceBindings::visitStorageImage(QD3D12Stage s,
+                                                     const QRhiShaderResourceBinding::Data::StorageImageData &,
+                                                     QD3D12ShaderResourceVisitor::StorageOp,
+                                                     int shaderRegister)
+{
+    D3D12_DESCRIPTOR_RANGE1 range = {};
+    range.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_UAV;
+    range.NumDescriptors = 1;
+    range.BaseShaderRegister = shaderRegister;
+    range.OffsetInDescriptorsFromTableStart = visitorData.currentUavRangeOffset[s];
+    visitorData.currentUavRangeOffset[s] += 1;
+    visitorData.uavRanges[s].append(range);
+    if (visitorData.uavRanges[s].count() == 1) {
+        visitorData.uavTables[s].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
+        visitorData.uavTables[s].ShaderVisibility = qd3d12_stageToVisibility(s);
+    }
+}
+
+QD3D12ObjectHandle QD3D12ShaderResourceBindings::createRootSignature(const QD3D12ShaderStageData *stageData,
+                                                                     int stageCount)
+{
+    if (!QtD3D12ApiSupport::instance()->pD3D12SerializeVersionedRootSignature)
+        return {};
+
+    QRHI_RES_RHI(QRhiD3D12);
+
+    // It's not just that the root signature has to be tied to the pipeline
+    // (cannot just freely create it like e.g. with Vulkan where one just
+    // creates a descriptor layout 1:1 with the QRhiShaderResourceBindings'
+    // data), due to not knowing the shader-specific resource binding mapping
+    // tables at the point of srb creation, but each shader stage may have a
+    // different mapping table. (ugh!)
+    //
+    // Hence we set up everything per-stage, even if it means the root
+    // signature gets unnecessarily big. (note that the magic is in the
+    // ShaderVisibility: even though the register range is the same in the
+    // descriptor tables, the visibility is different)
+
+    QD3D12ShaderResourceVisitor visitor(this, stageData, stageCount);
+
+    visitorData = {};
+
+    using namespace std::placeholders;
+    visitor.uniformBuffer = std::bind(&QD3D12ShaderResourceBindings::visitUniformBuffer, this, _1, _2, _3, _4);
+    visitor.texture = std::bind(&QD3D12ShaderResourceBindings::visitTexture, this, _1, _2, _3);
+    visitor.sampler = std::bind(&QD3D12ShaderResourceBindings::visitSampler, this, _1, _2, _3);
+    visitor.storageBuffer = std::bind(&QD3D12ShaderResourceBindings::visitStorageBuffer, this, _1, _2, _3, _4);
+    visitor.storageImage = std::bind(&QD3D12ShaderResourceBindings::visitStorageImage, this, _1, _2, _3, _4);
+
+    visitor.visit();
+
+    // The maximum size of a root signature is 256 bytes, where a descriptor
+    // table is 4, a root descriptor (e.g. CBV) is 8. We have 5 stages at most
+    // (or 1 with compute) and a separate descriptor table for SRVs (->
+    // textures) and UAVs (-> storage buffers and images) per stage, plus each
+    // uniform buffer counts as a CBV in the stages it is visible.
+    //
+    // Due to the limited maximum size of a shader-visible sampler heap (2048)
+    // and the potential costly switching of descriptor heaps, each sampler is
+    // declared as a separate root parameter / descriptor table (meaning that
+    // two samplers in the same stage are two parameters and two tables, not
+    // just one). QRhi documents a hard limit of 16 on texture/sampler bindings
+    // in a shader (matching D3D11), so we can hopefully get away with this.
+    //
+    // This means that e.g. a vertex+fragment shader with a uniform buffer
+    // visible in both and one texture+sampler in the fragment shader would
+    // consume 2*8 + 4 + 4 = 24 bytes. This also implies that clients
+    // specifying the minimal stage bit mask for each entry in
+    // QRhiShaderResourceBindings are ideal for this backend since it helps
+    // reducing the chance of hitting the size limit.
+
+    QVarLengthArray<D3D12_ROOT_PARAMETER1, 4> rootParams;
+    for (int s = 0; s < 6; ++s) {
+        if (!visitorData.cbParams[s].isEmpty())
+            rootParams.append(visitorData.cbParams[s].constData(), visitorData.cbParams[s].count());
+    }
+    for (int s = 0; s < 6; ++s) {
+        if (!visitorData.srvRanges[s].isEmpty()) {
+            visitorData.srvTables[s].DescriptorTable.NumDescriptorRanges = visitorData.srvRanges[s].count();
+            visitorData.srvTables[s].DescriptorTable.pDescriptorRanges = visitorData.srvRanges[s].constData();
+            rootParams.append(visitorData.srvTables[s]);
+        }
+    }
+    for (int s = 0; s < 6; ++s) {
+        if (!visitorData.samplerTables[s].isEmpty())
+            rootParams.append(visitorData.samplerTables[s].constData(), visitorData.samplerTables[s].count());
+    }
+    for (int s = 0; s < 6; ++s) {
+        if (!visitorData.uavRanges[s].isEmpty()) {
+            visitorData.uavTables[s].DescriptorTable.NumDescriptorRanges = visitorData.uavRanges[s].count();
+            visitorData.uavTables[s].DescriptorTable.pDescriptorRanges = visitorData.uavRanges[s].constData();
+            rootParams.append(visitorData.uavTables[s]);
+        }
+    }
+
+    D3D12_VERSIONED_ROOT_SIGNATURE_DESC rsDesc = {};
+    rsDesc.Version = D3D_ROOT_SIGNATURE_VERSION_1_1;
+    if (!rootParams.isEmpty()) {
+        rsDesc.Desc_1_1.NumParameters = rootParams.count();
+        rsDesc.Desc_1_1.pParameters = rootParams.constData();
+    }
+
+    UINT rsFlags = 0;
+    for (int stageIdx = 0; stageIdx < stageCount; ++stageIdx) {
+        if (stageData[stageIdx].valid && stageData[stageIdx].stage == VS)
+            rsFlags |= D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
+    }
+    rsDesc.Desc_1_1.Flags = D3D12_ROOT_SIGNATURE_FLAGS(rsFlags);
+
+    ID3DBlob *signature = nullptr;
+    HRESULT hr = QtD3D12ApiSupport::instance()->pD3D12SerializeVersionedRootSignature(&rsDesc, &signature, nullptr);
+    if (FAILED(hr)) {
+        qWarning("Failed to serialize root signature: %s", qPrintable(QSystemError::windowsComString(hr)));
+        return {};
+    }
+    ID3D12RootSignature *rootSig = nullptr;
+    hr = rhiD->dev->CreateRootSignature(0,
+                                        signature->GetBufferPointer(),
+                                        signature->GetBufferSize(),
+                                        IID_PPV_ARGS(&rootSig));
+    signature->Release();
+    if (FAILED(hr)) {
+        qWarning("Failed to create root signature: %s", qPrintable(QSystemError::windowsComString(hr)));
+        return {};
+    }
+
+    return QD3D12RootSignature::addToPool(&rhiD->rootSignaturePool, rootSig);
+}
+
+// For now we mirror exactly what's done in the D3D11 backend, meaning we use
+// the old shader compiler (so like fxc, not dxc) to generate shader model 5.0
+// output. Some day this should be moved to the new compiler and DXIL.
+
+static pD3DCompile resolveD3DCompile()
+{
+    for (const wchar_t *libraryName : {L"D3DCompiler_47", L"D3DCompiler_43"}) {
+        QSystemLibrary library(libraryName);
+        if (library.load()) {
+            if (auto symbol = library.resolve("D3DCompile"))
+                return reinterpret_cast<pD3DCompile>(symbol);
+        }
+    }
+    return nullptr;
+}
+
+static inline void makeHlslTargetString(char target[7], const char stage[3], int version)
+{
+    const int smMajor = version / 10;
+    const int smMinor = version % 10;
+    target[0] = stage[0];
+    target[1] = stage[1];
+    target[2] = '_';
+    target[3] = '0' + smMajor;
+    target[4] = '_';
+    target[5] = '0' + smMinor;
+    target[6] = '\0';
+}
+
+static QByteArray compileHlslShaderSource(const QShader &shader,
+                                          QShader::Variant shaderVariant,
+                                          UINT flags,
+                                          QString *error,
+                                          QShaderKey *usedShaderKey)
+{
+    // look for SM 6.7, 6.6, .., 5.0
+    const int shaderModelMax = 67;
+    for (int sm = shaderModelMax; sm >= 50; --sm) {
+        for (QShader::Source type : { QShader::DxilShader, QShader::DxbcShader }) {
+            QShaderKey key = { type, sm, shaderVariant };
+            QShaderCode intermediateBytecodeShader = shader.shader(key);
+            if (!intermediateBytecodeShader.shader().isEmpty()) {
+                if (usedShaderKey)
+                    *usedShaderKey = key;
+                return intermediateBytecodeShader.shader();
+            }
+        }
+    }
+
+    QShaderCode hlslSource;
+    QShaderKey key;
+    for (int sm = shaderModelMax; sm >= 50; --sm) {
+        key = { QShader::HlslShader, sm, shaderVariant };
+        hlslSource = shader.shader(key);
+        if (!hlslSource.shader().isEmpty())
+            break;
+    }
+
+    if (hlslSource.shader().isEmpty()) {
+        qWarning() << "No HLSL (shader model 6.7..5.0) code found in baked shader" << shader;
+        return QByteArray();
+    }
+
+    if (usedShaderKey)
+        *usedShaderKey = key;
+
+    char target[7];
+    switch (shader.stage()) {
+    case QShader::VertexStage:
+        makeHlslTargetString(target, "vs", key.sourceVersion().version());
+        break;
+    case QShader::TessellationControlStage:
+        makeHlslTargetString(target, "hs", key.sourceVersion().version());
+        break;
+    case QShader::TessellationEvaluationStage:
+        makeHlslTargetString(target, "ds", key.sourceVersion().version());
+        break;
+    case QShader::GeometryStage:
+        makeHlslTargetString(target, "gs", key.sourceVersion().version());
+        break;
+    case QShader::FragmentStage:
+        makeHlslTargetString(target, "ps", key.sourceVersion().version());
+        break;
+    case QShader::ComputeStage:
+        makeHlslTargetString(target, "cs", key.sourceVersion().version());
+        break;
+    }
+
+    static const pD3DCompile d3dCompile = resolveD3DCompile();
+    if (!d3dCompile) {
+        qWarning("Unable to resolve function D3DCompile()");
+        return QByteArray();
+    }
+
+    ID3DBlob *bytecode = nullptr;
+    ID3DBlob *errors = nullptr;
+    HRESULT hr = d3dCompile(hlslSource.shader().constData(), SIZE_T(hlslSource.shader().size()),
+                            nullptr, nullptr, nullptr,
+                            hlslSource.entryPoint().constData(), target, flags, 0, &bytecode, &errors);
+    if (FAILED(hr) || !bytecode) {
+        qWarning("HLSL shader compilation failed: 0x%x", uint(hr));
+        if (errors) {
+            *error = QString::fromUtf8(static_cast<const char *>(errors->GetBufferPointer()),
+                                       int(errors->GetBufferSize()));
+            errors->Release();
+        }
+        return QByteArray();
+    }
+
+    QByteArray result;
+    result.resize(int(bytecode->GetBufferSize()));
+    memcpy(result.data(), bytecode->GetBufferPointer(), size_t(result.size()));
+    bytecode->Release();
+
+    return result;
+}
+
+static inline UINT8 toD3DColorWriteMask(QRhiGraphicsPipeline::ColorMask c)
+{
+    UINT8 f = 0;
+    if (c.testFlag(QRhiGraphicsPipeline::R))
+        f |= D3D12_COLOR_WRITE_ENABLE_RED;
+    if (c.testFlag(QRhiGraphicsPipeline::G))
+        f |= D3D12_COLOR_WRITE_ENABLE_GREEN;
+    if (c.testFlag(QRhiGraphicsPipeline::B))
+        f |= D3D12_COLOR_WRITE_ENABLE_BLUE;
+    if (c.testFlag(QRhiGraphicsPipeline::A))
+        f |= D3D12_COLOR_WRITE_ENABLE_ALPHA;
+    return f;
+}
+
+static inline D3D12_BLEND toD3DBlendFactor(QRhiGraphicsPipeline::BlendFactor f, bool rgb)
+{
+    // SrcBlendAlpha and DstBlendAlpha do not accept *_COLOR. With other APIs
+    // this is handled internally (so that e.g. VK_BLEND_FACTOR_SRC_COLOR is
+    // accepted and is in effect equivalent to VK_BLEND_FACTOR_SRC_ALPHA when
+    // set as an alpha src/dest factor), but for D3D we have to take care of it
+    // ourselves. Hence the rgb argument.
+
+    switch (f) {
+    case QRhiGraphicsPipeline::Zero:
+        return D3D12_BLEND_ZERO;
+    case QRhiGraphicsPipeline::One:
+        return D3D12_BLEND_ONE;
+    case QRhiGraphicsPipeline::SrcColor:
+        return rgb ? D3D12_BLEND_SRC_COLOR : D3D12_BLEND_SRC_ALPHA;
+    case QRhiGraphicsPipeline::OneMinusSrcColor:
+        return rgb ? D3D12_BLEND_INV_SRC_COLOR : D3D12_BLEND_INV_SRC_ALPHA;
+    case QRhiGraphicsPipeline::DstColor:
+        return rgb ? D3D12_BLEND_DEST_COLOR : D3D12_BLEND_DEST_ALPHA;
+    case QRhiGraphicsPipeline::OneMinusDstColor:
+        return rgb ? D3D12_BLEND_INV_DEST_COLOR : D3D12_BLEND_INV_DEST_ALPHA;
+    case QRhiGraphicsPipeline::SrcAlpha:
+        return D3D12_BLEND_SRC_ALPHA;
+    case QRhiGraphicsPipeline::OneMinusSrcAlpha:
+        return D3D12_BLEND_INV_SRC_ALPHA;
+    case QRhiGraphicsPipeline::DstAlpha:
+        return D3D12_BLEND_DEST_ALPHA;
+    case QRhiGraphicsPipeline::OneMinusDstAlpha:
+        return D3D12_BLEND_INV_DEST_ALPHA;
+    case QRhiGraphicsPipeline::ConstantColor:
+    case QRhiGraphicsPipeline::ConstantAlpha:
+        return D3D12_BLEND_BLEND_FACTOR;
+    case QRhiGraphicsPipeline::OneMinusConstantColor:
+    case QRhiGraphicsPipeline::OneMinusConstantAlpha:
+        return D3D12_BLEND_INV_BLEND_FACTOR;
+    case QRhiGraphicsPipeline::SrcAlphaSaturate:
+        return D3D12_BLEND_SRC_ALPHA_SAT;
+    case QRhiGraphicsPipeline::Src1Color:
+        return rgb ? D3D12_BLEND_SRC1_COLOR : D3D12_BLEND_SRC1_ALPHA;
+    case QRhiGraphicsPipeline::OneMinusSrc1Color:
+        return rgb ? D3D12_BLEND_INV_SRC1_COLOR : D3D12_BLEND_INV_SRC1_ALPHA;
+    case QRhiGraphicsPipeline::Src1Alpha:
+        return D3D12_BLEND_SRC1_ALPHA;
+    case QRhiGraphicsPipeline::OneMinusSrc1Alpha:
+        return D3D12_BLEND_INV_SRC1_ALPHA;
+    }
+    Q_UNREACHABLE_RETURN(D3D12_BLEND_ZERO);
+}
+
+static inline D3D12_BLEND_OP toD3DBlendOp(QRhiGraphicsPipeline::BlendOp op)
+{
+    switch (op) {
+    case QRhiGraphicsPipeline::Add:
+        return D3D12_BLEND_OP_ADD;
+    case QRhiGraphicsPipeline::Subtract:
+        return D3D12_BLEND_OP_SUBTRACT;
+    case QRhiGraphicsPipeline::ReverseSubtract:
+        return D3D12_BLEND_OP_REV_SUBTRACT;
+    case QRhiGraphicsPipeline::Min:
+        return D3D12_BLEND_OP_MIN;
+    case QRhiGraphicsPipeline::Max:
+        return D3D12_BLEND_OP_MAX;
+    }
+    Q_UNREACHABLE_RETURN(D3D12_BLEND_OP_ADD);
+}
+
+static inline D3D12_CULL_MODE toD3DCullMode(QRhiGraphicsPipeline::CullMode c)
+{
+    switch (c) {
+    case QRhiGraphicsPipeline::None:
+        return D3D12_CULL_MODE_NONE;
+    case QRhiGraphicsPipeline::Front:
+        return D3D12_CULL_MODE_FRONT;
+    case QRhiGraphicsPipeline::Back:
+        return D3D12_CULL_MODE_BACK;
+    }
+    Q_UNREACHABLE_RETURN(D3D12_CULL_MODE_NONE);
+}
+
+static inline D3D12_FILL_MODE toD3DFillMode(QRhiGraphicsPipeline::PolygonMode mode)
+{
+    switch (mode) {
+    case QRhiGraphicsPipeline::Fill:
+        return D3D12_FILL_MODE_SOLID;
+    case QRhiGraphicsPipeline::Line:
+        return D3D12_FILL_MODE_WIREFRAME;
+    }
+    Q_UNREACHABLE_RETURN(D3D12_FILL_MODE_SOLID);
+}
+
+static inline D3D12_COMPARISON_FUNC toD3DCompareOp(QRhiGraphicsPipeline::CompareOp op)
+{
+    switch (op) {
+    case QRhiGraphicsPipeline::Never:
+        return D3D12_COMPARISON_FUNC_NEVER;
+    case QRhiGraphicsPipeline::Less:
+        return D3D12_COMPARISON_FUNC_LESS;
+    case QRhiGraphicsPipeline::Equal:
+        return D3D12_COMPARISON_FUNC_EQUAL;
+    case QRhiGraphicsPipeline::LessOrEqual:
+        return D3D12_COMPARISON_FUNC_LESS_EQUAL;
+    case QRhiGraphicsPipeline::Greater:
+        return D3D12_COMPARISON_FUNC_GREATER;
+    case QRhiGraphicsPipeline::NotEqual:
+        return D3D12_COMPARISON_FUNC_NOT_EQUAL;
+    case QRhiGraphicsPipeline::GreaterOrEqual:
+        return D3D12_COMPARISON_FUNC_GREATER_EQUAL;
+    case QRhiGraphicsPipeline::Always:
+        return D3D12_COMPARISON_FUNC_ALWAYS;
+    }
+    Q_UNREACHABLE_RETURN(D3D12_COMPARISON_FUNC_ALWAYS);
+}
+
+static inline D3D12_STENCIL_OP toD3DStencilOp(QRhiGraphicsPipeline::StencilOp op)
+{
+    switch (op) {
+    case QRhiGraphicsPipeline::StencilZero:
+        return D3D12_STENCIL_OP_ZERO;
+    case QRhiGraphicsPipeline::Keep:
+        return D3D12_STENCIL_OP_KEEP;
+    case QRhiGraphicsPipeline::Replace:
+        return D3D12_STENCIL_OP_REPLACE;
+    case QRhiGraphicsPipeline::IncrementAndClamp:
+        return D3D12_STENCIL_OP_INCR_SAT;
+    case QRhiGraphicsPipeline::DecrementAndClamp:
+        return D3D12_STENCIL_OP_DECR_SAT;
+    case QRhiGraphicsPipeline::Invert:
+        return D3D12_STENCIL_OP_INVERT;
+    case QRhiGraphicsPipeline::IncrementAndWrap:
+        return D3D12_STENCIL_OP_INCR;
+    case QRhiGraphicsPipeline::DecrementAndWrap:
+        return D3D12_STENCIL_OP_DECR;
+    }
+    Q_UNREACHABLE_RETURN(D3D12_STENCIL_OP_KEEP);
+}
+
+static inline D3D12_PRIMITIVE_TOPOLOGY toD3DTopology(QRhiGraphicsPipeline::Topology t, int patchControlPointCount)
+{
+    switch (t) {
+    case QRhiGraphicsPipeline::Triangles:
+        return D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST;
+    case QRhiGraphicsPipeline::TriangleStrip:
+        return D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP;
+    case QRhiGraphicsPipeline::TriangleFan:
+        qWarning("Triangle fans are not supported with D3D");
+        return D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP;
+    case QRhiGraphicsPipeline::Lines:
+        return D3D_PRIMITIVE_TOPOLOGY_LINELIST;
+    case QRhiGraphicsPipeline::LineStrip:
+        return D3D_PRIMITIVE_TOPOLOGY_LINESTRIP;
+    case QRhiGraphicsPipeline::Points:
+        return D3D_PRIMITIVE_TOPOLOGY_POINTLIST;
+    case QRhiGraphicsPipeline::Patches:
+        Q_ASSERT(patchControlPointCount >= 1 && patchControlPointCount <= 32);
+        return D3D_PRIMITIVE_TOPOLOGY(D3D_PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST + (patchControlPointCount - 1));
+    }
+    Q_UNREACHABLE_RETURN(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
+}
+
+static inline D3D12_PRIMITIVE_TOPOLOGY_TYPE toD3DTopologyType(QRhiGraphicsPipeline::Topology t)
+{
+    switch (t) {
+    case QRhiGraphicsPipeline::Triangles:
+    case QRhiGraphicsPipeline::TriangleStrip:
+    case QRhiGraphicsPipeline::TriangleFan:
+        return D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
+    case QRhiGraphicsPipeline::Lines:
+    case QRhiGraphicsPipeline::LineStrip:
+        return D3D12_PRIMITIVE_TOPOLOGY_TYPE_LINE;
+    case QRhiGraphicsPipeline::Points:
+        return D3D12_PRIMITIVE_TOPOLOGY_TYPE_POINT;
+    case QRhiGraphicsPipeline::Patches:
+        return D3D12_PRIMITIVE_TOPOLOGY_TYPE_PATCH;
+    }
+    Q_UNREACHABLE_RETURN(D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE);
+}
+
+static inline DXGI_FORMAT toD3DAttributeFormat(QRhiVertexInputAttribute::Format format)
+{
+    switch (format) {
+    case QRhiVertexInputAttribute::Float4:
+        return DXGI_FORMAT_R32G32B32A32_FLOAT;
+    case QRhiVertexInputAttribute::Float3:
+        return DXGI_FORMAT_R32G32B32_FLOAT;
+    case QRhiVertexInputAttribute::Float2:
+        return DXGI_FORMAT_R32G32_FLOAT;
+    case QRhiVertexInputAttribute::Float:
+        return DXGI_FORMAT_R32_FLOAT;
+    case QRhiVertexInputAttribute::UNormByte4:
+        return DXGI_FORMAT_R8G8B8A8_UNORM;
+    case QRhiVertexInputAttribute::UNormByte2:
+        return DXGI_FORMAT_R8G8_UNORM;
+    case QRhiVertexInputAttribute::UNormByte:
+        return DXGI_FORMAT_R8_UNORM;
+    case QRhiVertexInputAttribute::UInt4:
+        return DXGI_FORMAT_R32G32B32A32_UINT;
+    case QRhiVertexInputAttribute::UInt3:
+        return DXGI_FORMAT_R32G32B32_UINT;
+    case QRhiVertexInputAttribute::UInt2:
+        return DXGI_FORMAT_R32G32_UINT;
+    case QRhiVertexInputAttribute::UInt:
+        return DXGI_FORMAT_R32_UINT;
+     case QRhiVertexInputAttribute::SInt4:
+        return DXGI_FORMAT_R32G32B32A32_SINT;
+    case QRhiVertexInputAttribute::SInt3:
+        return DXGI_FORMAT_R32G32B32_SINT;
+    case QRhiVertexInputAttribute::SInt2:
+        return DXGI_FORMAT_R32G32_SINT;
+    case QRhiVertexInputAttribute::SInt:
+        return DXGI_FORMAT_R32_SINT;
+    case QRhiVertexInputAttribute::Half4:
+    // Note: D3D does not support half3.  Pass through half3 as half4.
+    case QRhiVertexInputAttribute::Half3:
+        return DXGI_FORMAT_R16G16B16A16_FLOAT;
+    case QRhiVertexInputAttribute::Half2:
+        return DXGI_FORMAT_R16G16_FLOAT;
+    case QRhiVertexInputAttribute::Half:
+         return DXGI_FORMAT_R16_FLOAT;
+    }
+    Q_UNREACHABLE_RETURN(DXGI_FORMAT_R32G32B32A32_FLOAT);
+}
+
+QD3D12GraphicsPipeline::QD3D12GraphicsPipeline(QRhiImplementation *rhi)
+    : QRhiGraphicsPipeline(rhi)
+{
+}
+
+QD3D12GraphicsPipeline::~QD3D12GraphicsPipeline()
+{
+    destroy();
+}
+
+void QD3D12GraphicsPipeline::destroy()
+{
+    if (handle.isNull())
+        return;
+
+    QRHI_RES_RHI(QRhiD3D12);
+    if (rhiD) {
+        rhiD->releaseQueue.deferredReleasePipeline(handle);
+        rhiD->releaseQueue.deferredReleaseRootSignature(rootSigHandle);
+    }
+
+    handle = {};
+    stageData = {};
+
+    if (rhiD)
+        rhiD->unregisterResource(this);
+}
+
+bool QD3D12GraphicsPipeline::create()
+{
+    if (!handle.isNull())
+        destroy();
+
+    QRHI_RES_RHI(QRhiD3D12);
+    if (!rhiD->sanityCheckGraphicsPipeline(this))
+        return false;
+
+    rhiD->pipelineCreationStart();
+
+    QByteArray shaderBytecode[5];
+    for (const QRhiShaderStage &shaderStage : std::as_const(m_shaderStages)) {
+        const QD3D12Stage d3dStage = qd3d12_stage(shaderStage.type());
+        stageData[d3dStage].valid = true;
+        stageData[d3dStage].stage = d3dStage;
+        auto cacheIt = rhiD->shaderBytecodeCache.data.constFind(shaderStage);
+        if (cacheIt != rhiD->shaderBytecodeCache.data.constEnd()) {
+            shaderBytecode[d3dStage] = cacheIt->bytecode;
+            stageData[d3dStage].nativeResourceBindingMap = cacheIt->nativeResourceBindingMap;
+        } else {
+            QString error;
+            QShaderKey shaderKey;
+            UINT compileFlags = 0;
+            if (m_flags.testFlag(CompileShadersWithDebugInfo))
+                compileFlags |= D3DCOMPILE_DEBUG;
+            const QByteArray bytecode = compileHlslShaderSource(shaderStage.shader(),
+                                                                shaderStage.shaderVariant(),
+                                                                compileFlags,
+                                                                &error,
+                                                                &shaderKey);
+            if (bytecode.isEmpty()) {
+                qWarning("HLSL compute shader compilation failed: %s", qPrintable(error));
+                return false;
+            }
+
+            shaderBytecode[d3dStage] = bytecode;
+            stageData[d3dStage].nativeResourceBindingMap = shaderStage.shader().nativeResourceBindingMap(shaderKey);
+            rhiD->shaderBytecodeCache.insertWithCapacityLimit(shaderStage,
+                                                              { bytecode, stageData[d3dStage].nativeResourceBindingMap });
+        }
+    }
+
+    QD3D12ShaderResourceBindings *srbD = QRHI_RES(QD3D12ShaderResourceBindings, m_shaderResourceBindings);
+    if (srbD) {
+        rootSigHandle = srbD->createRootSignature(stageData.data(), 5);
+        if (rootSigHandle.isNull()) {
+            qWarning("Failed to create root signature");
+            return false;
+        }
+    }
+    ID3D12RootSignature *rootSig = nullptr;
+    if (QD3D12RootSignature *rs = rhiD->rootSignaturePool.lookupRef(rootSigHandle))
+        rootSig = rs->rootSig;
+    if (!rootSig) {
+        qWarning("Cannot create graphics pipeline state without root signature");
+        return false;
+    }
+
+    QD3D12RenderPassDescriptor *rpD = QRHI_RES(QD3D12RenderPassDescriptor, m_renderPassDesc);
+    const DXGI_SAMPLE_DESC sampleDesc = rhiD->effectiveSampleCount(m_sampleCount, DXGI_FORMAT(rpD->colorFormat[0]));
+
+    D3D12_GRAPHICS_PIPELINE_STATE_DESC psoDesc = {};
+    psoDesc.pRootSignature = rootSig;
+    for (const QRhiShaderStage &shaderStage : std::as_const(m_shaderStages)) {
+        const int d3dStage = qd3d12_stage(shaderStage.type());
+        switch (d3dStage) {
+        case VS:
+            psoDesc.VS.pShaderBytecode = shaderBytecode[d3dStage].constData();
+            psoDesc.VS.BytecodeLength = shaderBytecode[d3dStage].size();
+            break;
+        case HS:
+            psoDesc.HS.pShaderBytecode = shaderBytecode[d3dStage].constData();
+            psoDesc.HS.BytecodeLength = shaderBytecode[d3dStage].size();
+            break;
+        case DS:
+            psoDesc.DS.pShaderBytecode = shaderBytecode[d3dStage].constData();
+            psoDesc.DS.BytecodeLength = shaderBytecode[d3dStage].size();
+            break;
+        case GS:
+            psoDesc.GS.pShaderBytecode = shaderBytecode[d3dStage].constData();
+            psoDesc.GS.BytecodeLength = shaderBytecode[d3dStage].size();
+            break;
+        case PS:
+            psoDesc.PS.pShaderBytecode = shaderBytecode[d3dStage].constData();
+            psoDesc.PS.BytecodeLength = shaderBytecode[d3dStage].size();
+            break;
+        default:
+            Q_UNREACHABLE();
+            break;
+        }
+    }
+
+    psoDesc.BlendState.IndependentBlendEnable = m_targetBlends.count() > 1;
+    for (int i = 0, ie = m_targetBlends.count(); i != ie; ++i) {
+        const QRhiGraphicsPipeline::TargetBlend &b(m_targetBlends[i]);
+        D3D12_RENDER_TARGET_BLEND_DESC blend = {};
+        blend.BlendEnable = b.enable;
+        blend.SrcBlend = toD3DBlendFactor(b.srcColor, true);
+        blend.DestBlend = toD3DBlendFactor(b.dstColor, true);
+        blend.BlendOp = toD3DBlendOp(b.opColor);
+        blend.SrcBlendAlpha = toD3DBlendFactor(b.srcAlpha, false);
+        blend.DestBlendAlpha = toD3DBlendFactor(b.dstAlpha, false);
+        blend.BlendOpAlpha = toD3DBlendOp(b.opAlpha);
+        blend.RenderTargetWriteMask = toD3DColorWriteMask(b.colorWrite);
+        psoDesc.BlendState.RenderTarget[i] = blend;
+    }
+    if (m_targetBlends.isEmpty()) {
+        D3D12_RENDER_TARGET_BLEND_DESC blend = {};
+        blend.RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;
+        psoDesc.BlendState.RenderTarget[0] = blend;
+    }
+
+    psoDesc.SampleMask = 0xFFFFFFFF;
+
+    psoDesc.RasterizerState.FillMode = toD3DFillMode(m_polygonMode);
+    psoDesc.RasterizerState.CullMode = toD3DCullMode(m_cullMode);
+    psoDesc.RasterizerState.FrontCounterClockwise = m_frontFace == CCW;
+    psoDesc.RasterizerState.DepthBias = m_depthBias;
+    psoDesc.RasterizerState.SlopeScaledDepthBias = m_slopeScaledDepthBias;
+    psoDesc.RasterizerState.DepthClipEnable = TRUE;
+    psoDesc.RasterizerState.MultisampleEnable = sampleDesc.Count > 1;
+
+    psoDesc.DepthStencilState.DepthEnable = m_depthTest;
+    psoDesc.DepthStencilState.DepthWriteMask = m_depthWrite ? D3D12_DEPTH_WRITE_MASK_ALL : D3D12_DEPTH_WRITE_MASK_ZERO;
+    psoDesc.DepthStencilState.DepthFunc = toD3DCompareOp(m_depthOp);
+    psoDesc.DepthStencilState.StencilEnable = m_stencilTest;
+    if (m_stencilTest) {
+        psoDesc.DepthStencilState.StencilReadMask = UINT8(m_stencilReadMask);
+        psoDesc.DepthStencilState.StencilWriteMask = UINT8(m_stencilWriteMask);
+        psoDesc.DepthStencilState.FrontFace.StencilFailOp = toD3DStencilOp(m_stencilFront.failOp);
+        psoDesc.DepthStencilState.FrontFace.StencilDepthFailOp = toD3DStencilOp(m_stencilFront.depthFailOp);
+        psoDesc.DepthStencilState.FrontFace.StencilPassOp = toD3DStencilOp(m_stencilFront.passOp);
+        psoDesc.DepthStencilState.FrontFace.StencilFunc = toD3DCompareOp(m_stencilFront.compareOp);
+        psoDesc.DepthStencilState.BackFace.StencilFailOp = toD3DStencilOp(m_stencilBack.failOp);
+        psoDesc.DepthStencilState.BackFace.StencilDepthFailOp = toD3DStencilOp(m_stencilBack.depthFailOp);
+        psoDesc.DepthStencilState.BackFace.StencilPassOp = toD3DStencilOp(m_stencilBack.passOp);
+        psoDesc.DepthStencilState.BackFace.StencilFunc = toD3DCompareOp(m_stencilBack.compareOp);
+    }
+
+    QVarLengthArray<D3D12_INPUT_ELEMENT_DESC, 4> inputDescs;
+    QByteArrayList matrixSliceSemantics;
+    if (!shaderBytecode[VS].isEmpty()) {
+        for (auto it = m_vertexInputLayout.cbeginAttributes(), itEnd = m_vertexInputLayout.cendAttributes();
+             it != itEnd; ++it)
+        {
+            D3D12_INPUT_ELEMENT_DESC desc = {};
+            // The output from SPIRV-Cross uses TEXCOORD<location> as the
+            // semantic, except for matrices that are unrolled into consecutive
+            // vec2/3/4s attributes and need TEXCOORD<location>_ as
+            // SemanticName and row/column index as SemanticIndex.
+            const int matrixSlice = it->matrixSlice();
+            if (matrixSlice < 0) {
+                desc.SemanticName = "TEXCOORD";
+                desc.SemanticIndex = UINT(it->location());
+            } else {
+                QByteArray sem;
+                sem.resize(16);
+                qsnprintf(sem.data(), sem.size(), "TEXCOORD%d_", it->location() - matrixSlice);
+                matrixSliceSemantics.append(sem);
+                desc.SemanticName = matrixSliceSemantics.last().constData();
+                desc.SemanticIndex = UINT(matrixSlice);
+            }
+            desc.Format = toD3DAttributeFormat(it->format());
+            desc.InputSlot = UINT(it->binding());
+            desc.AlignedByteOffset = it->offset();
+            const QRhiVertexInputBinding *inputBinding = m_vertexInputLayout.bindingAt(it->binding());
+            if (inputBinding->classification() == QRhiVertexInputBinding::PerInstance) {
+                desc.InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA;
+                desc.InstanceDataStepRate = inputBinding->instanceStepRate();
+            } else {
+                desc.InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
+            }
+            inputDescs.append(desc);
+        }
+    }
+    if (!inputDescs.isEmpty()) {
+        psoDesc.InputLayout.pInputElementDescs = inputDescs.constData();
+        psoDesc.InputLayout.NumElements = inputDescs.count();
+    }
+
+    psoDesc.PrimitiveTopologyType = toD3DTopologyType(m_topology);
+    topology = toD3DTopology(m_topology, m_patchControlPointCount);
+
+    psoDesc.NumRenderTargets = rpD->colorAttachmentCount;
+    for (int i = 0; i < rpD->colorAttachmentCount; ++i)
+        psoDesc.RTVFormats[i] = DXGI_FORMAT(rpD->colorFormat[i]);
+    psoDesc.DSVFormat = rpD->hasDepthStencil ? DXGI_FORMAT(rpD->dsFormat) : DXGI_FORMAT_UNKNOWN;
+    psoDesc.SampleDesc = sampleDesc;
+
+    ID3D12PipelineState *pso = nullptr;
+    HRESULT hr = rhiD->dev->CreateGraphicsPipelineState(&psoDesc, IID_PPV_ARGS(&pso));
+    if (FAILED(hr)) {
+        qWarning("Failed to create graphics pipeline state: %s",
+                 qPrintable(QSystemError::windowsComString(hr)));
+        rhiD->rootSignaturePool.remove(rootSigHandle);
+        rootSigHandle = {};
+        return false;
+    }
+
+    handle = QD3D12Pipeline::addToPool(&rhiD->pipelinePool, QD3D12Pipeline::Graphics, pso);
+
+    rhiD->pipelineCreationEnd();
+    generation += 1;
+    rhiD->registerResource(this);
+    return true;
+}
+
+QD3D12ComputePipeline::QD3D12ComputePipeline(QRhiImplementation *rhi)
+    : QRhiComputePipeline(rhi)
+{
+}
+
+QD3D12ComputePipeline::~QD3D12ComputePipeline()
+{
+    destroy();
+}
+
+void QD3D12ComputePipeline::destroy()
+{
+    if (handle.isNull())
+        return;
+
+    QRHI_RES_RHI(QRhiD3D12);
+    if (rhiD) {
+        rhiD->releaseQueue.deferredReleasePipeline(handle);
+        rhiD->releaseQueue.deferredReleaseRootSignature(rootSigHandle);
+    }
+
+    handle = {};
+    stageData = {};
+
+    if (rhiD)
+        rhiD->unregisterResource(this);
+}
+
+bool QD3D12ComputePipeline::create()
+{
+    if (!handle.isNull())
+        destroy();
+
+    QRHI_RES_RHI(QRhiD3D12);
+    rhiD->pipelineCreationStart();
+
+    stageData.valid = true;
+    stageData.stage = CS;
+
+    QByteArray shaderBytecode;
+    auto cacheIt = rhiD->shaderBytecodeCache.data.constFind(m_shaderStage);
+    if (cacheIt != rhiD->shaderBytecodeCache.data.constEnd()) {
+        shaderBytecode = cacheIt->bytecode;
+        stageData.nativeResourceBindingMap = cacheIt->nativeResourceBindingMap;
+    } else {
+        QString error;
+        QShaderKey shaderKey;
+        UINT compileFlags = 0;
+        if (m_flags.testFlag(CompileShadersWithDebugInfo))
+            compileFlags |= D3DCOMPILE_DEBUG;
+        const QByteArray bytecode = compileHlslShaderSource(m_shaderStage.shader(),
+                                                            m_shaderStage.shaderVariant(),
+                                                            compileFlags,
+                                                            &error,
+                                                            &shaderKey);
+        if (bytecode.isEmpty()) {
+            qWarning("HLSL compute shader compilation failed: %s", qPrintable(error));
+            return false;
+        }
+
+        shaderBytecode = bytecode;
+        stageData.nativeResourceBindingMap = m_shaderStage.shader().nativeResourceBindingMap(shaderKey);
+        rhiD->shaderBytecodeCache.insertWithCapacityLimit(m_shaderStage, { bytecode,
+                                                                           stageData.nativeResourceBindingMap });
+    }
+
+    QD3D12ShaderResourceBindings *srbD = QRHI_RES(QD3D12ShaderResourceBindings, m_shaderResourceBindings);
+    if (srbD) {
+        rootSigHandle = srbD->createRootSignature(&stageData, 1);
+        if (rootSigHandle.isNull()) {
+            qWarning("Failed to create root signature");
+            return false;
+        }
+    }
+    ID3D12RootSignature *rootSig = nullptr;
+    if (QD3D12RootSignature *rs = rhiD->rootSignaturePool.lookupRef(rootSigHandle))
+        rootSig = rs->rootSig;
+    if (!rootSig) {
+        qWarning("Cannot create compute pipeline state without root signature");
+        return false;
+    }
+
+    D3D12_COMPUTE_PIPELINE_STATE_DESC psoDesc = {};
+    psoDesc.pRootSignature = rootSig;
+    psoDesc.CS.pShaderBytecode = shaderBytecode.constData();
+    psoDesc.CS.BytecodeLength = shaderBytecode.size();
+    ID3D12PipelineState *pso = nullptr;
+    HRESULT hr = rhiD->dev->CreateComputePipelineState(&psoDesc, IID_PPV_ARGS(&pso));
+    if (FAILED(hr)) {
+        qWarning("Failed to create compute pipeline state: %s",
+                 qPrintable(QSystemError::windowsComString(hr)));
+        rhiD->rootSignaturePool.remove(rootSigHandle);
+        rootSigHandle = {};
+        return false;
+    }
+
+    handle = QD3D12Pipeline::addToPool(&rhiD->pipelinePool, QD3D12Pipeline::Compute, pso);
+
+    rhiD->pipelineCreationEnd();
+    generation += 1;
+    rhiD->registerResource(this);
+    return true;
+}
+
+// This is a lot like in the Metal backend: we need to now the rtv and dsv
+// formats to create a graphics pipeline, and that's exactly what our
+// "renderpass descriptor" is going to hold.
+QD3D12RenderPassDescriptor::QD3D12RenderPassDescriptor(QRhiImplementation *rhi)
+    : QRhiRenderPassDescriptor(rhi)
+{
+    serializedFormatData.reserve(16);
+}
+
+QD3D12RenderPassDescriptor::~QD3D12RenderPassDescriptor()
+{
+    destroy();
+}
+
+void QD3D12RenderPassDescriptor::destroy()
+{
+    // nothing to do here
+}
+
+bool QD3D12RenderPassDescriptor::isCompatible(const QRhiRenderPassDescriptor *other) const
+{
+    if (!other)
+        return false;
+
+    const QD3D12RenderPassDescriptor *o = QRHI_RES(const QD3D12RenderPassDescriptor, other);
+
+    if (colorAttachmentCount != o->colorAttachmentCount)
+        return false;
+
+    if (hasDepthStencil != o->hasDepthStencil)
+         return false;
+
+    for (int i = 0; i < colorAttachmentCount; ++i) {
+        if (colorFormat[i] != o->colorFormat[i])
+            return false;
+    }
+
+    if (hasDepthStencil) {
+        if (dsFormat != o->dsFormat)
+            return false;
+    }
+
+    return true;
+}
+
+void QD3D12RenderPassDescriptor::updateSerializedFormat()
+{
+    serializedFormatData.clear();
+    auto p = std::back_inserter(serializedFormatData);
+
+    *p++ = colorAttachmentCount;
+    *p++ = hasDepthStencil;
+    for (int i = 0; i < colorAttachmentCount; ++i)
+      *p++ = colorFormat[i];
+    *p++ = hasDepthStencil ? dsFormat : 0;
+}
+
+QRhiRenderPassDescriptor *QD3D12RenderPassDescriptor::newCompatibleRenderPassDescriptor() const
+{
+    QD3D12RenderPassDescriptor *rp = new QD3D12RenderPassDescriptor(m_rhi);
+    rp->colorAttachmentCount = colorAttachmentCount;
+    rp->hasDepthStencil = hasDepthStencil;
+    memcpy(rp->colorFormat, colorFormat, sizeof(colorFormat));
+    rp->dsFormat = dsFormat;
+    rp->updateSerializedFormat();
+    return rp;
+}
+
+QVector<quint32> QD3D12RenderPassDescriptor::serializedFormat() const
+{
+    return serializedFormatData;
+}
+
+QD3D12CommandBuffer::QD3D12CommandBuffer(QRhiImplementation *rhi)
+    : QRhiCommandBuffer(rhi)
+{
+    resetState();
+}
+
+QD3D12CommandBuffer::~QD3D12CommandBuffer()
+{
+    destroy();
+}
+
+void QD3D12CommandBuffer::destroy()
+{
+    // nothing to do here, the command list is not owned by us
+}
+
+const QRhiNativeHandles *QD3D12CommandBuffer::nativeHandles()
+{
+    nativeHandlesStruct.commandList = cmdList;
+    return &nativeHandlesStruct;
+}
+
+QD3D12SwapChainRenderTarget::QD3D12SwapChainRenderTarget(QRhiImplementation *rhi, QRhiSwapChain *swapchain)
+    : QRhiSwapChainRenderTarget(rhi, swapchain),
+      d(rhi)
+{
+}
+
+QD3D12SwapChainRenderTarget::~QD3D12SwapChainRenderTarget()
+{
+    destroy();
+}
+
+void QD3D12SwapChainRenderTarget::destroy()
+{
+    // nothing to do here
+}
+
+QSize QD3D12SwapChainRenderTarget::pixelSize() const
+{
+    return d.pixelSize;
+}
+
+float QD3D12SwapChainRenderTarget::devicePixelRatio() const
+{
+    return d.dpr;
+}
+
+int QD3D12SwapChainRenderTarget::sampleCount() const
+{
+    return d.sampleCount;
+}
+
+QD3D12SwapChain::QD3D12SwapChain(QRhiImplementation *rhi)
+    : QRhiSwapChain(rhi),
+      rtWrapper(rhi, this),
+      cbWrapper(rhi)
+{
+}
+
+QD3D12SwapChain::~QD3D12SwapChain()
+{
+    destroy();
+}
+
+void QD3D12SwapChain::destroy()
+{
+    if (!swapChain)
+        return;
+
+    releaseBuffers();
+
+    swapChain->Release();
+    swapChain = nullptr;
+    sourceSwapChain1->Release();
+    sourceSwapChain1 = nullptr;
+
+    for (int i = 0; i < QD3D12_FRAMES_IN_FLIGHT; ++i) {
+        FrameResources &fr(frameRes[i]);
+        if (fr.fence)
+            fr.fence->Release();
+        if (fr.fenceEvent)
+            CloseHandle(fr.fenceEvent);
+        if (fr.cmdList)
+            fr.cmdList->Release();
+        fr = {};
+    }
+
+    if (dcompVisual) {
+        dcompVisual->Release();
+        dcompVisual = nullptr;
+    }
+
+    if (dcompTarget) {
+        dcompTarget->Release();
+        dcompTarget = nullptr;
+    }
+
+    QRHI_RES_RHI(QRhiD3D12);
+    if (rhiD) {
+        rhiD->swapchains.remove(this);
+        rhiD->unregisterResource(this);
+    }
+}
+
+void QD3D12SwapChain::releaseBuffers()
+{
+    QRHI_RES_RHI(QRhiD3D12);
+    rhiD->waitGpu();
+    for (UINT i = 0; i < BUFFER_COUNT; ++i) {
+        rhiD->resourcePool.remove(colorBuffers[i]);
+        rhiD->rtvPool.release(rtvs[i], 1);
+        if (!msaaBuffers[i].isNull())
+            rhiD->resourcePool.remove(msaaBuffers[i]);
+        if (msaaRtvs[i].isValid())
+            rhiD->rtvPool.release(msaaRtvs[i], 1);
+    }
+}
+
+void QD3D12SwapChain::waitCommandCompletionForFrameSlot(int frameSlot)
+{
+    FrameResources &fr(frameRes[frameSlot]);
+    if (fr.fence->GetCompletedValue() < fr.fenceCounter) {
+        fr.fence->SetEventOnCompletion(fr.fenceCounter, fr.fenceEvent);
+        WaitForSingleObject(fr.fenceEvent, INFINITE);
+    }
+}
+
+void QD3D12SwapChain::addCommandCompletionSignalForCurrentFrameSlot()
+{
+    QRHI_RES_RHI(QRhiD3D12);
+    FrameResources &fr(frameRes[currentFrameSlot]);
+    fr.fenceCounter += 1u;
+    rhiD->cmdQueue->Signal(fr.fence, fr.fenceCounter);
+}
+
+QRhiCommandBuffer *QD3D12SwapChain::currentFrameCommandBuffer()
+{
+    return &cbWrapper;
+}
+
+QRhiRenderTarget *QD3D12SwapChain::currentFrameRenderTarget()
+{
+    return &rtWrapper;
+}
+
+QSize QD3D12SwapChain::surfacePixelSize()
+{
+    Q_ASSERT(m_window);
+    return m_window->size() * m_window->devicePixelRatio();
+}
+
+static bool output6ForWindow(QWindow *w, IDXGIAdapter1 *adapter, IDXGIOutput6 **result)
+{
+    bool ok = false;
+    QRect wr = w->geometry();
+    wr = QRect(wr.topLeft() * w->devicePixelRatio(), wr.size() * w->devicePixelRatio());
+    const QPoint center = wr.center();
+    IDXGIOutput *currentOutput = nullptr;
+    IDXGIOutput *output = nullptr;
+    for (UINT i = 0; adapter->EnumOutputs(i, &output) != DXGI_ERROR_NOT_FOUND; ++i) {
+        DXGI_OUTPUT_DESC desc;
+        output->GetDesc(&desc);
+        const RECT r = desc.DesktopCoordinates;
+        const QRect dr(QPoint(r.left, r.top), QPoint(r.right - 1, r.bottom - 1));
+        if (dr.contains(center)) {
+            currentOutput = output;
+            break;
+        } else {
+            output->Release();
+        }
+    }
+    if (currentOutput) {
+        ok = SUCCEEDED(currentOutput->QueryInterface(IID_PPV_ARGS(result)));
+        currentOutput->Release();
+    }
+    return ok;
+}
+
+static bool outputDesc1ForWindow(QWindow *w, IDXGIAdapter1 *adapter, DXGI_OUTPUT_DESC1 *result)
+{
+    bool ok = false;
+    IDXGIOutput6 *out6 = nullptr;
+    if (output6ForWindow(w, adapter, &out6)) {
+        ok = SUCCEEDED(out6->GetDesc1(result));
+        out6->Release();
+    }
+    return ok;
+}
+
+bool QD3D12SwapChain::isFormatSupported(Format f)
+{
+    if (f == SDR)
+        return true;
+
+    if (!m_window) {
+        qWarning("Attempted to call isFormatSupported() without a window set");
+        return false;
+    }
+
+    QRHI_RES_RHI(QRhiD3D12);
+    DXGI_OUTPUT_DESC1 desc1;
+    if (outputDesc1ForWindow(m_window, rhiD->activeAdapter, &desc1))
+        return desc1.ColorSpace == DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020;
+
+    return false;
+}
+
+QRhiSwapChainHdrInfo QD3D12SwapChain::hdrInfo()
+{
+    QRhiSwapChainHdrInfo info = QRhiSwapChain::hdrInfo();
+    if (m_format != QRhiSwapChain::SDR && m_window) {
+        QRHI_RES_RHI(QRhiD3D12);
+        DXGI_OUTPUT_DESC1 hdrOutputDesc;
+        if (outputDesc1ForWindow(m_window, rhiD->activeAdapter, &hdrOutputDesc)) {
+            info.isHardCodedDefaults = false;
+            info.limitsType = QRhiSwapChainHdrInfo::LuminanceInNits;
+            info.limits.luminanceInNits.minLuminance = hdrOutputDesc.MinLuminance;
+            info.limits.luminanceInNits.maxLuminance = hdrOutputDesc.MaxLuminance;
+        }
+    }
+    return info;
+}
+
+QRhiRenderPassDescriptor *QD3D12SwapChain::newCompatibleRenderPassDescriptor()
+{
+    // not yet built so cannot rely on data computed in createOrResize()
+    chooseFormats();
+
+    QD3D12RenderPassDescriptor *rpD = new QD3D12RenderPassDescriptor(m_rhi);
+    rpD->colorAttachmentCount = 1;
+    rpD->hasDepthStencil = m_depthStencil != nullptr;
+    rpD->colorFormat[0] = int(srgbAdjustedColorFormat);
+    rpD->dsFormat = QD3D12RenderBuffer::DS_FORMAT;
+    rpD->updateSerializedFormat();
+    return rpD;
+}
+
+static const DXGI_FORMAT DEFAULT_FORMAT = DXGI_FORMAT_R8G8B8A8_UNORM;
+static const DXGI_FORMAT DEFAULT_SRGB_FORMAT = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
+
+bool QRhiD3D12::ensureDirectCompositionDevice()
+{
+    if (!QtD3D12ApiSupport::instance()->pDCompositionCreateDevice) {
+        qWarning() << "DirectComposition is not available on current platform.";
+        return false;
+    }
+
+    if (dcompDevice)
+        return true;
+
+    qCDebug(QRHI_LOG_INFO, "Creating Direct Composition device (needed for semi-transparent windows)");
+
+    HRESULT hr = QtD3D12ApiSupport::instance()->pDCompositionCreateDevice(
+                nullptr, IID_PPV_ARGS(&dcompDevice));
+    if (FAILED(hr)) {
+        qWarning("Failed to Direct Composition device: %s", qPrintable(QSystemError::windowsComString(hr)));
+        return false;
+    }
+
+    return true;
+}
+
+void QD3D12SwapChain::chooseFormats()
+{
+    colorFormat = DEFAULT_FORMAT;
+    srgbAdjustedColorFormat = m_flags.testFlag(sRGB) ? DEFAULT_SRGB_FORMAT : DEFAULT_FORMAT;
+    hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709; // SDR
+    DXGI_OUTPUT_DESC1 hdrOutputDesc;
+    QRHI_RES_RHI(QRhiD3D12);
+    if (outputDesc1ForWindow(m_window, rhiD->activeAdapter, &hdrOutputDesc) && m_format != SDR) {
+        // https://docs.microsoft.com/en-us/windows/win32/direct3darticles/high-dynamic-range
+        if (hdrOutputDesc.ColorSpace == DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020) {
+            switch (m_format) {
+            case HDRExtendedSrgbLinear:
+                colorFormat = DXGI_FORMAT_R16G16B16A16_FLOAT;
+                hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709;
+                srgbAdjustedColorFormat = colorFormat;
+                break;
+            case HDR10:
+                colorFormat = DXGI_FORMAT_R10G10B10A2_UNORM;
+                hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020;
+                srgbAdjustedColorFormat = colorFormat;
+                break;
+            default:
+                break;
+            }
+        } else {
+            // This happens also when Use HDR is set to Off in the Windows
+            // Display settings. Show a helpful warning, but continue with the
+            // default non-HDR format.
+            qWarning("The output associated with the window is not HDR capable "
+                     "(or Use HDR is Off in the Display Settings), ignoring HDR format request");
+        }
+    }
+    sampleDesc = rhiD->effectiveSampleCount(m_sampleCount, colorFormat);
+}
+
+bool QD3D12SwapChain::createOrResize()
+{
+    // Can be called multiple times due to window resizes - that is not the
+    // same as a simple destroy+create (as with other resources). Just need to
+    // resize the buffers then.
+
+    const bool needsRegistration = !window || window != m_window;
+
+    // except if the window actually changes
+    if (window && window != m_window)
+        destroy();
+
+    window = m_window;
+    m_currentPixelSize = surfacePixelSize();
+    pixelSize = m_currentPixelSize;
+
+    if (pixelSize.isEmpty())
+        return false;
+
+    HWND hwnd = reinterpret_cast<HWND>(window->winId());
+    HRESULT hr;
+    QRHI_RES_RHI(QRhiD3D12);
+
+    if (m_flags.testFlag(SurfaceHasPreMulAlpha) || m_flags.testFlag(SurfaceHasNonPreMulAlpha)) {
+        if (rhiD->ensureDirectCompositionDevice()) {
+            if (!dcompTarget) {
+                hr = rhiD->dcompDevice->CreateTargetForHwnd(hwnd, true, &dcompTarget);
+                if (FAILED(hr)) {
+                    qWarning("Failed to create Direct Compsition target for the window: %s",
+                             qPrintable(QSystemError::windowsComString(hr)));
+                }
+            }
+            if (dcompTarget && !dcompVisual) {
+                hr = rhiD->dcompDevice->CreateVisual(&dcompVisual);
+                if (FAILED(hr)) {
+                    qWarning("Failed to create DirectComposition visual: %s",
+                             qPrintable(QSystemError::windowsComString(hr)));
+                }
+            }
+        }
+        // simple consistency check
+        if (window->requestedFormat().alphaBufferSize() <= 0)
+            qWarning("Swapchain says surface has alpha but the window has no alphaBufferSize set. "
+                     "This may lead to problems.");
+    }
+
+    swapInterval = m_flags.testFlag(QRhiSwapChain::NoVSync) ? 0 : 1;
+    swapChainFlags = 0;
+    if (swapInterval == 0 && rhiD->supportsAllowTearing)
+        swapChainFlags |= DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING;
+
+    if (!swapChain) {
+        chooseFormats();
+
+        DXGI_SWAP_CHAIN_DESC1 desc = {};
+        desc.Width = UINT(pixelSize.width());
+        desc.Height = UINT(pixelSize.height());
+        desc.Format = colorFormat;
+        desc.SampleDesc.Count = 1;
+        desc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
+        desc.BufferCount = BUFFER_COUNT;
+        desc.Flags = swapChainFlags;
+        desc.Scaling = DXGI_SCALING_NONE;
+        desc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
+
+        if (dcompVisual) {
+            // With DirectComposition setting AlphaMode to STRAIGHT fails the
+            // swapchain creation, whereas the result seems to be identical
+            // with any of the other values, including IGNORE. (?)
+            desc.AlphaMode = DXGI_ALPHA_MODE_PREMULTIPLIED;
+
+            // DirectComposition has its own limitations, cannot use
+            // SCALING_NONE. So with semi-transparency requested we are forced
+            // to SCALING_STRETCH.
+            desc.Scaling = DXGI_SCALING_STRETCH;
+        }
+
+        if (dcompVisual)
+            hr = rhiD->dxgiFactory->CreateSwapChainForComposition(rhiD->cmdQueue, &desc, nullptr, &sourceSwapChain1);
+        else
+            hr = rhiD->dxgiFactory->CreateSwapChainForHwnd(rhiD->cmdQueue, hwnd, &desc, nullptr, nullptr, &sourceSwapChain1);
+
+        // If failed and we tried a HDR format, then try with SDR. This
+        // matches other backends, such as Vulkan where if the format is
+        // not supported, the default one is used instead.
+        if (FAILED(hr) && m_format != SDR) {
+            colorFormat = DEFAULT_FORMAT;
+            desc.Format = DEFAULT_FORMAT;
+            if (dcompVisual)
+                hr = rhiD->dxgiFactory->CreateSwapChainForComposition(rhiD->cmdQueue, &desc, nullptr, &sourceSwapChain1);
+            else
+                hr = rhiD->dxgiFactory->CreateSwapChainForHwnd(rhiD->cmdQueue, hwnd, &desc, nullptr, nullptr, &sourceSwapChain1);
+        }
+
+        if (SUCCEEDED(hr)) {
+            if (FAILED(sourceSwapChain1->QueryInterface(IID_PPV_ARGS(&swapChain)))) {
+                qWarning("IDXGISwapChain3 not available");
+                return false;
+            }
+            if (m_format != SDR) {
+                hr = swapChain->SetColorSpace1(hdrColorSpace);
+                if (FAILED(hr)) {
+                    qWarning("Failed to set color space on swapchain: %s",
+                             qPrintable(QSystemError::windowsComString(hr)));
+                }
+            }
+            if (dcompVisual) {
+                hr = dcompVisual->SetContent(swapChain);
+                if (SUCCEEDED(hr)) {
+                    hr = dcompTarget->SetRoot(dcompVisual);
+                    if (FAILED(hr)) {
+                        qWarning("Failed to associate Direct Composition visual with the target: %s",
+                                 qPrintable(QSystemError::windowsComString(hr)));
+                    }
+                } else {
+                    qWarning("Failed to set content for Direct Composition visual: %s",
+                             qPrintable(QSystemError::windowsComString(hr)));
+                }
+            }
+        }
+        if (FAILED(hr)) {
+            qWarning("Failed to create D3D12 swapchain: %s", qPrintable(QSystemError::windowsComString(hr)));
+            return false;
+        }
+        rhiD->dxgiFactory->MakeWindowAssociation(hwnd, DXGI_MWA_NO_WINDOW_CHANGES);
+
+        for (int i = 0; i < QD3D12_FRAMES_IN_FLIGHT; ++i) {
+            hr = rhiD->dev->CreateFence(0,
+                                        D3D12_FENCE_FLAG_NONE,
+                                        IID_PPV_ARGS(&frameRes[i].fence));
+            if (FAILED(hr)) {
+                qWarning("Failed to create fence for swapchain: %s",
+                         qPrintable(QSystemError::windowsComString(hr)));
+                return false;
+            }
+            frameRes[i].fenceEvent = CreateEvent(nullptr, FALSE, FALSE, nullptr);
+
+            frameRes[i].fenceCounter = 0;
+        }
+    } else {
+        releaseBuffers();
+        hr = swapChain->ResizeBuffers(BUFFER_COUNT,
+                                      UINT(pixelSize.width()),
+                                      UINT(pixelSize.height()),
+                                      colorFormat,
+                                      swapChainFlags);
+        if (hr == DXGI_ERROR_DEVICE_REMOVED || hr == DXGI_ERROR_DEVICE_RESET) {
+            qWarning("Device loss detected in ResizeBuffers()");
+            rhiD->deviceLost = true;
+            return false;
+        } else if (FAILED(hr)) {
+            qWarning("Failed to resize D3D12 swapchain: %s", qPrintable(QSystemError::windowsComString(hr)));
+            return false;
+        }
+    }
+
+    for (UINT i = 0; i < BUFFER_COUNT; ++i) {
+        ID3D12Resource *colorBuffer;
+        hr = swapChain->GetBuffer(i, IID_PPV_ARGS(&colorBuffer));
+        if (FAILED(hr)) {
+            qWarning("Failed to get buffer %u for D3D12 swapchain: %s",
+                     i, qPrintable(QSystemError::windowsComString(hr)));
+            return false;
+        }
+        colorBuffers[i] = QD3D12Resource::addToPool(&rhiD->resourcePool, colorBuffer, D3D12_RESOURCE_STATE_PRESENT);
+        rtvs[i] = rhiD->rtvPool.allocate(1);
+        D3D12_RENDER_TARGET_VIEW_DESC rtvDesc = {};
+        rtvDesc.Format = srgbAdjustedColorFormat;
+        rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2D;
+        rhiD->dev->CreateRenderTargetView(colorBuffer, &rtvDesc, rtvs[i].cpuHandle);
+    }
+
+    if (m_depthStencil && m_depthStencil->sampleCount() != m_sampleCount) {
+        qWarning("Depth-stencil buffer's sampleCount (%d) does not match color buffers' sample count (%d). Expect problems.",
+                 m_depthStencil->sampleCount(), m_sampleCount);
+    }
+    if (m_depthStencil && m_depthStencil->pixelSize() != pixelSize) {
+        if (m_depthStencil->flags().testFlag(QRhiRenderBuffer::UsedWithSwapChainOnly)) {
+            m_depthStencil->setPixelSize(pixelSize);
+            if (!m_depthStencil->create())
+                qWarning("Failed to rebuild swapchain's associated depth-stencil buffer for size %dx%d",
+                         pixelSize.width(), pixelSize.height());
+        } else {
+            qWarning("Depth-stencil buffer's size (%dx%d) does not match the surface size (%dx%d). Expect problems.",
+                     m_depthStencil->pixelSize().width(), m_depthStencil->pixelSize().height(),
+                     pixelSize.width(), pixelSize.height());
+        }
+    }
+
+    ds = m_depthStencil ? QRHI_RES(QD3D12RenderBuffer, m_depthStencil) : nullptr;
+
+    if (sampleDesc.Count > 1) {
+        for (UINT i = 0; i < BUFFER_COUNT; ++i) {
+            D3D12_RESOURCE_DESC resourceDesc = {};
+            resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
+            resourceDesc.Width = UINT64(pixelSize.width());
+            resourceDesc.Height = UINT(pixelSize.height());
+            resourceDesc.DepthOrArraySize = 1;
+            resourceDesc.MipLevels = 1;
+            resourceDesc.Format = srgbAdjustedColorFormat;
+            resourceDesc.SampleDesc = sampleDesc;
+            resourceDesc.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;
+            resourceDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET;
+            D3D12_CLEAR_VALUE clearValue = {};
+            clearValue.Format = colorFormat;
+            ID3D12Resource *resource = nullptr;
+            D3D12MA::Allocation *allocation = nullptr;
+            HRESULT hr = rhiD->vma.createResource(D3D12_HEAP_TYPE_DEFAULT,
+                                                  &resourceDesc,
+                                                  D3D12_RESOURCE_STATE_RENDER_TARGET,
+                                                  &clearValue,
+                                                  &allocation,
+                                                  IID_PPV_ARGS(&resource));
+            if (FAILED(hr)) {
+                qWarning("Failed to create MSAA color buffer: %s", qPrintable(QSystemError::windowsComString(hr)));
+                return false;
+            }
+            msaaBuffers[i] = QD3D12Resource::addToPool(&rhiD->resourcePool, resource, D3D12_RESOURCE_STATE_RENDER_TARGET, allocation);
+            msaaRtvs[i] = rhiD->rtvPool.allocate(1);
+            if (!msaaRtvs[i].isValid())
+                return false;
+            D3D12_RENDER_TARGET_VIEW_DESC rtvDesc = {};
+            rtvDesc.Format = srgbAdjustedColorFormat;
+            rtvDesc.ViewDimension = sampleDesc.Count > 1 ? D3D12_RTV_DIMENSION_TEXTURE2DMS
+                                                         : D3D12_RTV_DIMENSION_TEXTURE2D;
+            rhiD->dev->CreateRenderTargetView(resource, &rtvDesc, msaaRtvs[i].cpuHandle);
+        }
+    }
+
+    currentBackBufferIndex = swapChain->GetCurrentBackBufferIndex();
+    currentFrameSlot = 0;
+
+    rtWrapper.setRenderPassDescriptor(m_renderPassDesc); // for the public getter in QRhiRenderTarget
+    QD3D12SwapChainRenderTarget *rtD = QRHI_RES(QD3D12SwapChainRenderTarget, &rtWrapper);
+    rtD->d.rp = QRHI_RES(QD3D12RenderPassDescriptor, m_renderPassDesc);
+    rtD->d.pixelSize = pixelSize;
+    rtD->d.dpr = float(window->devicePixelRatio());
+    rtD->d.sampleCount = int(sampleDesc.Count);
+    rtD->d.colorAttCount = 1;
+    rtD->d.dsAttCount = m_depthStencil ? 1 : 0;
+
+    if (needsRegistration) {
+        rhiD->swapchains.insert(this);
+        rhiD->registerResource(this);
+    }
+
+    return true;
+}
+
+QT_END_NAMESPACE
diff --git a/src/gui/text/qtextcursor.cpp b/src/gui/text/qtextcursor.cpp
index c23bcf0317..a2a62338ab 100644
--- a/src/gui/text/qtextcursor.cpp
+++ b/src/gui/text/qtextcursor.cpp
@@ -474,6 +474,9 @@ bool QTextCursorPrivate::movePosition(QTextCursor::MoveOperation op, QTextCursor
         const int len = blockIt.length() - 1;
         if (relativePos >= len)
             return false;
+        // Patch: Improved apostrophe processing.
+        relativePos = engine->toEdge(relativePos, len, true);
+#if 0
         if (engine->atWordSeparator(relativePos)) {
             ++relativePos;
             while (relativePos < len && engine->atWordSeparator(relativePos))
@@ -482,6 +485,9 @@ bool QTextCursorPrivate::movePosition(QTextCursor::MoveOperation op, QTextCursor
             while (relativePos < len && !attributes[relativePos].whiteSpace && !engine->atWordSeparator(relativePos))
                 ++relativePos;
         }
+#else
+        Q_UNUSED(attributes);
+#endif
         newPosition = blockIt.position() + relativePos;
         break;
     }
diff --git a/src/gui/text/qtextengine.cpp b/src/gui/text/qtextengine.cpp
index eded3e3f33..dfa3a7cf17 100644
--- a/src/gui/text/qtextengine.cpp
+++ b/src/gui/text/qtextengine.cpp
@@ -2832,7 +2832,8 @@ bool QTextEngine::atWordSeparator(int position) const
     case '&':
     case '^':
     case '*':
-    case '\'':
+    // Patch: Make the apostrophe a non-separator for words.
+    //case '\'':
     case '"':
     case '`':
     case '~':
@@ -2845,6 +2846,74 @@ bool QTextEngine::atWordSeparator(int position) const
     return false;
 }
 
+// Patch: Improved apostrophe processing.
+// We should consider apostrophes as word separators when there is more than
+// one apostrophe in a row, or when the apostrophe is at the beginning or end
+// of the word.
+int QTextEngine::toEdge(int pos, int len, bool isRightDirection) {
+    const auto step = isRightDirection ? 1 : -1;
+    const auto next = isRightDirection ? 0 : -1;
+
+    QCharAttributes *attributes = const_cast<QCharAttributes *>(this->attributes());
+
+    const auto atApostrophe = [&](int position) {
+        return layoutData->string.at(position).unicode() == '\'';
+    };
+
+    const auto atSepOrApost = [&](int position) {
+        return atApostrophe(position) || atWordSeparator(position);
+    };
+
+    const auto inBounds = [&](int position) {
+        return isRightDirection
+            ? position < len
+            : position > 0;
+    };
+
+    const auto atSepOrSpace = [&](int position) {
+        return attributes[position].whiteSpace || atWordSeparator(position);
+    };
+
+    const auto isApostropheInWord = [&](int position) {
+        if (!atApostrophe(position)) {
+            return false;
+        }
+        auto p = position - 1;
+        if (p <= 0 || atSepOrSpace(p)) {
+            return false;
+        }
+        p = position + 1;
+        if (p >= len || atSepOrSpace(p)) {
+            return false;
+        }
+        return true;
+    };
+
+    auto counter = 0;
+    while (inBounds(pos) && atSepOrApost(pos + next)) {
+        counter++;
+        pos += step;
+    }
+    // If it's not the single apostrophe, then that's non-letter part of text.
+    if (counter > 1 || (counter == 1 && !isApostropheInWord(pos - step + next))) {
+        return pos;
+    }
+
+    bool isPrevApostrophe = false;
+    while (inBounds(pos) && !atSepOrSpace(pos + next)) {
+        bool isNextApostrophe = atApostrophe(pos + next);
+        if (isPrevApostrophe && isNextApostrophe) {
+            break;
+        }
+        pos += step;
+        isPrevApostrophe = isNextApostrophe;
+    }
+    if (isPrevApostrophe) {
+        pos += -step;
+    }
+    return pos;
+}
+
 void QTextEngine::setPreeditArea(int position, const QString &preeditText)
 {
     if (preeditText.isEmpty()) {
diff --git a/src/gui/text/qtextengine_p.h b/src/gui/text/qtextengine_p.h
index 59e332c64a..04c35316c8 100644
--- a/src/gui/text/qtextengine_p.h
+++ b/src/gui/text/qtextengine_p.h
@@ -586,6 +586,8 @@ private:
 
 public:
     bool atWordSeparator(int position) const;
+    // Patch: Improved apostrophe processing.
+    int toEdge(int pos, int len, bool isRightDirection);
 
     QString elidedText(Qt::TextElideMode mode, QFixed width, int flags = 0, int from = 0, int count = -1) const;
 
diff --git a/src/gui/text/qtextlayout.cpp b/src/gui/text/qtextlayout.cpp
index 486e04544a..6a00600688 100644
--- a/src/gui/text/qtextlayout.cpp
+++ b/src/gui/text/qtextlayout.cpp
@@ -661,6 +661,12 @@ int QTextLayout::nextCursorPosition(int oldPos, CursorMode mode) const
         while (oldPos < len && !attributes[oldPos].graphemeBoundary)
             oldPos++;
     } else {
+        // Patch: Skip to the end of the current word, not to the start of the next one.
+        while (oldPos < len && attributes[oldPos].whiteSpace)
+            oldPos++;
+        // Patch: Improved apostrophe processing.
+        oldPos = d->toEdge(oldPos, len, true);
+#if 0
         if (oldPos < len && d->atWordSeparator(oldPos)) {
             oldPos++;
             while (oldPos < len && d->atWordSeparator(oldPos))
@@ -671,6 +677,7 @@ int QTextLayout::nextCursorPosition(int oldPos, CursorMode mode) const
         }
         while (oldPos < len && attributes[oldPos].whiteSpace)
             oldPos++;
+#endif
     }
 
     return oldPos;
@@ -700,6 +707,9 @@ int QTextLayout::previousCursorPosition(int oldPos, CursorMode mode) const
         while (oldPos > 0 && attributes[oldPos - 1].whiteSpace)
             oldPos--;
 
+        // Patch: Improved apostrophe processing.
+        oldPos = d->toEdge(oldPos, len, false);
+#if 0
         if (oldPos && d->atWordSeparator(oldPos-1)) {
             oldPos--;
             while (oldPos && d->atWordSeparator(oldPos-1))
@@ -708,6 +718,7 @@ int QTextLayout::previousCursorPosition(int oldPos, CursorMode mode) const
             while (oldPos > 0 && !attributes[oldPos - 1].whiteSpace && !d->atWordSeparator(oldPos-1))
                 oldPos--;
         }
+#endif
     }
 
     return oldPos;
diff --git a/src/gui/text/windows/qwindowsdirectwritefontdatabase.cpp b/src/gui/text/windows/qwindowsdirectwritefontdatabase.cpp
index 6b4933cca7..eed71b6e94 100644
--- a/src/gui/text/windows/qwindowsdirectwritefontdatabase.cpp
+++ b/src/gui/text/windows/qwindowsdirectwritefontdatabase.cpp
@@ -107,8 +107,7 @@ void QWindowsDirectWriteFontDatabase::populateFamily(const QString &familyName)
             IDWriteFont *font;
             if (SUCCEEDED(matchingFonts->GetFont(j, &font))) {
                 IDWriteFont1 *font1 = nullptr;
-                if (!SUCCEEDED(font->QueryInterface(__uuidof(IDWriteFont1),
-                                                   reinterpret_cast<void **>(&font1)))) {
+                if (!SUCCEEDED(font->QueryInterface(IID_PPV_ARGS(&font1)))) {
                     qCWarning(lcQpaFonts) << "COM object does not support IDWriteFont1";
                     continue;
                 }
@@ -271,8 +270,7 @@ QStringList QWindowsDirectWriteFontDatabase::addApplicationFont(const QByteArray
 
     QStringList ret;
     IDWriteFontFace3 *face3 = nullptr;
-    if (SUCCEEDED(face->QueryInterface(__uuidof(IDWriteFontFace3),
-                                      reinterpret_cast<void **>(&face3)))) {
+    if (SUCCEEDED(face->QueryInterface(IID_PPV_ARGS(&face3)))) {
         QString defaultLocaleFamilyName;
         QString englishLocaleFamilyName;
 
diff --git a/src/gui/text/windows/qwindowsfontdatabase.cpp b/src/gui/text/windows/qwindowsfontdatabase.cpp
index 2de53be6a8..4e6ffa14f7 100644
--- a/src/gui/text/windows/qwindowsfontdatabase.cpp
+++ b/src/gui/text/windows/qwindowsfontdatabase.cpp
@@ -1188,8 +1188,7 @@ QFontEngine *QWindowsFontDatabase::createEngine(const QFontDef &request, const Q
                 bool isColorFont = false;
 #if QT_CONFIG(direct2d)
                 IDWriteFontFace2 *directWriteFontFace2 = nullptr;
-                if (SUCCEEDED(directWriteFontFace->QueryInterface(__uuidof(IDWriteFontFace2),
-                                                                  reinterpret_cast<void **>(&directWriteFontFace2)))) {
+                if (SUCCEEDED(directWriteFontFace->QueryInterface(IID_PPV_ARGS(&directWriteFontFace2)))) {
                     if (directWriteFontFace2->IsColorFont())
                         isColorFont = directWriteFontFace2->GetPaletteEntryCount() > 0;
 
diff --git a/src/gui/text/windows/qwindowsfontdatabasebase.cpp b/src/gui/text/windows/qwindowsfontdatabasebase.cpp
index f45678c65c..6f10517714 100644
--- a/src/gui/text/windows/qwindowsfontdatabasebase.cpp
+++ b/src/gui/text/windows/qwindowsfontdatabasebase.cpp
@@ -6,6 +6,7 @@
 
 #include <QtCore/QThreadStorage>
 #include <QtCore/QtEndian>
+#include <QtCore/private/qsystemlibrary_p.h>
 
 #if QT_CONFIG(directwrite)
 #  if QT_CONFIG(directwrite3)
@@ -546,17 +547,23 @@ bool QWindowsFontDatabaseBase::init(QSharedPointer<QWindowsFontEngineData> d)
 #if QT_CONFIG(directwrite) && QT_CONFIG(direct2d)
 void QWindowsFontDatabaseBase::createDirectWriteFactory(IDWriteFactory **factory)
 {
+    static const auto pDWriteCreateFactory =
+        reinterpret_cast<decltype(&::DWriteCreateFactory)>(
+            QSystemLibrary::resolve(u"dwrite"_s, "DWriteCreateFactory"));
+    if (!pDWriteCreateFactory)
+        return;
+
     *factory = nullptr;
     IUnknown *result = nullptr;
 
 #  if QT_CONFIG(directwrite3)
-    DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory3), &result);
+    pDWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory3), &result);
 #  endif
     if (result == nullptr)
-        DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory2), &result);
+        pDWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory2), &result);
 
     if (result == nullptr) {
-        if (FAILED(DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory), &result))) {
+        if (FAILED(pDWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory), &result))) {
             qErrnoWarning("DWriteCreateFactory failed");
             return;
         }
@@ -685,7 +692,13 @@ QFont QWindowsFontDatabaseBase::systemDefaultFont()
     // Qt 6: Obtain default GUI font (typically "Segoe UI, 9pt", see QTBUG-58610)
     NONCLIENTMETRICS ncm = {};
     ncm.cbSize = sizeof(ncm);
-    SystemParametersInfoForDpi(SPI_GETNONCLIENTMETRICS, ncm.cbSize, &ncm, 0, defaultVerticalDPI());
+    static const auto pSystemParametersInfoForDpi =
+        reinterpret_cast<decltype(&::SystemParametersInfoForDpi)>(
+            QSystemLibrary::resolve(u"user32"_s, "SystemParametersInfoForDpi"));
+    if (pSystemParametersInfoForDpi)
+        pSystemParametersInfoForDpi(SPI_GETNONCLIENTMETRICS, ncm.cbSize, &ncm, 0, defaultVerticalDPI());
+    else
+        SystemParametersInfo(SPI_GETNONCLIENTMETRICS, ncm.cbSize, &ncm, 0);
     const QFont systemFont = QWindowsFontDatabase::LOGFONT_to_QFont(ncm.lfMessageFont);
     qCDebug(lcQpaFonts) << __FUNCTION__ << systemFont;
     return systemFont;
diff --git a/src/gui/text/windows/qwindowsfontenginedirectwrite.cpp b/src/gui/text/windows/qwindowsfontenginedirectwrite.cpp
index 14dd064c33..026211c0a3 100644
--- a/src/gui/text/windows/qwindowsfontenginedirectwrite.cpp
+++ b/src/gui/text/windows/qwindowsfontenginedirectwrite.cpp
@@ -671,8 +671,7 @@ bool QWindowsFontEngineDirectWrite::supportsHorizontalSubPixelPositions() const
 QFontEngine::Properties QWindowsFontEngineDirectWrite::properties() const
 {
     IDWriteFontFace2 *directWriteFontFace2;
-    if (SUCCEEDED(m_directWriteFontFace->QueryInterface(__uuidof(IDWriteFontFace2),
-                                                        reinterpret_cast<void **>(&directWriteFontFace2)))) {
+    if (SUCCEEDED(m_directWriteFontFace->QueryInterface(IID_PPV_ARGS(&directWriteFontFace2)))) {
         DWRITE_FONT_METRICS1 metrics;
         directWriteFontFace2->GetMetrics(&metrics);
 
@@ -739,8 +738,7 @@ QImage QWindowsFontEngineDirectWrite::imageForGlyph(glyph_t t,
             : DWRITE_GRID_FIT_MODE_DEFAULT;
 
     IDWriteFactory2 *factory2 = nullptr;
-    HRESULT hr = m_fontEngineData->directWriteFactory->QueryInterface(__uuidof(IDWriteFactory2),
-                                                                      reinterpret_cast<void **>(&factory2));
+    HRESULT hr = m_fontEngineData->directWriteFactory->QueryInterface(IID_PPV_ARGS(&factory2));
     IDWriteGlyphRunAnalysis *glyphAnalysis = NULL;
     if (!SUCCEEDED(hr)) {
         qErrnoWarning(hr, "%s: Failed to query IDWriteFactory2 interface.", __FUNCTION__);
@@ -1063,8 +1061,7 @@ glyph_metrics_t QWindowsFontEngineDirectWrite::alphaMapBoundingBox(glyph_t glyph
             : DWRITE_GRID_FIT_MODE_DEFAULT;
 
     IDWriteFactory2 *factory2 = nullptr;
-    HRESULT hr = m_fontEngineData->directWriteFactory->QueryInterface(__uuidof(IDWriteFactory2),
-                                                                      reinterpret_cast<void **>(&factory2));
+    HRESULT hr = m_fontEngineData->directWriteFactory->QueryInterface(IID_PPV_ARGS(&factory2));
 
     IDWriteGlyphRunAnalysis *glyphAnalysis = NULL;
     if (SUCCEEDED(hr)) {
diff --git a/src/network/socket/qnativesocketengine_win.cpp b/src/network/socket/qnativesocketengine_win.cpp
index d578e5230f..98c72b8067 100644
--- a/src/network/socket/qnativesocketengine_win.cpp
+++ b/src/network/socket/qnativesocketengine_win.cpp
@@ -274,12 +274,31 @@ bool QNativeSocketEnginePrivate::createNewSocket(QAbstractSocket::SocketType soc
     // MSDN KB179942 states that on winnt 4 WSA_FLAG_OVERLAPPED is needed if socket is to be non
     // blocking and recommends always doing it for cross-windows-version compatibility.
 
-    // WSA_FLAG_NO_HANDLE_INHERIT is atomic (like linux O_CLOEXEC)
+    // WSA_FLAG_NO_HANDLE_INHERIT is atomic (like linux O_CLOEXEC), but requires windows 7 SP 1 or later
+    // SetHandleInformation is supported since W2K but isn't atomic
 #ifndef WSA_FLAG_NO_HANDLE_INHERIT
 #define WSA_FLAG_NO_HANDLE_INHERIT 0x80
 #endif
 
     SOCKET socket = ::WSASocket(protocol, type, 0, NULL, 0, WSA_FLAG_NO_HANDLE_INHERIT | WSA_FLAG_OVERLAPPED);
+    // previous call fails if the windows 7 service pack 1 or hot fix isn't installed.
+
+    // Try the old API if the new one failed on Windows 7
+    if (socket == INVALID_SOCKET && !QOperatingSystemVersion::isWin8OrGreater()) {
+        socket = ::WSASocket(protocol, type, 0, NULL, 0, WSA_FLAG_OVERLAPPED);
+#ifdef HANDLE_FLAG_INHERIT
+        if (socket != INVALID_SOCKET) {
+            // make non inheritable the old way
+            BOOL handleFlags = SetHandleInformation(reinterpret_cast<HANDLE>(socket), HANDLE_FLAG_INHERIT, 0);
+#  ifdef QNATIVESOCKETENGINE_DEBUG
+            qDebug() << "QNativeSocketEnginePrivate::createNewSocket - set inheritable" << handleFlags;
+#  else // !QNATIVESOCKETENGINE_DEBUG
+            Q_UNUSED(handleFlags);
+#  endif // QNATIVESOCKETENGINE_DEBUG
+        }
+#endif // HANDLE_FLAG_INHERIT
+    }
+
     if (socket == INVALID_SOCKET) {
         int err = WSAGetLastError();
         WS_ERROR_DEBUG(err);
diff --git a/src/openglwidgets/qopenglwidget.cpp b/src/openglwidgets/qopenglwidget.cpp
index ad2b461f7e..d921fb803a 100644
--- a/src/openglwidgets/qopenglwidget.cpp
+++ b/src/openglwidgets/qopenglwidget.cpp
@@ -622,12 +622,13 @@ void QOpenGLWidgetPaintDevice::ensureActiveTarget()
     if (!wd->initialized)
         return;
 
-    if (QOpenGLContext::currentContext() != wd->context)
+    if (QOpenGLContext::currentContext() != wd->context) {
         d->w->makeCurrent();
-    else
+        if (!wd->initialized)
+            return; // Trying to fix a crash on context loss.
+    } else
         wd->fbos[wd->currentTargetBuffer]->bind();
 
-
     if (!wd->inPaintGL)
         QOpenGLContextPrivate::get(wd->context)->defaultFboRedirect = wd->fbos[wd->currentTargetBuffer]->handle();
 
@@ -720,7 +721,11 @@ void QOpenGLWidgetPrivate::recreateFbos()
 
     emit q->aboutToResize();
 
-    context->makeCurrent(surface);
+    if (!context->makeCurrent(surface)) {
+        // Trying to fix a crash on context loss.
+        reset();
+        return;
+    }
 
     destroyFbos();
 
@@ -802,6 +807,9 @@ void QOpenGLWidgetPrivate::beginCompose()
     if (flushPending) {
         flushPending = false;
         q->makeCurrent();
+        if (!initialized) {
+            return;
+        }
         static_cast<QOpenGLExtensions *>(context->functions())->flushShared();
     }
     hasBeenComposed = true;
@@ -857,6 +865,7 @@ void QOpenGLWidgetPrivate::initialize()
     }
     if (Q_UNLIKELY(!context->create())) {
         qWarning("QOpenGLWidget: Failed to create context");
+        reset();
         return;
     }
 
@@ -867,6 +876,7 @@ void QOpenGLWidgetPrivate::initialize()
 
     if (Q_UNLIKELY(!context->makeCurrent(surface))) {
         qWarning("QOpenGLWidget: Failed to make context current");
+        reset();
         return;
     }
 
@@ -907,6 +917,9 @@ void QOpenGLWidgetPrivate::resolveSamplesForBuffer(QOpenGLWidget::TargetBuffer t
     Q_Q(QOpenGLWidget);
     if (resolvedFbos[targetBuffer]) {
         q->makeCurrent(targetBuffer);
+        if (!initialized) {
+            return;
+        }
         QRect rect(QPoint(0, 0), fbos[targetBuffer]->size());
         QOpenGLFramebufferObject::blitFramebuffer(resolvedFbos[targetBuffer], rect, fbos[targetBuffer], rect);
         flushPending = true;
@@ -921,6 +934,8 @@ void QOpenGLWidgetPrivate::render()
         return;
 
     setCurrentTargetBuffer(QOpenGLWidget::LeftBuffer);
+    if (!initialized)
+        return; // Trying to fix a crash on context loss.
 
     QOpenGLContext *ctx = QOpenGLContext::currentContext();
     if (!ctx) {
@@ -1032,12 +1047,20 @@ QImage QOpenGLWidgetPrivate::grabFramebuffer(QOpenGLWidget::TargetBuffer targetB
     if (!fbos[targetBuffer]) // could be completely offscreen, without ever getting a resize event
         recreateFbos();
 
+    if (!fbos[targetBuffer])
+        return QImage(); // Trying to fix a crash on context loss.
+
     if (!inPaintGL)
         render();
 
     setCurrentTargetBuffer(targetBuffer);
+    if (!initialized)
+        return QImage(); // Trying to fix a crash on context loss.
+
     if (resolvedFbos[targetBuffer]) {
         resolveSamplesForBuffer(targetBuffer);
+        if (!initialized)
+            return QImage(); // Trying to fix a crash on context loss.
         resolvedFbos[targetBuffer]->bind();
     }
 
@@ -1272,7 +1295,12 @@ void QOpenGLWidget::makeCurrent()
     if (!d->initialized)
         return;
 
-    d->context->makeCurrent(d->surface);
+    if (!d->context->makeCurrent(d->surface)) {
+        // Trying to fix a crash on context loss.
+        // If makeCurrent() failed, that means we're not initialized any more.
+        d->initialized = false; // This prevents infinite recursion to makeCurrent().
+        d->reset();
+    }
 
     if (d->fbos[d->currentTargetBuffer]) // there may not be one if we are in reset()
         d->fbos[d->currentTargetBuffer]->bind();
@@ -1460,6 +1488,9 @@ void QOpenGLWidget::resizeEvent(QResizeEvent *e)
         return;
 
     d->recreateFbos();
+    if (!d->fbos[d->currentTargetBuffer])
+        return; // Trying to fix a crash on context loss.
+
     // Make sure our own context is current before invoking user overrides. If
     // the fbo was recreated then there's a chance something else is current now.
     makeCurrent();
diff --git a/src/plugins/imageformats/jpeg/qjpeghandler.cpp b/src/plugins/imageformats/jpeg/qjpeghandler.cpp
index 0d72ba01d0..1ac875666a 100644
--- a/src/plugins/imageformats/jpeg/qjpeghandler.cpp
+++ b/src/plugins/imageformats/jpeg/qjpeghandler.cpp
@@ -545,6 +545,9 @@ static bool do_write_jpeg_image(struct jpeg_compress_struct &cinfo,
 
         jpeg_set_defaults(&cinfo);
 
+        cinfo.comp_info[0].v_samp_factor = 1;
+        cinfo.comp_info[0].h_samp_factor = 1;
+
         qreal diffInch = qAbs(image.dotsPerMeterX()*2.54/100. - qRound(image.dotsPerMeterX()*2.54/100.))
                          + qAbs(image.dotsPerMeterY()*2.54/100. - qRound(image.dotsPerMeterY()*2.54/100.));
         qreal diffCm = (qAbs(image.dotsPerMeterX()/100. - qRound(image.dotsPerMeterX()/100.))
diff --git a/src/plugins/networkinformation/networklistmanager/qnetworklistmanagerevents.cpp b/src/plugins/networkinformation/networklistmanager/qnetworklistmanagerevents.cpp
index 5b0a91df3e..ec2207f833 100644
--- a/src/plugins/networkinformation/networklistmanager/qnetworklistmanagerevents.cpp
+++ b/src/plugins/networkinformation/networklistmanager/qnetworklistmanagerevents.cpp
@@ -5,6 +5,7 @@
 #include <QtCore/private/qsystemerror_p.h>
 
 #include <QtCore/qpointer.h>
+#include <QtCore/qoperatingsystemversion.h>
 
 #include <mutex>
 
@@ -100,20 +101,22 @@ bool QNetworkListManagerEvents::start()
     }
 
 #if QT_CONFIG(cpp_winrt)
-    using namespace winrt::Windows::Networking::Connectivity;
-    using winrt::Windows::Foundation::IInspectable;
-    // Register for changes in the network and store a token to unregister later:
-    token = NetworkInformation::NetworkStatusChanged(
-            [owner = QPointer(this)](const IInspectable sender) {
-                Q_UNUSED(sender);
-                if (owner) {
-                    std::scoped_lock locker(owner->winrtLock);
-                    if (owner->token)
-                        owner->emitWinRTUpdates();
-                }
-            });
-    // Emit initial state
-    emitWinRTUpdates();
+    if (QOperatingSystemVersion::isWin10OrGreater()) {
+        using namespace winrt::Windows::Networking::Connectivity;
+        using winrt::Windows::Foundation::IInspectable;
+        // Register for changes in the network and store a token to unregister later:
+        token = NetworkInformation::NetworkStatusChanged(
+                [owner = QPointer(this)](const IInspectable sender) {
+                    Q_UNUSED(sender);
+                    if (owner) {
+                        std::scoped_lock locker(owner->winrtLock);
+                        if (owner->token)
+                            owner->emitWinRTUpdates();
+                    }
+                });
+        // Emit initial state
+        emitWinRTUpdates();
+    }
 #endif
 
     return true;
@@ -132,13 +135,15 @@ void QNetworkListManagerEvents::stop()
     // Even if we fail we should still try to unregister from winrt events:
 
 #if QT_CONFIG(cpp_winrt)
-    // Try to synchronize unregistering with potentially in-progress callbacks
-    std::scoped_lock locker(winrtLock);
-    if (token) {
-        using namespace winrt::Windows::Networking::Connectivity;
-        // Pass the token we stored earlier to unregister:
-        NetworkInformation::NetworkStatusChanged(token);
-        token = {};
+    if (QOperatingSystemVersion::isWin10OrGreater()) {
+        // Try to synchronize unregistering with potentially in-progress callbacks
+        std::scoped_lock locker(winrtLock);
+        if (token) {
+            using namespace winrt::Windows::Networking::Connectivity;
+            // Pass the token we stored earlier to unregister:
+            NetworkInformation::NetworkStatusChanged(token);
+            token = {};
+        }
     }
 #endif
 }
@@ -189,6 +194,9 @@ using namespace winrt::Windows::Networking::Connectivity;
 [[nodiscard]]
 QNetworkInformation::TransportMedium getTransportMedium(const ConnectionProfile &profile)
 {
+    if (!QOperatingSystemVersion::isWin10OrGreater())
+        return QNetworkInformation::TransportMedium::Unknown;
+
     if (profile.IsWwanConnectionProfile())
         return QNetworkInformation::TransportMedium::Cellular;
     if (profile.IsWlanConnectionProfile())
@@ -222,6 +230,8 @@ QNetworkInformation::TransportMedium getTransportMedium(const ConnectionProfile
 
 [[nodiscard]] bool getMetered(const ConnectionProfile &profile)
 {
+    if (!QOperatingSystemVersion::isWin10OrGreater())
+        return false;
     ConnectionCost cost(nullptr);
     try {
         cost = profile.GetConnectionCost();
@@ -237,6 +247,8 @@ QNetworkInformation::TransportMedium getTransportMedium(const ConnectionProfile
 
 void QNetworkListManagerEvents::emitWinRTUpdates()
 {
+    if (!QOperatingSystemVersion::isWin10OrGreater())
+        return;
     using namespace winrt::Windows::Networking::Connectivity;
     ConnectionProfile profile = nullptr;
     try {
diff --git a/src/plugins/platforms/CMakeLists.txt b/src/plugins/platforms/CMakeLists.txt
index bcf29dedd1..4095e3f023 100644
--- a/src/plugins/platforms/CMakeLists.txt
+++ b/src/plugins/platforms/CMakeLists.txt
@@ -4,12 +4,6 @@
 if(ANDROID)
     add_subdirectory(android)
 endif()
-if(NOT ANDROID AND NOT WASM)
-    add_subdirectory(minimal)
-endif()
-if(QT_FEATURE_freetype AND NOT ANDROID AND NOT WASM)
-    add_subdirectory(offscreen)
-endif()
 if(QT_FEATURE_xcb)
     add_subdirectory(xcb)
 endif()
@@ -22,9 +16,6 @@ endif()
 if(WIN32)
     add_subdirectory(windows)
 endif()
-if(QT_FEATURE_direct2d1_1 AND QT_FEATURE_directwrite)
-    add_subdirectory(direct2d)
-endif()
 if(QNX)
     add_subdirectory(qnx)
 endif()
diff --git a/src/plugins/platforms/windows/CMakeLists.txt b/src/plugins/platforms/windows/CMakeLists.txt
index 4425e78b30..7b51026bd3 100644
--- a/src/plugins/platforms/windows/CMakeLists.txt
+++ b/src/plugins/platforms/windows/CMakeLists.txt
@@ -49,7 +49,6 @@ qt_internal_add_plugin(QWindowsIntegrationPlugin
         Qt::Gui
         Qt::GuiPrivate
         advapi32
-        dwmapi
         gdi32
         imm32
         ole32
@@ -60,10 +59,7 @@ qt_internal_add_plugin(QWindowsIntegrationPlugin
         winmm
         winspool
         wtsapi32
-        shcore
         comdlg32
-        d3d9
-        runtimeobject
 )
 
 # Duplicated symbols
@@ -193,6 +189,8 @@ qt_internal_extend_target(QWindowsIntegrationPlugin CONDITION QT_FEATURE_accessi
         uiautomation/qwindowsuiautils.cpp uiautomation/qwindowsuiautils.h
         uiautomation/qwindowsuiavalueprovider.cpp uiautomation/qwindowsuiavalueprovider.h
         uiautomation/qwindowsuiawindowprovider.cpp uiautomation/qwindowsuiawindowprovider.h
+    LIBRARIES
+        uiautomationcore
 )
 
 qt_internal_extend_target(QWindowsIntegrationPlugin CONDITION MINGW AND QT_FEATURE_accessibility
diff --git a/src/plugins/platforms/windows/qwin10helpers.cpp b/src/plugins/platforms/windows/qwin10helpers.cpp
index 026e81cb0c..e17d2bc20d 100644
--- a/src/plugins/platforms/windows/qwin10helpers.cpp
+++ b/src/plugins/platforms/windows/qwin10helpers.cpp
@@ -4,6 +4,8 @@
 #include "qwin10helpers.h"
 
 #include <QtCore/qdebug.h>
+#include <QtCore/qoperatingsystemversion.h>
+#include <QtCore/private/qsystemlibrary_p.h>
 #include <winstring.h>
 #include <roapi.h>
 
@@ -60,29 +62,62 @@ public:
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
+struct QComBaseApi
+{
+    decltype(&::RoGetActivationFactory) pRoGetActivationFactory = nullptr;
+    decltype(&::WindowsCreateStringReference) pWindowsCreateStringReference = nullptr;
+
+    static QComBaseApi *instance()
+    {
+        static QComBaseApi api;
+        return &api;
+    }
+
+private:
+    Q_DISABLE_COPY_MOVE(QComBaseApi)
+
+    explicit QComBaseApi()
+    {
+        QSystemLibrary comBase(u"combase"_s);
+        pRoGetActivationFactory = reinterpret_cast<decltype(pRoGetActivationFactory)>(comBase.resolve("RoGetActivationFactory"));
+        pWindowsCreateStringReference = reinterpret_cast<decltype(pWindowsCreateStringReference)>(comBase.resolve("WindowsCreateStringReference"));
+    }
+
+    ~QComBaseApi() = default;
+};
+
 // Return tablet mode, note: Does not work for GetDesktopWindow().
 bool qt_windowsIsTabletMode(HWND hwnd)
 {
+    if (!QComBaseApi::instance()->pRoGetActivationFactory ||
+        !QComBaseApi::instance()->pWindowsCreateStringReference) {
+        return false;
+    }
+
     bool result = false;
 
     const wchar_t uiViewSettingsId[] = L"Windows.UI.ViewManagement.UIViewSettings";
     HSTRING_HEADER uiViewSettingsIdRefHeader;
     HSTRING uiViewSettingsIdHs = nullptr;
     const auto uiViewSettingsIdLen = UINT32(sizeof(uiViewSettingsId) / sizeof(uiViewSettingsId[0]) - 1);
-    if (FAILED(WindowsCreateStringReference(uiViewSettingsId, uiViewSettingsIdLen, &uiViewSettingsIdRefHeader, &uiViewSettingsIdHs)))
+    if (FAILED(QComBaseApi::instance()->pWindowsCreateStringReference(uiViewSettingsId, uiViewSettingsIdLen, &uiViewSettingsIdRefHeader, &uiViewSettingsIdHs)))
         return false;
 
     IUIViewSettingsInterop *uiViewSettingsInterop = nullptr;
     // __uuidof(IUIViewSettingsInterop);
-    const GUID uiViewSettingsInteropRefId = {0x3694dbf9, 0x8f68, 0x44be,{0x8f, 0xf5, 0x19, 0x5c, 0x98, 0xed, 0xe8, 0xa6}};
+    static constexpr const GUID uiViewSettingsInteropRefId =
+        {0x3694dbf9, 0x8f68, 0x44be,{0x8f, 0xf5, 0x19, 0x5c, 0x98, 0xed, 0xe8, 0xa6}};
 
-    HRESULT hr = RoGetActivationFactory(uiViewSettingsIdHs, uiViewSettingsInteropRefId,
+    HRESULT hr = QComBaseApi::instance()->pRoGetActivationFactory(uiViewSettingsIdHs, uiViewSettingsInteropRefId,
                                                    reinterpret_cast<void **>(&uiViewSettingsInterop));
     if (FAILED(hr))
         return false;
 
     //  __uuidof(ABI::Windows::UI::ViewManagement::IUIViewSettings);
-    const GUID uiViewSettingsRefId = {0xc63657f6, 0x8850, 0x470d,{0x88, 0xf8, 0x45, 0x5e, 0x16, 0xea, 0x2c, 0x26}};
+    static constexpr const GUID uiViewSettingsRefId =
+        {0xc63657f6, 0x8850, 0x470d,{0x88, 0xf8, 0x45, 0x5e, 0x16, 0xea, 0x2c, 0x26}};
     ABI::Windows::UI::ViewManagement::IUIViewSettings *viewSettings = nullptr;
     hr = uiViewSettingsInterop->GetForWindow(hwnd, uiViewSettingsRefId,
                                              reinterpret_cast<void **>(&viewSettings));
diff --git a/src/plugins/platforms/windows/qwindowscontext.cpp b/src/plugins/platforms/windows/qwindowscontext.cpp
index e8914fb6a2..41d45ed41d 100644
--- a/src/plugins/platforms/windows/qwindowscontext.cpp
+++ b/src/plugins/platforms/windows/qwindowscontext.cpp
@@ -118,26 +118,6 @@ static inline bool sessionManagerInteractionBlocked()
 static inline bool sessionManagerInteractionBlocked() { return false; }
 #endif
 
-static inline int windowDpiAwareness(HWND hwnd)
-{
-    return static_cast<int>(GetAwarenessFromDpiAwarenessContext(GetWindowDpiAwarenessContext(hwnd)));
-}
-
-// Note: This only works within WM_NCCREATE
-static bool enableNonClientDpiScaling(HWND hwnd)
-{
-    bool result = false;
-    if (windowDpiAwareness(hwnd) == 2) {
-        result = EnableNonClientDpiScaling(hwnd) != FALSE;
-        if (!result) {
-            const DWORD errorCode = GetLastError();
-            qErrnoWarning(int(errorCode), "EnableNonClientDpiScaling() failed for HWND %p (%lu)",
-                          hwnd, errorCode);
-        }
-    }
-    return result;
-}
-
 QWindowsContext *QWindowsContext::m_instance = nullptr;
 
 /*!
@@ -224,7 +204,8 @@ QWindowsContext::~QWindowsContext()
     unregisterWindowClasses();
     if (d->m_oleInitializeResult == S_OK || d->m_oleInitializeResult == S_FALSE) {
 #ifdef QT_USE_FACTORY_CACHE_REGISTRATION
-        detail::QWinRTFactoryCacheRegistration::clearAllCaches();
+        if (QOperatingSystemVersion::isWin10OrGreater())
+            detail::QWinRTFactoryCacheRegistration::clearAllCaches();
 #endif
         OleUninitialize();
     }
@@ -299,6 +280,9 @@ bool QWindowsContext::initPointer(unsigned integrationOptions)
     if (integrationOptions & QWindowsIntegration::DontUseWMPointer)
         return false;
 
+    if (!QWindowsApi::instance()->supportsPointerApi())
+        return false;
+
     d->m_systemInfo |= QWindowsContext::SI_SupportsPointer;
     return true;
 }
@@ -366,49 +350,207 @@ void QWindowsContext::setDetectAltGrModifier(bool a)
     d->m_keyMapper.setDetectAltGrModifier(a);
 }
 
-int QWindowsContext::processDpiAwareness()
+[[nodiscard]] static inline QtWindows::DpiAwareness
+    dpiAwarenessContextToQtDpiAwareness(DPI_AWARENESS_CONTEXT context)
 {
-    PROCESS_DPI_AWARENESS result;
-    if (SUCCEEDED(GetProcessDpiAwareness(nullptr, &result))) {
-        return static_cast<int>(result);
+    if (!QWindowsApi::instance()->pIsValidDpiAwarenessContext
+            || !QWindowsApi::instance()->pAreDpiAwarenessContextsEqual) {
+        return QtWindows::DpiAwareness::Invalid;
     }
-    return -1;
+    // IsValidDpiAwarenessContext() will handle the NULL pointer case.
+    if (!QWindowsApi::instance()->pIsValidDpiAwarenessContext(context))
+        return QtWindows::DpiAwareness::Invalid;
+    if (QWindowsApi::instance()->pAreDpiAwarenessContextsEqual(
+                context, DPI_AWARENESS_CONTEXT_UNAWARE_GDISCALED))
+        return QtWindows::DpiAwareness::Unaware_GdiScaled;
+    if (QWindowsApi::instance()->pAreDpiAwarenessContextsEqual(
+                context, DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2))
+        return QtWindows::DpiAwareness::PerMonitorVersion2;
+    if (QWindowsApi::instance()->pAreDpiAwarenessContextsEqual(
+                context, DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE))
+        return QtWindows::DpiAwareness::PerMonitor;
+    if (QWindowsApi::instance()->pAreDpiAwarenessContextsEqual(
+                context, DPI_AWARENESS_CONTEXT_SYSTEM_AWARE))
+        return QtWindows::DpiAwareness::System;
+    if (QWindowsApi::instance()->pAreDpiAwarenessContextsEqual(
+                context, DPI_AWARENESS_CONTEXT_UNAWARE))
+        return QtWindows::DpiAwareness::Unaware;
+    return QtWindows::DpiAwareness::Invalid;
+}
+
+QtWindows::DpiAwareness QWindowsContext::windowDpiAwareness(HWND hwnd)
+{
+    if (!hwnd)
+        return QtWindows::DpiAwareness::Invalid;
+    if (QWindowsApi::instance()->pGetWindowDpiAwarenessContext) {
+        const auto context = QWindowsApi::instance()->pGetWindowDpiAwarenessContext(hwnd);
+        return dpiAwarenessContextToQtDpiAwareness(context);
+    }
+    qCWarning(lcQpaWindow) << "Current platform doesn't support querying DPI awareness "
+                              "mode for a specific window, using current process's DPI "
+                              "awareness mode instead.";
+    return processDpiAwareness();
+}
+
+[[nodiscard]] static inline QtWindows::DpiAwareness
+    processDpiAwarenessToQtDpiAwareness(PROCESS_DPI_AWARENESS pda)
+{
+    switch (pda) {
+    case PROCESS_DPI_UNAWARE:
+        return QtWindows::DpiAwareness::Unaware;
+    case PROCESS_SYSTEM_DPI_AWARE:
+        return QtWindows::DpiAwareness::System;
+    case PROCESS_PER_MONITOR_DPI_AWARE:
+        return QtWindows::DpiAwareness::PerMonitor;
+    }
+    return QtWindows::DpiAwareness::Invalid;
 }
 
-void QWindowsContext::setProcessDpiAwareness(QtWindows::ProcessDpiAwareness dpiAwareness)
+QtWindows::DpiAwareness QWindowsContext::processDpiAwareness()
 {
-    qCDebug(lcQpaWindow) << __FUNCTION__ << dpiAwareness;
-    if (processDpiAwareness() == int(dpiAwareness))
-        return;
+    // Although we have GetDpiAwarenessContextForProcess(), however,
+    // it's only available on Win10 1903+, which is a little higher
+    // than Qt's minimum supported version (1809), so we can't use it.
+    // Luckily, MS docs said GetThreadDpiAwarenessContext() will also
+    // return the default DPI_AWARENESS_CONTEXT for the process if
+    // SetThreadDpiAwarenessContext() was never called. So we can use
+    // it as an equivalent.
+    if (QWindowsApi::instance()->pGetThreadDpiAwarenessContext) {
+        const auto context = QWindowsApi::instance()->pGetThreadDpiAwarenessContext();
+        return dpiAwarenessContextToQtDpiAwareness(context);
+    }
+    if (QWindowsApi::instance()->pGetProcessDpiAwareness) {
+        PROCESS_DPI_AWARENESS pda = PROCESS_DPI_UNAWARE;
+        const HRESULT hr = QWindowsApi::instance()->pGetProcessDpiAwareness(nullptr, &pda);
+        if (SUCCEEDED(hr)) {
+            return processDpiAwarenessToQtDpiAwareness(pda);
+        } else {
+            qCWarning(lcQpaWindow).nospace().noquote()
+                    << "GetProcessDpiAwareness() failed: "
+                    << QSystemError::windowsComString(hr);
+        }
+    }
+    if (IsProcessDPIAware()) {
+        return QtWindows::DpiAwareness::System;
+    }
+    return QtWindows::DpiAwareness::Unaware;
+}
+
+[[nodiscard]] static inline DPI_AWARENESS_CONTEXT
+    qtDpiAwarenessToDpiAwarenessContext(QtWindows::DpiAwareness dpiAwareness)
+{
+    switch (dpiAwareness) {
+    case QtWindows::DpiAwareness::Invalid:
+        return nullptr;
+    case QtWindows::DpiAwareness::Unaware:
+        return DPI_AWARENESS_CONTEXT_UNAWARE;
+    case QtWindows::DpiAwareness::System:
+        return DPI_AWARENESS_CONTEXT_SYSTEM_AWARE;
+    case QtWindows::DpiAwareness::PerMonitor:
+        return DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE;
+    case QtWindows::DpiAwareness::PerMonitorVersion2:
+        return DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2;
+    case QtWindows::DpiAwareness::Unaware_GdiScaled:
+        return DPI_AWARENESS_CONTEXT_UNAWARE_GDISCALED;
+    }
+    return nullptr;
+}
+
+#ifndef QT_NO_DEBUG_STREAM
+QDebug operator<<(QDebug d, QtWindows::DpiAwareness dpiAwareness)
+{
+    const QDebugStateSaver saver(d);
+    QString message = u"QtWindows::DpiAwareness::"_s;
+    switch (dpiAwareness) {
+    case QtWindows::DpiAwareness::Invalid:
+        message += u"Invalid"_s;
+        break;
+    case QtWindows::DpiAwareness::Unaware:
+        message += u"Unaware"_s;
+        break;
+    case QtWindows::DpiAwareness::System:
+        message += u"System"_s;
+        break;
+    case QtWindows::DpiAwareness::PerMonitor:
+        message += u"PerMonitor"_s;
+        break;
+    case QtWindows::DpiAwareness::PerMonitorVersion2:
+        message += u"PerMonitorVersion2"_s;
+        break;
+    case QtWindows::DpiAwareness::Unaware_GdiScaled:
+        message += u"Unaware_GdiScaled"_s;
+        break;
+    }
+    d.nospace().noquote() << message;
+    return d;
+}
+#endif
 
-    const HRESULT hr = SetProcessDpiAwareness(static_cast<PROCESS_DPI_AWARENESS>(dpiAwareness));
-    if (FAILED(hr)) {
-        qCWarning(lcQpaWindow).noquote().nospace() << "SetProcessDpiAwareness("
-            << dpiAwareness << ") failed: " << QSystemError::windowsComString(hr) << ", using "
-            << QWindowsContext::processDpiAwareness() << "\nQt's fallback DPI awareness is "
-            << "PROCESS_DPI_AWARENESS. If you know what you are doing consider an override in qt.conf";
+[[nodiscard]] static inline PROCESS_DPI_AWARENESS
+    qtDpiAwarenessToProcessDpiAwareness(QtWindows::DpiAwareness awareness)
+{
+    switch (awareness) {
+    case QtWindows::DpiAwareness::Invalid:
+        return PROCESS_DPI_AWARENESS(-1);
+    case QtWindows::DpiAwareness::Unaware:
+    case QtWindows::DpiAwareness::Unaware_GdiScaled:
+        return PROCESS_DPI_UNAWARE;
+    case QtWindows::DpiAwareness::System:
+        return PROCESS_SYSTEM_DPI_AWARE;
+    case QtWindows::DpiAwareness::PerMonitor:
+    case QtWindows::DpiAwareness::PerMonitorVersion2:
+        return PROCESS_PER_MONITOR_DPI_AWARE;
     }
+    return PROCESS_DPI_AWARENESS(-1);
 }
 
-bool QWindowsContext::setProcessDpiV2Awareness()
+bool QWindowsContext::setProcessDpiAwareness(QtWindows::DpiAwareness dpiAwareness)
 {
-    qCDebug(lcQpaWindow) << __FUNCTION__;
-    auto dpiContext = GetThreadDpiAwarenessContext();
-    if (AreDpiAwarenessContextsEqual(dpiContext, DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2))
+    qCDebug(lcQpaWindow) << __FUNCTION__ << dpiAwareness;
+    if (processDpiAwareness() == dpiAwareness)
         return true;
-
-    const BOOL ok = SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2);
-    if (!ok) {
-        const DWORD dwError = GetLastError();
-        qCWarning(lcQpaWindow).noquote().nospace()
-            << "SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2) failed: "
-            << QSystemError::windowsComString(HRESULT(dwError)) << "\nQt's default DPI awareness "
-            << "context is DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2. If you know what you "
-            << "are doing you can overwrite this default using qt.conf "
-            << "(https://doc.qt.io/qt-6/highdpi.html#configuring-windows)";
+    if (QWindowsApi::instance()->pIsValidDpiAwarenessContext
+            && QWindowsApi::instance()->pSetProcessDpiAwarenessContext) {
+        const auto context = qtDpiAwarenessToDpiAwarenessContext(dpiAwareness);
+        if (!QWindowsApi::instance()->pIsValidDpiAwarenessContext(context)) {
+            qCWarning(lcQpaWindow) << dpiAwareness << "is not supported by current system.";
+            return false;
+        }
+        if (!QWindowsApi::instance()->pSetProcessDpiAwarenessContext(context)) {
+            qCWarning(lcQpaWindow).noquote().nospace()
+                << "SetProcessDpiAwarenessContext() failed: "
+                << QSystemError::windowsString()
+                << "\nQt's default DPI awareness context is "
+                << "DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2. If you know what you "
+                << "are doing, you can overwrite this default using qt.conf "
+                << "(https://doc.qt.io/qt-6/highdpi.html#configuring-windows).";
+            return false;
+        }
+        return true;
+    }
+    if (QWindowsApi::instance()->pSetProcessDpiAwareness) {
+        const PROCESS_DPI_AWARENESS pda = qtDpiAwarenessToProcessDpiAwareness(dpiAwareness);
+        if (int(pda) == -1) {
+            qCWarning(lcQpaWindow).nospace().noquote()
+                    << "Failed to retrieve the current process's DPI awareness mode.";
+            return false;
+        }
+        const HRESULT hr = QWindowsApi::instance()->pSetProcessDpiAwareness(pda);
+        if (FAILED(hr)) {
+            qCWarning(lcQpaWindow).nospace().noquote()
+                    << "SetProcessDpiAwareness() failed: "
+                    << QSystemError::windowsComString(hr);
+            return false;
+        }
+        return true;
+    }
+    if (!SetProcessDPIAware()) {
+        qCWarning(lcQpaWindow).nospace().noquote()
+                << "SetProcessDPIAware() failed: " << QSystemError::windowsString();
         return false;
     }
-    QWindowsContextPrivate::m_v2DpiAware = true;
+    QWindowsContextPrivate::m_v2DpiAware
+        = processDpiAwareness() == QtWindows::DpiAwareness::PerMonitorVersion2;
     return true;
 }
 
@@ -837,8 +979,8 @@ void QWindowsContext::forceNcCalcSize(HWND hwnd)
 bool QWindowsContext::systemParametersInfo(unsigned action, unsigned param, void *out,
                                            unsigned dpi)
 {
-    const BOOL result = dpi != 0
-        ? SystemParametersInfoForDpi(action, param, out, 0, dpi)
+    const BOOL result = (dpi != 0) && (QWindowsApi::instance()->pSystemParametersInfoForDpi != nullptr)
+        ? QWindowsApi::instance()->pSystemParametersInfoForDpi(action, param, out, 0, dpi)
         : SystemParametersInfo(action, param, out, 0);
     return result == TRUE;
 }
@@ -885,7 +1027,8 @@ bool QWindowsContext::shouldHaveNonClientDpiScaling(const QWindow *window)
     if (QWindowsContextPrivate::m_v2DpiAware)
         return true;
 
-    return window->isTopLevel()
+    return QOperatingSystemVersion::isWin10OrGreater()
+        && window->isTopLevel()
         && !window->property(QWindowsWindow::embeddedNativeParentHandleProperty).isValid()
 #if QT_CONFIG(opengl) // /QTBUG-62901, EnableNonClientDpiScaling has problems with GL
         && (window->surfaceType() != QSurface::OpenGLSurface
@@ -921,6 +1064,23 @@ static inline bool isInputMessage(UINT m)
         || (m >= WM_KEYFIRST && m <= WM_KEYLAST);
 }
 
+// Note: This only works within WM_NCCREATE
+static bool enableNonClientDpiScaling(HWND hwnd)
+{
+    if (!QWindowsApi::instance()->pEnableNonClientDpiScaling)
+        return false;
+    bool result = false;
+    if (QWindowsContext::windowDpiAwareness(hwnd) == QtWindows::DpiAwareness::PerMonitor) {
+        result = QWindowsApi::instance()->pEnableNonClientDpiScaling(hwnd) != FALSE;
+        if (!result) {
+            const DWORD errorCode = GetLastError();
+            qErrnoWarning(int(errorCode), "EnableNonClientDpiScaling() failed for HWND %p (%lu)",
+                          hwnd, errorCode);
+        }
+    }
+    return result;
+}
+
 /*!
      \brief Main windows procedure registered for windows.
 
@@ -1532,4 +1692,137 @@ bool QWindowsContext::filterNativeEvent(QWindow *window, MSG *msg, LRESULT *resu
     return false;
 }
 
+UINT QWindowsContext::getDpiForWindow(const HWND hWnd)
+{
+    Q_ASSERT(hWnd);
+    if (!hWnd)
+        return 0;
+    if (QWindowsApi::instance()->pGetDpiForWindow)
+        return QWindowsApi::instance()->pGetDpiForWindow(hWnd);
+    if (const HDC hdc = GetDC(hWnd)) {
+        const int dpiX = GetDeviceCaps(hdc, LOGPIXELSX);
+        ReleaseDC(hWnd, hdc);
+        if (dpiX > 0)
+            return dpiX;
+    }
+    return 0;
+}
+
+UINT QWindowsContext::getDpiForMonitor(const HMONITOR hMonitor)
+{
+    Q_ASSERT(hMonitor);
+    if (!hMonitor)
+        return 0;
+    if (QWindowsApi::instance()->pGetDpiForMonitor) {
+        UINT dpiX = 0;
+        UINT dpiY = 0;
+        const HRESULT hr = QWindowsApi::instance()->pGetDpiForMonitor(hMonitor, MDT_EFFECTIVE_DPI, &dpiX, &dpiY);
+        if (SUCCEEDED(hr) && (dpiX > 0))
+            return dpiX;
+    }
+    MONITORINFOEXW monitorInfo;
+    SecureZeroMemory(&monitorInfo, sizeof(monitorInfo));
+    monitorInfo.cbSize = sizeof(monitorInfo);
+    GetMonitorInfoW(hMonitor, &monitorInfo);
+    if (const HDC hdc = CreateDCW(monitorInfo.szDevice, monitorInfo.szDevice, nullptr, nullptr)) {
+        const int dpiX = GetDeviceCaps(hdc, LOGPIXELSX);
+        DeleteDC(hdc);
+        if (dpiX > 0)
+            return dpiX;
+    }
+    return 0;
+}
+
+UINT QWindowsContext::getDpiForPrimaryMonitor()
+{
+    if (const HMONITOR hMonitor = MonitorFromWindow(GetDesktopWindow(), MONITOR_DEFAULTTOPRIMARY))
+        return getDpiForMonitor(hMonitor);
+    return 0;
+}
+
+UINT QWindowsContext::getMostPossibleDpiForWindow(const HWND hWnd)
+{
+    Q_ASSERT(hWnd);
+    if (!hWnd)
+        return 0;
+    UINT dpi = getDpiForWindow(hWnd);
+    if (dpi > 0)
+        return dpi;
+    if (const HMONITOR hMonitor = MonitorFromWindow(hWnd, MONITOR_DEFAULTTONEAREST)) {
+        dpi = getDpiForMonitor(hMonitor);
+        if (dpi > 0)
+            return dpi;
+    }
+    dpi = getDpiForPrimaryMonitor();
+    if (dpi > 0)
+        return dpi;
+    return USER_DEFAULT_SCREEN_DPI;
+}
+
+UINT QWindowsContext::getMostPossibleDpiForMonitor(const HMONITOR hMonitor)
+{
+    Q_ASSERT(hMonitor);
+    if (!hMonitor)
+        return 0;
+    UINT dpi = getDpiForMonitor(hMonitor);
+    if (dpi > 0)
+        return dpi;
+    dpi = getDpiForPrimaryMonitor();
+    if (dpi > 0)
+        return dpi;
+    return USER_DEFAULT_SCREEN_DPI;
+}
+
+int QWindowsContext::getResizeBorderThicknessForDpi(const UINT dpi)
+{
+    // The thickness of the padded border will always be 0 if DWM composition is disabled.
+    if (QWindowsApi::instance()->pGetSystemMetricsForDpi) {
+        return QWindowsApi::instance()->pGetSystemMetricsForDpi(SM_CXSIZEFRAME, dpi)
+            + QWindowsApi::instance()->pGetSystemMetricsForDpi(SM_CXPADDEDBORDER, dpi);
+    }
+    return GetSystemMetrics(SM_CXSIZEFRAME) + GetSystemMetrics(SM_CXPADDEDBORDER);
+}
+
+int QWindowsContext::getResizeBorderThickness(const HWND hWnd)
+{
+    Q_ASSERT(hWnd);
+    if (!hWnd)
+        return 0;
+    return getResizeBorderThicknessForDpi(getMostPossibleDpiForWindow(hWnd));
+}
+
+int QWindowsContext::getResizeBorderThickness(const HMONITOR hMonitor)
+{
+    Q_ASSERT(hMonitor);
+    if (!hMonitor)
+        return 0;
+    return getResizeBorderThicknessForDpi(getMostPossibleDpiForMonitor(hMonitor));
+}
+
+int QWindowsContext::getTitleBarHeightForDpi(const UINT dpi)
+{
+    const int border = getResizeBorderThicknessForDpi(dpi);
+    if (QWindowsApi::instance()->pGetSystemMetricsForDpi) {
+        return border +
+            QWindowsApi::instance()->pGetSystemMetricsForDpi(SM_CYCAPTION, dpi);
+    }
+    return border + GetSystemMetrics(SM_CYCAPTION);
+}
+
+int QWindowsContext::getTitleBarHeight(const HWND hWnd)
+{
+    Q_ASSERT(hWnd);
+    if (!hWnd)
+        return 0;
+    return getTitleBarHeightForDpi(getMostPossibleDpiForWindow(hWnd));
+}
+
+int QWindowsContext::getTitleBarHeight(const HMONITOR hMonitor)
+{
+    Q_ASSERT(hMonitor);
+    if (!hMonitor)
+        return 0;
+    return getTitleBarHeightForDpi(getMostPossibleDpiForMonitor(hMonitor));
+}
+
 QT_END_NAMESPACE
diff --git a/src/plugins/platforms/windows/qwindowscontext.h b/src/plugins/platforms/windows/qwindowscontext.h
index 6b3010f33c..4252b9b801 100644
--- a/src/plugins/platforms/windows/qwindowscontext.h
+++ b/src/plugins/platforms/windows/qwindowscontext.h
@@ -10,13 +10,18 @@
 #include <QtCore/qscopedpointer.h>
 #include <QtCore/qsharedpointer.h>
 #include <QtCore/qloggingcategory.h>
+#include <QtCore/qoperatingsystemversion.h>
+#include <QtCore/private/qsystemlibrary_p.h>
 
 #define STRICT_TYPED_ITEMIDS
 #include <shlobj.h>
 #include <shlwapi.h>
+#include <shellscalingapi.h>
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
 Q_DECLARE_LOGGING_CATEGORY(lcQpaWindow)
 Q_DECLARE_LOGGING_CATEGORY(lcQpaEvents)
 Q_DECLARE_LOGGING_CATEGORY(lcQpaGl)
@@ -44,6 +49,119 @@ class QPoint;
 class QKeyEvent;
 class QPointingDevice;
 
+struct QWindowsApi
+{
+    decltype(&::GetDpiForWindow) pGetDpiForWindow = nullptr;
+    decltype(&::GetDpiForMonitor) pGetDpiForMonitor = nullptr;
+    decltype(&::SystemParametersInfoForDpi) pSystemParametersInfoForDpi = nullptr;
+    decltype(&::GetSystemMetricsForDpi) pGetSystemMetricsForDpi = nullptr;
+    decltype(&::AdjustWindowRectExForDpi) pAdjustWindowRectExForDpi = nullptr;
+    decltype(&::GetProcessDpiAwareness) pGetProcessDpiAwareness = nullptr;
+    decltype(&::SetProcessDpiAwareness) pSetProcessDpiAwareness = nullptr;
+    decltype(&::SetProcessDpiAwarenessContext) pSetProcessDpiAwarenessContext = nullptr;
+    decltype(&::EnableNonClientDpiScaling) pEnableNonClientDpiScaling = nullptr;
+    decltype(&::GetAwarenessFromDpiAwarenessContext) pGetAwarenessFromDpiAwarenessContext = nullptr;
+    decltype(&::GetWindowDpiAwarenessContext) pGetWindowDpiAwarenessContext = nullptr;
+    decltype(&::GetThreadDpiAwarenessContext) pGetThreadDpiAwarenessContext = nullptr;
+    decltype(&::AreDpiAwarenessContextsEqual) pAreDpiAwarenessContextsEqual = nullptr;
+    decltype(&::GetPointerType) pGetPointerType = nullptr;
+    decltype(&::GetPointerInfo) pGetPointerInfo = nullptr;
+    decltype(&::GetPointerFrameTouchInfo) pGetPointerFrameTouchInfo = nullptr;
+    decltype(&::GetPointerFrameTouchInfoHistory) pGetPointerFrameTouchInfoHistory = nullptr;
+    decltype(&::GetPointerPenInfo) pGetPointerPenInfo = nullptr;
+    decltype(&::GetPointerPenInfoHistory) pGetPointerPenInfoHistory = nullptr;
+    decltype(&::SkipPointerFrameMessages) pSkipPointerFrameMessages = nullptr;
+    decltype(&::GetPointerDeviceRects) pGetPointerDeviceRects = nullptr;
+    decltype(&::SetDisplayAutoRotationPreferences) pSetDisplayAutoRotationPreferences = nullptr;
+    decltype(&::GetDisplayAutoRotationPreferences) pGetDisplayAutoRotationPreferences = nullptr;
+    decltype(&::RegisterTouchWindow) pRegisterTouchWindow = nullptr;
+    decltype(&::UnregisterTouchWindow) pUnregisterTouchWindow = nullptr;
+    decltype(&::IsTouchWindow) pIsTouchWindow = nullptr;
+    decltype(&::GetDisplayConfigBufferSizes) pGetDisplayConfigBufferSizes = nullptr;
+    decltype(&::QueryDisplayConfig) pQueryDisplayConfig = nullptr;
+    decltype(&::DisplayConfigGetDeviceInfo) pDisplayConfigGetDeviceInfo = nullptr;
+    decltype(&::GetTouchInputInfo) pGetTouchInputInfo = nullptr;
+    decltype(&::CloseTouchInputHandle) pCloseTouchInputHandle = nullptr;
+    decltype(&::ChangeWindowMessageFilterEx) pChangeWindowMessageFilterEx = nullptr;
+    decltype(&::Shell_NotifyIconGetRect) pShell_NotifyIconGetRect = nullptr;
+    decltype(&::IsValidDpiAwarenessContext) pIsValidDpiAwarenessContext = nullptr;
+
+    static QWindowsApi *instance()
+    {
+        static QWindowsApi api;
+        return &api;
+    }
+
+    bool supportsPointerApi() const
+    {
+        return pGetPointerType && pGetPointerInfo && pGetPointerFrameTouchInfo
+            && pGetPointerFrameTouchInfoHistory && pGetPointerPenInfo
+            && pGetPointerPenInfoHistory && pSkipPointerFrameMessages
+            && pGetPointerDeviceRects;
+    }
+
+private:
+    Q_DISABLE_COPY_MOVE(QWindowsApi)
+
+    explicit QWindowsApi()
+    {
+        if (QOperatingSystemVersion::isWin7OrGreater()) {
+            QSystemLibrary shell32(u"shell32"_s);
+            pShell_NotifyIconGetRect = reinterpret_cast<decltype(pShell_NotifyIconGetRect)>(shell32.resolve("Shell_NotifyIconGetRect"));
+
+            QSystemLibrary user32(u"user32"_s);
+            pRegisterTouchWindow = reinterpret_cast<decltype(pRegisterTouchWindow)>(user32.resolve("RegisterTouchWindow"));
+            pUnregisterTouchWindow = reinterpret_cast<decltype(pUnregisterTouchWindow)>(user32.resolve("UnregisterTouchWindow"));
+            pIsTouchWindow = reinterpret_cast<decltype(pIsTouchWindow)>(user32.resolve("IsTouchWindow"));
+            pGetDisplayConfigBufferSizes = reinterpret_cast<decltype(pGetDisplayConfigBufferSizes)>(user32.resolve("GetDisplayConfigBufferSizes"));
+            pQueryDisplayConfig = reinterpret_cast<decltype(pQueryDisplayConfig)>(user32.resolve("QueryDisplayConfig"));
+            pDisplayConfigGetDeviceInfo = reinterpret_cast<decltype(pDisplayConfigGetDeviceInfo)>(user32.resolve("DisplayConfigGetDeviceInfo"));
+            pGetTouchInputInfo = reinterpret_cast<decltype(pGetTouchInputInfo)>(user32.resolve("GetTouchInputInfo"));
+            pCloseTouchInputHandle = reinterpret_cast<decltype(pCloseTouchInputHandle)>(user32.resolve("CloseTouchInputHandle"));
+            pChangeWindowMessageFilterEx = reinterpret_cast<decltype(pChangeWindowMessageFilterEx)>(user32.resolve("ChangeWindowMessageFilterEx"));
+
+            if (QOperatingSystemVersion::isWin8OrGreater()) {
+                pGetPointerType = reinterpret_cast<decltype(pGetPointerType)>(user32.resolve("GetPointerType"));
+                pGetPointerInfo = reinterpret_cast<decltype(pGetPointerInfo)>(user32.resolve("GetPointerInfo"));
+                pGetPointerFrameTouchInfo = reinterpret_cast<decltype(pGetPointerFrameTouchInfo)>(user32.resolve("GetPointerFrameTouchInfo"));
+                pGetPointerFrameTouchInfoHistory = reinterpret_cast<decltype(pGetPointerFrameTouchInfoHistory)>(user32.resolve("GetPointerFrameTouchInfoHistory"));
+                pGetPointerPenInfo = reinterpret_cast<decltype(pGetPointerPenInfo)>(user32.resolve("GetPointerPenInfo"));
+                pGetPointerPenInfoHistory = reinterpret_cast<decltype(pGetPointerPenInfoHistory)>(user32.resolve("GetPointerPenInfoHistory"));
+                pSkipPointerFrameMessages = reinterpret_cast<decltype(pSkipPointerFrameMessages)>(user32.resolve("SkipPointerFrameMessages"));
+                pGetPointerDeviceRects = reinterpret_cast<decltype(pGetPointerDeviceRects)>(user32.resolve("GetPointerDeviceRects"));
+                pSetDisplayAutoRotationPreferences = reinterpret_cast<decltype(pSetDisplayAutoRotationPreferences)>(user32.resolve("SetDisplayAutoRotationPreferences"));
+                pGetDisplayAutoRotationPreferences = reinterpret_cast<decltype(pGetDisplayAutoRotationPreferences)>(user32.resolve("GetDisplayAutoRotationPreferences"));
+
+                if (QOperatingSystemVersion::isWin8Point1OrGreater()) {
+                    QSystemLibrary shcore(u"shcore"_s);
+                    pGetDpiForMonitor = reinterpret_cast<decltype(pGetDpiForMonitor)>(shcore.resolve("GetDpiForMonitor"));
+                    pGetProcessDpiAwareness = reinterpret_cast<decltype(pGetProcessDpiAwareness)>(shcore.resolve("GetProcessDpiAwareness"));
+                    pSetProcessDpiAwareness = reinterpret_cast<decltype(pSetProcessDpiAwareness)>(shcore.resolve("SetProcessDpiAwareness"));
+
+                    if (QOperatingSystemVersion::isWin10RS1OrGreater()) {
+                        pGetDpiForWindow = reinterpret_cast<decltype(pGetDpiForWindow)>(user32.resolve("GetDpiForWindow"));
+                        pSystemParametersInfoForDpi = reinterpret_cast<decltype(pSystemParametersInfoForDpi)>(user32.resolve("SystemParametersInfoForDpi"));
+                        pGetSystemMetricsForDpi = reinterpret_cast<decltype(pGetSystemMetricsForDpi)>(user32.resolve("GetSystemMetricsForDpi"));
+                        pAdjustWindowRectExForDpi = reinterpret_cast<decltype(pAdjustWindowRectExForDpi)>(user32.resolve("AdjustWindowRectExForDpi"));
+                        pEnableNonClientDpiScaling = reinterpret_cast<decltype(pEnableNonClientDpiScaling)>(user32.resolve("EnableNonClientDpiScaling"));
+                        pGetAwarenessFromDpiAwarenessContext = reinterpret_cast<decltype(pGetAwarenessFromDpiAwarenessContext)>(user32.resolve("GetAwarenessFromDpiAwarenessContext"));
+                        pGetWindowDpiAwarenessContext = reinterpret_cast<decltype(pGetWindowDpiAwarenessContext)>(user32.resolve("GetWindowDpiAwarenessContext"));
+                        pGetThreadDpiAwarenessContext = reinterpret_cast<decltype(pGetThreadDpiAwarenessContext)>(user32.resolve("GetThreadDpiAwarenessContext"));
+                        pAreDpiAwarenessContextsEqual = reinterpret_cast<decltype(pAreDpiAwarenessContextsEqual)>(user32.resolve("AreDpiAwarenessContextsEqual"));
+                        pIsValidDpiAwarenessContext = reinterpret_cast<decltype(pIsValidDpiAwarenessContext)>(user32.resolve("IsValidDpiAwarenessContext"));
+
+                        if (QOperatingSystemVersion::isWin10RS2OrGreater()) {
+                            pSetProcessDpiAwarenessContext = reinterpret_cast<decltype(pSetProcessDpiAwarenessContext)>(user32.resolve("SetProcessDpiAwarenessContext"));
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    ~QWindowsApi() = default;
+};
+
 class QWindowsContext
 {
     Q_DISABLE_COPY_MOVE(QWindowsContext)
@@ -115,9 +233,10 @@ public:
     QSharedPointer<QWindowCreationContext> windowCreationContext() const;
 
     static void setTabletAbsoluteRange(int a);
-    void setProcessDpiAwareness(QtWindows::ProcessDpiAwareness dpiAwareness);
-    static int processDpiAwareness();
-    bool setProcessDpiV2Awareness();
+    
+    static bool setProcessDpiAwareness(QtWindows::DpiAwareness dpiAwareness);
+    static QtWindows::DpiAwareness processDpiAwareness();
+    static QtWindows::DpiAwareness windowDpiAwareness(HWND hwnd);
 
     static bool isDarkMode();
 
@@ -158,6 +277,18 @@ public:
     static bool filterNativeEvent(MSG *msg, LRESULT *result);
     static bool filterNativeEvent(QWindow *window, MSG *msg, LRESULT *result);
 
+    [[nodiscard]] static UINT getDpiForWindow(const HWND hWnd);
+    [[nodiscard]] static UINT getDpiForMonitor(const HMONITOR hMonitor);
+    [[nodiscard]] static UINT getDpiForPrimaryMonitor();
+    [[nodiscard]] static UINT getMostPossibleDpiForWindow(const HWND hWnd);
+    [[nodiscard]] static UINT getMostPossibleDpiForMonitor(const HMONITOR hMonitor);
+    [[nodiscard]] static int getResizeBorderThicknessForDpi(const UINT dpi);
+    [[nodiscard]] static int getResizeBorderThickness(const HWND hWnd);
+    [[nodiscard]] static int getResizeBorderThickness(const HMONITOR hMonitor);
+    [[nodiscard]] static int getTitleBarHeightForDpi(const UINT dpi);
+    [[nodiscard]] static int getTitleBarHeight(const HWND hWnd);
+    [[nodiscard]] static int getTitleBarHeight(const HMONITOR hMonitor);
+
 private:
     void handleFocusEvent(QtWindows::WindowsEventType et, QWindowsWindow *w);
 #ifndef QT_NO_CONTEXTMENU
diff --git a/src/plugins/platforms/windows/qwindowsdialoghelpers.cpp b/src/plugins/platforms/windows/qwindowsdialoghelpers.cpp
index a8dbd8633e..9d817a4f90 100644
--- a/src/plugins/platforms/windows/qwindowsdialoghelpers.cpp
+++ b/src/plugins/platforms/windows/qwindowsdialoghelpers.cpp
@@ -1414,7 +1414,8 @@ static QString createTemporaryItemCopy(QWindowsShellItem &qItem, QString *errorM
 static QUrl itemToDialogUrl(QWindowsShellItem &qItem, QString *errorMessage)
 {
     QUrl url = qItem.url();
-    if (url.isLocalFile() || url.scheme().startsWith(u"http"))
+    // Patch: Make loaded 'http' resources copy.
+    if (url.isLocalFile()/*|| url.scheme().startsWith(u"http")*/)
         return url;
     const QString path = qItem.path();
     if (path.isEmpty() && !qItem.isDir() && qItem.canStream()) {
diff --git a/src/plugins/platforms/windows/qwindowsdrag.cpp b/src/plugins/platforms/windows/qwindowsdrag.cpp
index 48e0bba41f..fe36b00cf4 100644
--- a/src/plugins/platforms/windows/qwindowsdrag.cpp
+++ b/src/plugins/platforms/windows/qwindowsdrag.cpp
@@ -665,12 +665,13 @@ static HRESULT startDoDragDrop(LPDATAOBJECT pDataObj, LPDROPSOURCE pDropSource,
                 return ::DoDragDrop(pDataObj, pDropSource, dwOKEffects, pdwEffect);
             }
 
-            if (msg.message == WM_POINTERUPDATE) {
+            static const bool pointerApiSupported = QWindowsApi::instance()->supportsPointerApi();
+            if (msg.message == WM_POINTERUPDATE && pointerApiSupported) {
 
                 const quint32 pointerId = GET_POINTERID_WPARAM(msg.wParam);
 
                 POINTER_INFO pointerInfo{};
-                if (!GetPointerInfo(pointerId, &pointerInfo))
+                if (!QWindowsApi::instance()->pGetPointerInfo(pointerId, &pointerInfo))
                     return E_FAIL;
 
                 if (pointerInfo.pointerFlags & POINTER_FLAG_PRIMARY) {
@@ -714,7 +715,7 @@ static HRESULT startDoDragDrop(LPDATAOBJECT pDataObj, LPDROPSOURCE pDropSource,
                 // Handle other messages.
                 qWindowsWndProc(msg.hwnd, msg.message, msg.wParam, msg.lParam);
 
-                if (msg.message == WM_POINTERLEAVE)
+                if (msg.message == WM_POINTERLEAVE && pointerApiSupported)
                     return E_FAIL;
             }
         } else {
diff --git a/src/plugins/platforms/windows/qwindowsintegration.cpp b/src/plugins/platforms/windows/qwindowsintegration.cpp
index 923e515b4f..395f3226e0 100644
--- a/src/plugins/platforms/windows/qwindowsintegration.cpp
+++ b/src/plugins/platforms/windows/qwindowsintegration.cpp
@@ -221,8 +221,12 @@ void QWindowsIntegrationPrivate::parseOptions(QWindowsIntegration *q, const QStr
     initOpenGlBlacklistResources();
 
     static bool dpiAwarenessSet = false;
+    static const bool hasDpiAwarenessContext =
+            QWindowsApi::instance()->pSetProcessDpiAwarenessContext != nullptr;
     // Default to per-monitor-v2 awareness (if available)
-    QtWindows::ProcessDpiAwareness dpiAwareness = QtWindows::ProcessPerMonitorV2DpiAware;
+    QtWindows::DpiAwareness dpiAwareness = hasDpiAwarenessContext
+            ? QtWindows::DpiAwareness::PerMonitorVersion2
+            : QtWindows::DpiAwareness::PerMonitor;
 
     int tabletAbsoluteRange = -1;
     DarkModeHandling darkModeHandling = DarkModeHandlingFlag::DarkModeWindowFrames
@@ -241,22 +245,13 @@ void QWindowsIntegrationPrivate::parseOptions(QWindowsIntegration *q, const QStr
 
     if (!dpiAwarenessSet) { // Set only once in case of repeated instantiations of QGuiApplication.
         if (!QCoreApplication::testAttribute(Qt::AA_PluginApplication)) {
-            if (dpiAwareness == QtWindows::ProcessPerMonitorV2DpiAware) {
-                // DpiAwareV2 requires using new API
-                if (m_context.setProcessDpiV2Awareness()) {
-                    qCDebug(lcQpaWindow, "DpiAwareness: DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2");
-                    dpiAwarenessSet = true;
-                } else {
-                    // fallback to old API
-                    dpiAwareness = QtWindows::ProcessPerMonitorDpiAware;
+            for (auto i = int(dpiAwareness); i != int(QtWindows::DpiAwareness::Invalid); --i) {
+                if (m_context.setProcessDpiAwareness(QtWindows::DpiAwareness(i))) {
+                    break;
                 }
             }
-
-            if (!dpiAwarenessSet) {
-                m_context.setProcessDpiAwareness(dpiAwareness);
-                qCDebug(lcQpaWindow) << "DpiAwareness=" << dpiAwareness
-                    << "effective process DPI awareness=" << QWindowsContext::processDpiAwareness();
-            }
+            qCDebug(lcQpaWindow) << "DpiAwareness=" << dpiAwareness
+                << "effective process DPI awareness=" << QWindowsContext::processDpiAwareness();
         }
         dpiAwarenessSet = true;
     }
diff --git a/src/plugins/platforms/windows/qwindowskeymapper.cpp b/src/plugins/platforms/windows/qwindowskeymapper.cpp
index 3089e745d4..fa961110d7 100644
--- a/src/plugins/platforms/windows/qwindowskeymapper.cpp
+++ b/src/plugins/platforms/windows/qwindowskeymapper.cpp
@@ -749,21 +749,10 @@ static inline QString messageKeyText(const MSG &msg)
     return ch.isNull() ? QString() : QString(ch);
 }
 
-[[nodiscard]] static inline int getTitleBarHeight(const HWND hwnd)
-{
-    const UINT dpi = GetDpiForWindow(hwnd);
-    const int captionHeight = GetSystemMetricsForDpi(SM_CYCAPTION, dpi);
-    if (IsZoomed(hwnd))
-        return captionHeight;
-    // The frame height should also be taken into account if the window
-    // is not maximized.
-    const int frameHeight = GetSystemMetricsForDpi(SM_CYSIZEFRAME, dpi)
-                            + GetSystemMetricsForDpi(SM_CXPADDEDBORDER, dpi);
-    return captionHeight + frameHeight;
-}
-
 [[nodiscard]] static inline bool isSystemMenuOffsetNeeded(const Qt::WindowFlags flags)
 {
+    if (qEnvironmentVariableIntValue("QT_WINDOWS_SYSTEM_MENU_NEED_OFFSET"))
+        return true;
     static constexpr const Qt::WindowFlags titleBarHints =
         Qt::WindowMinMaxButtonsHint | Qt::WindowCloseButtonHint | Qt::WindowContextHelpButtonHint;
     return (flags & Qt::WindowSystemMenuHint) && (flags & Qt::WindowTitleHint) && !(flags & titleBarHints)
@@ -804,7 +793,8 @@ static void showSystemMenu(QWindow* w)
 #undef disabled
 
     const QPoint pos = QHighDpi::toNativePixels(topLevel->geometry().topLeft(), topLevel);
-    const int titleBarOffset = isSystemMenuOffsetNeeded(topLevel->flags()) ? getTitleBarHeight(topLevelHwnd) : 0;
+    const int titleBarOffset = isSystemMenuOffsetNeeded(topLevel->flags())
+        ? QWindowsContext::getTitleBarHeight(topLevelHwnd) : 0;
     const int ret = TrackPopupMenuEx(menu,
                                TPM_LEFTALIGN | TPM_TOPALIGN | TPM_NONOTIFY | TPM_RETURNCMD,
                                pos.x(), pos.y() + titleBarOffset,
diff --git a/src/plugins/platforms/windows/qwindowsmousehandler.cpp b/src/plugins/platforms/windows/qwindowsmousehandler.cpp
index 28c88ab716..dc51ce4293 100644
--- a/src/plugins/platforms/windows/qwindowsmousehandler.cpp
+++ b/src/plugins/platforms/windows/qwindowsmousehandler.cpp
@@ -564,6 +564,11 @@ bool QWindowsMouseHandler::translateTouchEvent(QWindow *window, HWND,
     using QTouchPoint = QWindowSystemInterface::TouchPoint;
     using QTouchPointList = QList<QWindowSystemInterface::TouchPoint>;
 
+    if (!QWindowsApi::instance()->pGetTouchInputInfo
+            || !QWindowsApi::instance()->pCloseTouchInputHandle) {
+        return true;
+    }
+
     if (!QWindowsContext::instance()->initTouch()) {
         qWarning("Unable to initialize touch handling.");
         return true;
@@ -584,8 +589,8 @@ bool QWindowsMouseHandler::translateTouchEvent(QWindow *window, HWND,
     touchPoints.reserve(winTouchPointCount);
     QEventPoint::States allStates;
 
-    GetTouchInputInfo(reinterpret_cast<HTOUCHINPUT>(msg.lParam),
-                      UINT(msg.wParam), winTouchInputs.data(), sizeof(TOUCHINPUT));
+    QWindowsApi::instance()->pGetTouchInputInfo(reinterpret_cast<HTOUCHINPUT>(msg.lParam),
+                      UINT(msg.wParam), winTouchInputs.get(), sizeof(TOUCHINPUT));
     for (int i = 0; i < winTouchPointCount; ++i) {
         const TOUCHINPUT &winTouchInput = winTouchInputs[i];
         int id = m_touchInputIDToTouchPointID.value(winTouchInput.dwID, -1);
@@ -626,7 +631,7 @@ bool QWindowsMouseHandler::translateTouchEvent(QWindow *window, HWND,
         touchPoints.append(touchPoint);
     }
 
-    CloseTouchInputHandle(reinterpret_cast<HTOUCHINPUT>(msg.lParam));
+    QWindowsApi::instance()->pCloseTouchInputHandle(reinterpret_cast<HTOUCHINPUT>(msg.lParam));
 
     // all touch points released, forget the ids we've seen, they may not be reused
     if (allStates == QEventPoint::State::Released)
diff --git a/src/plugins/platforms/windows/qwindowsopengltester.cpp b/src/plugins/platforms/windows/qwindowsopengltester.cpp
index 6a790bcc1b..b03bcc1bf5 100644
--- a/src/plugins/platforms/windows/qwindowsopengltester.cpp
+++ b/src/plugins/platforms/windows/qwindowsopengltester.cpp
@@ -65,7 +65,11 @@ private:
 
 QDirect3D9Handle::QDirect3D9Handle()
 {
-    m_direct3D9 = Direct3DCreate9(D3D_SDK_VERSION);
+    static const auto pDirect3DCreate9 =
+        reinterpret_cast<decltype(&::Direct3DCreate9)>(
+            QSystemLibrary::resolve(u"d3d9"_s, "Direct3DCreate9"));
+    if (pDirect3DCreate9)
+        m_direct3D9 = pDirect3DCreate9(D3D_SDK_VERSION);
 }
 
 QDirect3D9Handle::~QDirect3D9Handle()
diff --git a/src/plugins/platforms/windows/qwindowspointerhandler.cpp b/src/plugins/platforms/windows/qwindowspointerhandler.cpp
index 88f02347b3..75226c3810 100644
--- a/src/plugins/platforms/windows/qwindowspointerhandler.cpp
+++ b/src/plugins/platforms/windows/qwindowspointerhandler.cpp
@@ -45,10 +45,13 @@ QWindowsPointerHandler::~QWindowsPointerHandler()
 
 bool QWindowsPointerHandler::translatePointerEvent(QWindow *window, HWND hwnd, QtWindows::WindowsEventType et, MSG msg, LRESULT *result)
 {
+    if (!QWindowsApi::instance()->supportsPointerApi())
+        return false;
+
     *result = 0;
     const quint32 pointerId = GET_POINTERID_WPARAM(msg.wParam);
 
-    if (!GetPointerType(pointerId, &m_pointerType)) {
+    if (!QWindowsApi::instance()->pGetPointerType(pointerId, &m_pointerType)) {
         qWarning() << "GetPointerType() failed:" << qt_error_string();
         return false;
     }
@@ -62,12 +65,12 @@ bool QWindowsPointerHandler::translatePointerEvent(QWindow *window, HWND hwnd, Q
     }
     case QT_PT_TOUCH: {
         quint32 pointerCount = 0;
-        if (!GetPointerFrameTouchInfo(pointerId, &pointerCount, nullptr)) {
+        if (!QWindowsApi::instance()->pGetPointerFrameTouchInfo(pointerId, &pointerCount, nullptr)) {
             qWarning() << "GetPointerFrameTouchInfo() failed:" << qt_error_string();
             return false;
         }
         QVarLengthArray<POINTER_TOUCH_INFO, 10> touchInfo(pointerCount);
-        if (!GetPointerFrameTouchInfo(pointerId, &pointerCount, touchInfo.data())) {
+        if (!QWindowsApi::instance()->pGetPointerFrameTouchInfo(pointerId, &pointerCount, touchInfo.data())) {
             qWarning() << "GetPointerFrameTouchInfo() failed:" << qt_error_string();
             return false;
         }
@@ -80,7 +83,7 @@ bool QWindowsPointerHandler::translatePointerEvent(QWindow *window, HWND hwnd, Q
         // dispatch any skipped frames if event compression is disabled by the app
         if (historyCount > 1 && !QCoreApplication::testAttribute(Qt::AA_CompressHighFrequencyEvents)) {
             touchInfo.resize(pointerCount * historyCount);
-            if (!GetPointerFrameTouchInfoHistory(pointerId,
+            if (!QWindowsApi::instance()->pGetPointerFrameTouchInfoHistory(pointerId,
                                                  &historyCount,
                                                  &pointerCount,
                                                  touchInfo.data())) {
@@ -101,7 +104,7 @@ bool QWindowsPointerHandler::translatePointerEvent(QWindow *window, HWND hwnd, Q
     }
     case QT_PT_PEN: {
         POINTER_PEN_INFO penInfo;
-        if (!GetPointerPenInfo(pointerId, &penInfo)) {
+        if (!QWindowsApi::instance()->pGetPointerPenInfo(pointerId, &penInfo)) {
             qWarning() << "GetPointerPenInfo() failed:" << qt_error_string();
             return false;
         }
@@ -113,7 +116,7 @@ bool QWindowsPointerHandler::translatePointerEvent(QWindow *window, HWND hwnd, Q
                 || !QCoreApplication::testAttribute(Qt::AA_CompressTabletEvents))) {
             QVarLengthArray<POINTER_PEN_INFO, 10> penInfoHistory(historyCount);
 
-            if (!GetPointerPenInfoHistory(pointerId, &historyCount, penInfoHistory.data())) {
+            if (!QWindowsApi::instance()->pGetPointerPenInfoHistory(pointerId, &historyCount, penInfoHistory.data())) {
                 qWarning() << "GetPointerPenInfoHistory() failed:" << qt_error_string();
                 return false;
             }
@@ -419,6 +422,9 @@ bool QWindowsPointerHandler::translateTouchEvent(QWindow *window, HWND hwnd,
 {
     Q_UNUSED(hwnd);
 
+    if (!QWindowsApi::instance()->supportsPointerApi())
+        return false;
+
     auto *touchInfo = static_cast<POINTER_TOUCH_INFO *>(vTouchInfo);
 
     if (et & QtWindows::NonClientEventFlag)
@@ -517,7 +523,7 @@ bool QWindowsPointerHandler::translateTouchEvent(QWindow *window, HWND hwnd,
         inputIds.insert(touchPoint.id);
 
         // Avoid getting repeated messages for this frame if there are multiple pointerIds
-        SkipPointerFrameMessages(touchInfo[i].pointerInfo.pointerId);
+        QWindowsApi::instance()->pSkipPointerFrameMessages(touchInfo[i].pointerInfo.pointerId);
     }
 
     // Some devices send touches for each finger in a different message/frame, instead of consolidating
@@ -557,13 +563,16 @@ bool QWindowsPointerHandler::translatePenEvent(QWindow *window, HWND hwnd, QtWin
                                                MSG msg, PVOID vPenInfo)
 {
 #if QT_CONFIG(tabletevent)
+    if (!QWindowsApi::instance()->supportsPointerApi())
+        return false;
+
     if (et & QtWindows::NonClientEventFlag)
         return false; // Let DefWindowProc() handle Non Client messages.
 
     auto *penInfo = static_cast<POINTER_PEN_INFO *>(vPenInfo);
 
     RECT pRect, dRect;
-    if (!GetPointerDeviceRects(penInfo->pointerInfo.sourceDevice, &pRect, &dRect))
+    if (!QWindowsApi::instance()->pGetPointerDeviceRects(penInfo->pointerInfo.sourceDevice, &pRect, &dRect))
         return false;
 
     const auto systemId = (qint64)penInfo->pointerInfo.sourceDevice;
diff --git a/src/plugins/platforms/windows/qwindowsscreen.cpp b/src/plugins/platforms/windows/qwindowsscreen.cpp
index 5414fc2778..7428e7a347 100644
--- a/src/plugins/platforms/windows/qwindowsscreen.cpp
+++ b/src/plugins/platforms/windows/qwindowsscreen.cpp
@@ -28,22 +28,14 @@ QT_BEGIN_NAMESPACE
 
 using namespace Qt::StringLiterals;
 
-static inline QDpi deviceDPI(HDC hdc)
-{
-    return QDpi(GetDeviceCaps(hdc, LOGPIXELSX), GetDeviceCaps(hdc, LOGPIXELSY));
-}
-
-static inline QDpi monitorDPI(HMONITOR hMonitor)
-{
-    UINT dpiX;
-    UINT dpiY;
-    if (SUCCEEDED(GetDpiForMonitor(hMonitor, MDT_EFFECTIVE_DPI, &dpiX, &dpiY)))
-        return QDpi(dpiX, dpiY);
-    return {0, 0};
-}
-
 static bool getPathInfo(const MONITORINFOEX &viewInfo, DISPLAYCONFIG_PATH_INFO *pathInfo)
 {
+    if (!QWindowsApi::instance()->pGetDisplayConfigBufferSizes
+            || !QWindowsApi::instance()->pQueryDisplayConfig
+            || !QWindowsApi::instance()->pDisplayConfigGetDeviceInfo) {
+        return false;
+    }
+
     // We might want to consider storing adapterId/id from DISPLAYCONFIG_PATH_TARGET_INFO.
     std::vector<DISPLAYCONFIG_PATH_INFO> pathInfos;
     std::vector<DISPLAYCONFIG_MODE_INFO> modeInfos;
@@ -56,14 +48,15 @@ static bool getPathInfo(const MONITORINFOEX &viewInfo, DISPLAYCONFIG_PATH_INFO *
         // QueryDisplayConfig documentation doesn't say the number of needed elements is updated
         // when the call fails with ERROR_INSUFFICIENT_BUFFER, so we need a separate call to
         // look up the needed buffer sizes.
-        if (GetDisplayConfigBufferSizes(QDC_ONLY_ACTIVE_PATHS, &numPathArrayElements,
-                                        &numModeInfoArrayElements) != ERROR_SUCCESS) {
+        if (QWindowsApi::instance()->pGetDisplayConfigBufferSizes(
+                QDC_ONLY_ACTIVE_PATHS, &numPathArrayElements, &numModeInfoArrayElements) != ERROR_SUCCESS) {
             return false;
         }
         pathInfos.resize(numPathArrayElements);
         modeInfos.resize(numModeInfoArrayElements);
-        result = QueryDisplayConfig(QDC_ONLY_ACTIVE_PATHS, &numPathArrayElements, pathInfos.data(),
-                                    &numModeInfoArrayElements, modeInfos.data(), nullptr);
+        result = QWindowsApi::instance()->pQueryDisplayConfig(
+                    QDC_ONLY_ACTIVE_PATHS, &numPathArrayElements, pathInfos.data(),
+                    &numModeInfoArrayElements, modeInfos.data(), nullptr);
     } while (result == ERROR_INSUFFICIENT_BUFFER);
 
     if (result != ERROR_SUCCESS)
@@ -76,7 +69,7 @@ static bool getPathInfo(const MONITORINFOEX &viewInfo, DISPLAYCONFIG_PATH_INFO *
         deviceName.header.size = sizeof(DISPLAYCONFIG_SOURCE_DEVICE_NAME);
         deviceName.header.adapterId = pathInfos[p].sourceInfo.adapterId;
         deviceName.header.id = pathInfos[p].sourceInfo.id;
-        if (DisplayConfigGetDeviceInfo(&deviceName.header) == ERROR_SUCCESS) {
+        if (QWindowsApi::instance()->pDisplayConfigGetDeviceInfo(&deviceName.header) == ERROR_SUCCESS) {
             if (wcscmp(viewInfo.szDevice, deviceName.viewGdiDeviceName) == 0) {
                 *pathInfo = pathInfos[p];
                 return true;
@@ -91,8 +84,9 @@ static bool getPathInfo(const MONITORINFOEX &viewInfo, DISPLAYCONFIG_PATH_INFO *
 // Needed later for HDR support
 static float getMonitorSDRWhiteLevel(DISPLAYCONFIG_PATH_TARGET_INFO *targetInfo)
 {
-    const float defaultSdrWhiteLevel = 200.0;
-    if (!targetInfo)
+    static constexpr const float defaultSdrWhiteLevel = 200.0;
+
+    if (!QWindowsApi::instance()->pDisplayConfigGetDeviceInfo || !targetInfo)
         return defaultSdrWhiteLevel;
 
     DISPLAYCONFIG_SDR_WHITE_LEVEL whiteLevel = {};
@@ -100,7 +94,7 @@ static float getMonitorSDRWhiteLevel(DISPLAYCONFIG_PATH_TARGET_INFO *targetInfo)
     whiteLevel.header.size = sizeof(DISPLAYCONFIG_SDR_WHITE_LEVEL);
     whiteLevel.header.adapterId = targetInfo->adapterId;
     whiteLevel.header.id = targetInfo->id;
-    if (DisplayConfigGetDeviceInfo(&whiteLevel.header) != ERROR_SUCCESS)
+    if (QWindowsApi::instance()->pDisplayConfigGetDeviceInfo(&whiteLevel.header) != ERROR_SUCCESS)
         return defaultSdrWhiteLevel;
     return whiteLevel.SDRWhiteLevel * 80.0 / 1000.0;
 }
@@ -128,7 +122,7 @@ static bool monitorData(HMONITOR hMonitor, QWindowsScreenData *data)
         deviceName.header.size = sizeof(DISPLAYCONFIG_TARGET_DEVICE_NAME);
         deviceName.header.adapterId = pathInfo.targetInfo.adapterId;
         deviceName.header.id = pathInfo.targetInfo.id;
-        if (DisplayConfigGetDeviceInfo(&deviceName.header) == ERROR_SUCCESS)
+        if (QWindowsApi::instance()->pDisplayConfigGetDeviceInfo(&deviceName.header) == ERROR_SUCCESS)
             data->name = QString::fromWCharArray(deviceName.monitorFriendlyDeviceName);
     }
     if (data->name.isEmpty())
@@ -137,8 +131,8 @@ static bool monitorData(HMONITOR hMonitor, QWindowsScreenData *data)
         data->flags |= QWindowsScreenData::LockScreen;
     } else {
         if (const HDC hdc = CreateDC(info.szDevice, nullptr, nullptr, nullptr)) {
-            const QDpi dpi = monitorDPI(hMonitor);
-            data->dpi = dpi.first > 0 ? dpi : deviceDPI(hdc);
+            const UINT dpi = QWindowsContext::getMostPossibleDpiForMonitor(hMonitor);
+            data->dpi = QDpi(dpi, dpi);
             data->depth = GetDeviceCaps(hdc, BITSPIXEL);
             data->format = data->depth == 16 ? QImage::Format_RGB16 : QImage::Format_RGB32;
             data->physicalSizeMM = QSizeF(GetDeviceCaps(hdc, HORZSIZE), GetDeviceCaps(hdc, VERTSIZE));
@@ -424,7 +418,8 @@ QRect QWindowsScreen::virtualGeometry(const QPlatformScreen *screen) // cf QScre
 
 bool QWindowsScreen::setOrientationPreference(Qt::ScreenOrientation o)
 {
-    bool result = false;
+    if (!QWindowsApi::instance()->pSetDisplayAutoRotationPreferences)
+        return false;
     ORIENTATION_PREFERENCE orientationPreference = ORIENTATION_PREFERENCE_NONE;
     switch (o) {
     case Qt::PrimaryOrientation:
@@ -442,33 +437,29 @@ bool QWindowsScreen::setOrientationPreference(Qt::ScreenOrientation o)
         orientationPreference = ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED;
         break;
     }
-    result = SetDisplayAutoRotationPreferences(orientationPreference);
-    return result;
+    return QWindowsApi::instance()->pSetDisplayAutoRotationPreferences(orientationPreference);
 }
 
 Qt::ScreenOrientation QWindowsScreen::orientationPreference()
 {
-    Qt::ScreenOrientation result = Qt::PrimaryOrientation;
+    if (!QWindowsApi::instance()->pGetDisplayAutoRotationPreferences)
+        return Qt::PrimaryOrientation;
     ORIENTATION_PREFERENCE orientationPreference = ORIENTATION_PREFERENCE_NONE;
-    if (GetDisplayAutoRotationPreferences(&orientationPreference)) {
+    if (QWindowsApi::instance()->pGetDisplayAutoRotationPreferences(&orientationPreference)) {
         switch (orientationPreference) {
         case ORIENTATION_PREFERENCE_NONE:
-            break;
+            return Qt::PrimaryOrientation;
         case ORIENTATION_PREFERENCE_LANDSCAPE:
-            result = Qt::LandscapeOrientation;
-            break;
+            return Qt::LandscapeOrientation;
         case ORIENTATION_PREFERENCE_PORTRAIT:
-            result = Qt::PortraitOrientation;
-            break;
+            return Qt::PortraitOrientation;
         case ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED:
-            result = Qt::InvertedLandscapeOrientation;
-            break;
+            return Qt::InvertedLandscapeOrientation;
         case ORIENTATION_PREFERENCE_PORTRAIT_FLIPPED:
-            result = Qt::InvertedPortraitOrientation;
-            break;
+            return Qt::InvertedPortraitOrientation;
         }
     }
-    return result;
+    return Qt::PrimaryOrientation;
 }
 
 /*!
diff --git a/src/plugins/platforms/windows/qwindowsservices.cpp b/src/plugins/platforms/windows/qwindowsservices.cpp
index d9bb76d10a..fb3b6454c2 100644
--- a/src/plugins/platforms/windows/qwindowsservices.cpp
+++ b/src/plugins/platforms/windows/qwindowsservices.cpp
@@ -163,6 +163,10 @@ static inline bool launchMail(const QUrl &url)
             command.prepend(doubleQuote);
         }
     }
+
+    // Patch: Fix mail launch if no param is expected in this command.
+    if (command.indexOf(QStringLiteral("%1")) < 0) return false;
+
     // Pass the url as the parameter. Should use QProcess::startDetached(),
     // but that cannot handle a Windows command line [yet].
     command.replace("%1"_L1, url.toString(QUrl::FullyEncoded));
diff --git a/src/plugins/platforms/windows/qwindowssystemtrayicon.cpp b/src/plugins/platforms/windows/qwindowssystemtrayicon.cpp
index 3bad237f9e..7a9b2c5b07 100644
--- a/src/plugins/platforms/windows/qwindowssystemtrayicon.cpp
+++ b/src/plugins/platforms/windows/qwindowssystemtrayicon.cpp
@@ -184,13 +184,16 @@ void QWindowsSystemTrayIcon::updateToolTip(const QString &tooltip)
 
 QRect QWindowsSystemTrayIcon::geometry() const
 {
+    if (!QWindowsApi::instance()->pShell_NotifyIconGetRect)
+        return {};
     NOTIFYICONIDENTIFIER nid;
     memset(&nid, 0, sizeof(nid));
     nid.cbSize = sizeof(nid);
     nid.hWnd = m_hwnd;
     nid.uID = q_uNOTIFYICONID;
     RECT rect;
-    const QRect result = SUCCEEDED(Shell_NotifyIconGetRect(&nid, &rect))
+    const QRect result =
+        SUCCEEDED(QWindowsApi::instance()->pShell_NotifyIconGetRect(&nid, &rect))
         ? QRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top)
         : QRect();
     qCDebug(lcQpaTrayIcon) << __FUNCTION__ << this << "returns" << result;
@@ -272,7 +275,8 @@ bool QWindowsSystemTrayIcon::ensureInstalled()
     if (!MYWM_TASKBARCREATED)
         MYWM_TASKBARCREATED = RegisterWindowMessage(L"TaskbarCreated");
     // Allow the WM_TASKBARCREATED message through the UIPI filter
-    ChangeWindowMessageFilterEx(m_hwnd, MYWM_TASKBARCREATED, MSGFLT_ALLOW, nullptr);
+    if (QWindowsApi::instance()->pChangeWindowMessageFilterEx)
+        QWindowsApi::instance()->pChangeWindowMessageFilterEx(m_hwnd, MYWM_TASKBARCREATED, MSGFLT_ALLOW, nullptr);
     qCDebug(lcQpaTrayIcon) << __FUNCTION__ << this << "MYWM_TASKBARCREATED=" << MYWM_TASKBARCREATED;
 
     QWindowsHwndSystemTrayIconEntry entry{m_hwnd, this};
diff --git a/src/plugins/platforms/windows/qwindowstheme.cpp b/src/plugins/platforms/windows/qwindowstheme.cpp
index 6fba9e55c1..64b38c594a 100644
--- a/src/plugins/platforms/windows/qwindowstheme.cpp
+++ b/src/plugins/platforms/windows/qwindowstheme.cpp
@@ -39,6 +39,7 @@
 #include <private/qsystemlibrary_p.h>
 #include <private/qwinregistry_p.h>
 #include <QtCore/private/qfunctions_win_p.h>
+#include <QtCore/qoperatingsystemversion.h>
 
 #include <algorithm>
 
@@ -232,11 +233,12 @@ void QWindowsTheme::populateLightSystemBasePalette(QPalette &result)
     QColor accent = getSysColor(COLOR_HIGHLIGHT);
 
 #if QT_CONFIG(cpp_winrt)
-    // respect the Windows 11 accent color
-    using namespace winrt::Windows::UI::ViewManagement;
-    const auto settings = UISettings();
-
-    accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
+    if (QOperatingSystemVersion::isWin10RS5OrGreater()) {
+        // respect the Windows 11 accent color
+        using namespace winrt::Windows::UI::ViewManagement;
+        const auto settings = UISettings();
+        accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
+    }
 #endif
 
     const QColor btnFace = background;
@@ -271,41 +273,62 @@ void QWindowsTheme::populateLightSystemBasePalette(QPalette &result)
 
 static void populateDarkSystemBasePalette(QPalette &result)
 {
+    QColor foreground;
+    QColor background;
+    QColor accent;
+    QColor accentDark;
+    QColor accentDarker;
+    QColor accentDarkest;
+    QColor accentLight;
+    QColor accentLighter;
+    QColor accentLightest;
+    QColor linkColor;
+
+    bool colorSet = false;
+
 #if QT_CONFIG(cpp_winrt)
-    using namespace winrt::Windows::UI::ViewManagement;
-    const auto settings = UISettings();
-
-    // We have to craft a palette from these colors. The settings.UIElementColor(UIElementType) API
-    // returns the old system colors, not the dark mode colors. If the background is black (which it
-    // usually), then override it with a dark gray instead so that we can go up and down the lightness.
-    const QColor foreground = getSysColor(settings.GetColorValue(UIColorType::Foreground));
-    const QColor background = [&settings]() -> QColor {
-        auto systemBackground = getSysColor(settings.GetColorValue(UIColorType::Background));
-        if (systemBackground == Qt::black)
-            systemBackground = QColor(0x1E, 0x1E, 0x1E);
-        return systemBackground;
-    }();
-
-    const QColor accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
-    const QColor accentDark = getSysColor(settings.GetColorValue(UIColorType::AccentDark1));
-    const QColor accentDarker = getSysColor(settings.GetColorValue(UIColorType::AccentDark2));
-    const QColor accentDarkest = getSysColor(settings.GetColorValue(UIColorType::AccentDark3));
-    const QColor accentLight = getSysColor(settings.GetColorValue(UIColorType::AccentLight1));
-    const QColor accentLighter = getSysColor(settings.GetColorValue(UIColorType::AccentLight2));
-    const QColor accentLightest = getSysColor(settings.GetColorValue(UIColorType::AccentLight3));
-    const QColor linkColor = accent;
-#else
-    const QColor foreground = Qt::white;
-    const QColor background = QColor(0x1E, 0x1E, 0x1E);
-    const QColor accent = QColor(0x00, 0x55, 0xff);
-    const QColor accentDark = accent.darker(120);
-    const QColor accentDarker = accentDark.darker(120);
-    const QColor accentDarkest = accentDarker.darker(120);
-    const QColor accentLight = accent.lighter(120);
-    const QColor accentLighter = accentLight.lighter(120);
-    const QColor accentLightest = accentLighter.lighter(120);
-    const QColor linkColor = Qt::blue;
+    if (QOperatingSystemVersion::isWin10RS5OrGreater()) {
+        using namespace winrt::Windows::UI::ViewManagement;
+        const auto settings = UISettings();
+
+        // We have to craft a palette from these colors. The settings.UIElementColor(UIElementType) API
+        // returns the old system colors, not the dark mode colors. If the background is black (which it
+        // usually), then override it with a dark gray instead so that we can go up and down the lightness.
+        foreground = getSysColor(settings.GetColorValue(UIColorType::Foreground));
+        background = [&settings]() -> QColor {
+            auto systemBackground = getSysColor(settings.GetColorValue(UIColorType::Background));
+            if (systemBackground == Qt::black)
+                systemBackground = QColor(0x1E, 0x1E, 0x1E);
+            return systemBackground;
+        }();
+
+        accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
+        accentDark = getSysColor(settings.GetColorValue(UIColorType::AccentDark1));
+        accentDarker = getSysColor(settings.GetColorValue(UIColorType::AccentDark2));
+        accentDarkest = getSysColor(settings.GetColorValue(UIColorType::AccentDark3));
+        accentLight = getSysColor(settings.GetColorValue(UIColorType::AccentLight1));
+        accentLighter = getSysColor(settings.GetColorValue(UIColorType::AccentLight2));
+        accentLightest = getSysColor(settings.GetColorValue(UIColorType::AccentLight3));
+        linkColor = accent;
+
+        colorSet = true;
+    }
 #endif
+
+    if (!colorSet) {
+        foreground = Qt::white;
+        background = QColor(0x1E, 0x1E, 0x1E);
+        accent = QColor(0x00, 0x55, 0xff);
+        accentDark = accent.darker(120);
+        accentDarker = accentDark.darker(120);
+        accentDarkest = accentDarker.darker(120);
+        accentLight = accent.lighter(120);
+        accentLighter = accentLight.lighter(120);
+        accentLightest = accentLighter.lighter(120);
+        linkColor = Qt::blue;
+        colorSet = true;
+    }
+
     const QColor buttonColor = background.lighter(200);
 
     result.setColor(QPalette::All, QPalette::WindowText, foreground);
@@ -561,25 +584,31 @@ void QWindowsTheme::refreshPalettes()
     m_palettes[MenuPalette] = new QPalette(menuPalette(*m_palettes[SystemPalette], light));
     m_palettes[MenuBarPalette] = menuBarPalette(*m_palettes[MenuPalette], light);
     if (!light) {
+        bool colorSet = false;
 #if QT_CONFIG(cpp_winrt)
-        using namespace winrt::Windows::UI::ViewManagement;
-        const auto settings = UISettings();
-        const QColor accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
-        const QColor accentLight = getSysColor(settings.GetColorValue(UIColorType::AccentLight1));
-        const QColor accentDarkest = getSysColor(settings.GetColorValue(UIColorType::AccentDark3));
-        m_palettes[CheckBoxPalette] = new QPalette(*m_palettes[SystemPalette]);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::Active, QPalette::Base, accent);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::Active, QPalette::Button, accentLight);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::Inactive, QPalette::Base, accentDarkest);
-#else
-        m_palettes[ButtonPalette] = new QPalette(*m_palettes[SystemPalette]);
-        m_palettes[ButtonPalette]->setColor(QPalette::Button, QColor(0x666666u));
-        const QColor checkBoxBlue(0x0078d7u);
-        m_palettes[CheckBoxPalette] = new QPalette(*m_palettes[SystemPalette]);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::Base, checkBoxBlue);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::Button, checkBoxBlue);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::ButtonText, Qt::white);
+        if (QOperatingSystemVersion::isWin10RS5OrGreater()) {
+            using namespace winrt::Windows::UI::ViewManagement;
+            const auto settings = UISettings();
+            const QColor accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
+            const QColor accentLight = getSysColor(settings.GetColorValue(UIColorType::AccentLight1));
+            const QColor accentDarkest = getSysColor(settings.GetColorValue(UIColorType::AccentDark3));
+            m_palettes[CheckBoxPalette] = new QPalette(*m_palettes[SystemPalette]);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::Active, QPalette::Base, accent);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::Active, QPalette::Button, accentLight);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::Inactive, QPalette::Base, accentDarkest);
+            colorSet = true;
+        }
 #endif
+        if (!colorSet) {
+            m_palettes[ButtonPalette] = new QPalette(*m_palettes[SystemPalette]);
+            m_palettes[ButtonPalette]->setColor(QPalette::Button, QColor(0x666666u));
+            const QColor checkBoxBlue(0x0078d7u);
+            m_palettes[CheckBoxPalette] = new QPalette(*m_palettes[SystemPalette]);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::Base, checkBoxBlue);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::Button, checkBoxBlue);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::ButtonText, Qt::white);
+            colorSet = true;
+        }
         m_palettes[RadioButtonPalette] = new QPalette(*m_palettes[CheckBoxPalette]);
     }
 }
@@ -637,7 +666,10 @@ void QWindowsTheme::refreshFonts()
     fixedFont.setStyleHint(QFont::TypeWriter);
 
     LOGFONT lfIconTitleFont;
-    SystemParametersInfoForDpi(SPI_GETICONTITLELOGFONT, sizeof(lfIconTitleFont), &lfIconTitleFont, 0, dpi);
+    if (QWindowsApi::instance()->pSystemParametersInfoForDpi)
+        QWindowsApi::instance()->pSystemParametersInfoForDpi(SPI_GETICONTITLELOGFONT, sizeof(lfIconTitleFont), &lfIconTitleFont, 0, dpi);
+    else
+        SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lfIconTitleFont), &lfIconTitleFont, 0);
     const QFont iconTitleFont = QWindowsFontDatabase::LOGFONT_to_QFont(lfIconTitleFont, dpi);
 
     m_fonts[SystemFont] = new QFont(QWindowsFontDatabase::systemDefaultFont());
@@ -1070,7 +1102,7 @@ bool QWindowsTheme::useNativeMenus()
 
 bool QWindowsTheme::queryDarkMode()
 {
-    if (queryHighContrast()) {
+    if (!QOperatingSystemVersion::isWin10RS5OrGreater() || queryHighContrast()) {
         return false;
     }
     const auto setting = QWinRegistryKey(HKEY_CURRENT_USER, LR"(Software\Microsoft\Windows\CurrentVersion\Themes\Personalize)")
diff --git a/src/plugins/platforms/windows/qwindowswindow.cpp b/src/plugins/platforms/windows/qwindowswindow.cpp
index 7e3be1c0c3..eeea302cf3 100644
--- a/src/plugins/platforms/windows/qwindowswindow.cpp
+++ b/src/plugins/platforms/windows/qwindowswindow.cpp
@@ -22,6 +22,7 @@
 #  include "qwindowscursor.h"
 #endif
 
+#include <QtCore/qoperatingsystemversion.h>
 #include <QtGui/qguiapplication.h>
 #include <QtGui/qscreen.h>
 #include <QtGui/qwindow.h>
@@ -53,6 +54,36 @@ enum {
     defaultWindowHeight = 160
 };
 
+struct QtDwmApis
+{
+    decltype(&::DwmIsCompositionEnabled) pDwmIsCompositionEnabled = nullptr;
+    decltype(&::DwmEnableBlurBehindWindow) pDwmEnableBlurBehindWindow = nullptr;
+    decltype(&::DwmGetWindowAttribute) pDwmGetWindowAttribute = nullptr;
+    decltype(&::DwmSetWindowAttribute) pDwmSetWindowAttribute = nullptr;
+
+    explicit QtDwmApis()
+    {
+        QSystemLibrary dwmapi(u"dwmapi"_s);
+        pDwmIsCompositionEnabled = reinterpret_cast<decltype(pDwmIsCompositionEnabled)>(dwmapi.resolve("DwmIsCompositionEnabled"));
+        pDwmEnableBlurBehindWindow = reinterpret_cast<decltype(pDwmEnableBlurBehindWindow)>(dwmapi.resolve("DwmEnableBlurBehindWindow"));
+        pDwmGetWindowAttribute = reinterpret_cast<decltype(pDwmGetWindowAttribute)>(dwmapi.resolve("DwmGetWindowAttribute"));
+        pDwmSetWindowAttribute = reinterpret_cast<decltype(pDwmSetWindowAttribute)>(dwmapi.resolve("DwmSetWindowAttribute"));
+    }
+
+    ~QtDwmApis() = default;
+
+    [[nodiscard]] static QtDwmApis *instance()
+    {
+        static QtDwmApis inst;
+        return &inst;
+    }
+
+    [[nodiscard]] bool isDwmAvailable() const
+    {
+        return pDwmIsCompositionEnabled && pDwmEnableBlurBehindWindow && pDwmGetWindowAttribute && pDwmSetWindowAttribute;
+    }
+};
+
 Q_GUI_EXPORT HICON qt_pixmapToWinHICON(const QPixmap &);
 
 static QByteArray debugWinStyle(DWORD style)
@@ -442,15 +473,34 @@ static inline bool windowIsAccelerated(const QWindow *w)
     }
 }
 
+static bool dwmIsCompositionEnabled()
+{
+    // DWM composition is always enabled and can't be disabled since Win8.
+    if (QOperatingSystemVersion::isWin8OrGreater())
+        return true;
+    if (!QtDwmApis::instance()->isDwmAvailable())
+        return false;
+    BOOL enabled = FALSE;
+    return SUCCEEDED(QtDwmApis::instance()->pDwmIsCompositionEnabled(&enabled)) && enabled != FALSE;
+}
+
 static bool applyBlurBehindWindow(HWND hwnd)
 {
+    if (!QtDwmApis::instance()->isDwmAvailable())
+        return false;
+
     DWM_BLURBEHIND blurBehind = {0, 0, nullptr, 0};
 
-    blurBehind.dwFlags = DWM_BB_ENABLE | DWM_BB_BLURREGION;
-    blurBehind.fEnable = TRUE;
-    blurBehind.hRgnBlur = CreateRectRgn(0, 0, -1, -1);
+    if (dwmIsCompositionEnabled()) {
+        blurBehind.dwFlags = DWM_BB_ENABLE | DWM_BB_BLURREGION;
+        blurBehind.fEnable = TRUE;
+        blurBehind.hRgnBlur = CreateRectRgn(0, 0, -1, -1);
+    } else {
+        blurBehind.dwFlags = DWM_BB_ENABLE;
+        blurBehind.fEnable = FALSE;
+    }
 
-    const bool result = DwmEnableBlurBehindWindow(hwnd, &blurBehind) == S_OK;
+    const bool result = QtDwmApis::instance()->pDwmEnableBlurBehindWindow(hwnd, &blurBehind) == S_OK;
 
     if (blurBehind.hRgnBlur)
         DeleteObject(blurBehind.hRgnBlur);
@@ -515,15 +565,6 @@ static inline void updateGLWindowSettings(const QWindow *w, HWND hwnd, Qt::Windo
     setWindowOpacity(hwnd, flags, hasAlpha, isAccelerated, opacity);
 }
 
-[[nodiscard]] static inline int getResizeBorderThickness(const UINT dpi)
-{
-    // The width of the padded border will always be 0 if DWM composition is
-    // disabled, but since it will always be enabled and can't be programtically
-    // disabled from Windows 8, we are safe to go.
-    return GetSystemMetricsForDpi(SM_CXSIZEFRAME, dpi)
-           + GetSystemMetricsForDpi(SM_CXPADDEDBORDER, dpi);
-}
-
 /*!
     Calculates the dimensions of the invisible borders within the
     window frames which only exist on Windows 10 and onwards.
@@ -531,22 +572,21 @@ static inline void updateGLWindowSettings(const QWindow *w, HWND hwnd, Qt::Windo
 
 static QMargins invisibleMargins(QPoint screenPoint)
 {
+    if (!QOperatingSystemVersion::isWin10OrGreater())
+        return QMargins();
     POINT pt = {screenPoint.x(), screenPoint.y()};
     if (HMONITOR hMonitor = MonitorFromPoint(pt, MONITOR_DEFAULTTONULL)) {
-        UINT dpiX;
-        UINT dpiY;
-        if (SUCCEEDED(GetDpiForMonitor(hMonitor, MDT_EFFECTIVE_DPI, &dpiX, &dpiY))) {
-            const int gap = getResizeBorderThickness(dpiX);
-            return QMargins(gap, 0, gap, gap);
-        }
+        const int gap = QWindowsContext::getResizeBorderThickness(hMonitor);
+        return QMargins(gap, 0, gap, gap);
     }
     return QMargins();
 }
 
 [[nodiscard]] static inline QMargins invisibleMargins(const HWND hwnd)
 {
-    const UINT dpi = GetDpiForWindow(hwnd);
-    const int gap = getResizeBorderThickness(dpi);
+    if (!QOperatingSystemVersion::isWin10OrGreater())
+        return QMargins();
+    const int gap = QWindowsContext::getResizeBorderThickness(hwnd);
     return QMargins(gap, 0, gap, gap);
 }
 
@@ -786,10 +826,8 @@ void WindowCreationData::fromWindow(const QWindow *w, const Qt::WindowFlags flag
     } else if (topLevel) {
         if (flags & Qt::FramelessWindowHint)
             style = WS_POPUP;                // no border
-        else if (flags & Qt::WindowTitleHint)
-            style = WS_OVERLAPPED;
         else
-            style = 0;
+            style = WS_OVERLAPPED;
     } else {
         style = WS_CHILD;
     }
@@ -806,7 +844,6 @@ void WindowCreationData::fromWindow(const QWindow *w, const Qt::WindowFlags flag
     if (topLevel) {
         if ((type == Qt::Window || dialog || tool)) {
             if (!(flags & Qt::FramelessWindowHint)) {
-                style |= WS_POPUP;
                 if (flags & Qt::MSWindowsFixedSizeDialogHint) {
                     style |= WS_DLGFRAME;
                 } else {
@@ -834,13 +871,17 @@ void WindowCreationData::fromWindow(const QWindow *w, const Qt::WindowFlags flag
             if ((flags & Qt::WindowContextHelpButtonHint) && !showMinimizeButton
                 && !showMaximizeButton)
                 exStyle |= WS_EX_CONTEXTHELP;
+            if (qEnvironmentVariableIntValue("QT_WINDOWS_DISABLE_BITMAP_REDIRECTION")
+                    && QOperatingSystemVersion::isWin8OrGreater()) {
+                exStyle |= WS_EX_NOREDIRECTIONBITMAP;
+            }
         } else {
              exStyle |= WS_EX_TOOLWINDOW;
         }
 
         // make mouse events fall through this window
         // NOTE: WS_EX_TRANSPARENT flag can make mouse inputs fall through a layered window
-        if (flagsIn & Qt::WindowTransparentForInput)
+        if (flags & Qt::WindowTransparentForInput)
             exStyle |= WS_EX_LAYERED | WS_EX_TRANSPARENT;
     }
 }
@@ -1052,9 +1093,12 @@ QMargins QWindowsGeometryHint::frame(const QWindow *w, DWORD style, DWORD exStyl
 {
     if (!w->isTopLevel() || w->flags().testFlag(Qt::FramelessWindowHint))
         return {};
+    if (!QWindowsApi::instance()->pAdjustWindowRectExForDpi)
+        return frameOnPrimaryScreen(w, style, exStyle);
     RECT rect = {0,0,0,0};
     style &= ~DWORD(WS_OVERLAPPED); // Not permitted, see docs.
-    if (AdjustWindowRectExForDpi(&rect, style, FALSE, exStyle, unsigned(qRound(dpi))) == FALSE) {
+    if (QWindowsApi::instance()->pAdjustWindowRectExForDpi(
+            &rect, style, FALSE, exStyle, unsigned(qRound(dpi))) == FALSE) {
         qErrnoWarning("%s: AdjustWindowRectExForDpi failed", __FUNCTION__);
     }
     const QMargins result(qAbs(rect.left), qAbs(rect.top),
@@ -1094,7 +1138,8 @@ QMargins QWindowsGeometryHint::frame(const QWindow *w, const QRect &geometry,
 {
     if (!w->isTopLevel() || w->flags().testFlag(Qt::FramelessWindowHint))
         return {};
-    if (QWindowsScreenManager::isSingleScreen()
+    if (!QWindowsApi::instance()->pAdjustWindowRectExForDpi
+        || QWindowsScreenManager::isSingleScreen()
         || !QWindowsContext::shouldHaveNonClientDpiScaling(w)) {
         return frameOnPrimaryScreen(w, style, exStyle);
     }
@@ -1249,10 +1294,12 @@ QMargins QWindowsBaseWindow::frameMargins_sys() const
 std::optional<QWindowsBaseWindow::TouchWindowTouchTypes>
     QWindowsBaseWindow::touchWindowTouchTypes_sys() const
 {
+    if (!QWindowsApi::instance()->pIsTouchWindow)
+        return std::nullopt;
     ULONG touchFlags = 0;
-    if (IsTouchWindow(handle(), &touchFlags) == FALSE)
-        return {};
-    TouchWindowTouchTypes result;
+    if (QWindowsApi::instance()->pIsTouchWindow(handle(), &touchFlags) == FALSE)
+        return std::nullopt;
+    TouchWindowTouchTypes result = {};
     if ((touchFlags & TWF_FINETOUCH) != 0)
         result.setFlag(TouchWindowTouchType::FineTouch);
     if ((touchFlags & TWF_WANTPALM) != 0)
@@ -1520,8 +1567,8 @@ QWindowsWindow::QWindowsWindow(QWindow *aWindow, const QWindowsWindowData &data)
 QWindowsWindow::~QWindowsWindow()
 {
     setFlag(WithinDestroy);
-    if (testFlag(TouchRegistered))
-        UnregisterTouchWindow(m_data.hwnd);
+    if (testFlag(TouchRegistered) && QWindowsApi::instance()->pUnregisterTouchWindow)
+        QWindowsApi::instance()->pUnregisterTouchWindow(m_data.hwnd);
     destroyWindow();
     destroyIcon();
 }
@@ -1548,7 +1595,7 @@ void QWindowsWindow::initialize()
             QWindowSystemInterface::handleGeometryChange<QWindowSystemInterface::SynchronousDelivery>(w, obtainedGeometry);
         }
     }
-    QWindowsWindow::setSavedDpi(GetDpiForWindow(handle()));
+    QWindowsWindow::setSavedDpi(QWindowsContext::getMostPossibleDpiForWindow(handle()));
 }
 
 QSurfaceFormat QWindowsWindow::format() const
@@ -2022,7 +2069,7 @@ void QWindowsWindow::handleDpiChanged(HWND hwnd, WPARAM wParam, LPARAM lParam)
 
 void QWindowsWindow::handleDpiChangedAfterParent(HWND hwnd)
 {
-    const UINT dpi = GetDpiForWindow(hwnd);
+    const UINT dpi = QWindowsContext::getMostPossibleDpiForWindow(hwnd);
     const qreal scale = qreal(dpi) / qreal(savedDpi());
     setSavedDpi(dpi);
 
@@ -2342,13 +2389,22 @@ bool QWindowsWindow::handleWmPaint(HWND hwnd, UINT message,
         return false;
     PAINTSTRUCT ps;
 
-    // GL software rendering (QTBUG-58178) with some AMD cards
+    // GL software rendering (QTBUG-58178) and Windows 7/Aero off with some AMD cards
     // (QTBUG-60527) need InvalidateRect() to suppress artifacts while resizing.
-    if (testFlag(OpenGLSurface) && isSoftwareGl())
+    if (testFlag(OpenGLSurface) && (isSoftwareGl() || !dwmIsCompositionEnabled()))
         InvalidateRect(hwnd, nullptr, false);
 
     BeginPaint(hwnd, &ps);
 
+    // Observed painting problems with Aero style disabled (QTBUG-7865).
+    if (Q_UNLIKELY(!dwmIsCompositionEnabled())
+        && ((testFlag(OpenGLSurface) && testFlag(OpenGLDoubleBuffered))
+            || testFlag(VulkanSurface)
+            || testFlag(Direct3DSurface)))
+    {
+        SelectClipRgn(ps.hdc, nullptr);
+    }
+
     // If the a window is obscured by another window (such as a child window)
     // we still need to send isExposed=true, for compatibility.
     // Our tests depend on it.
@@ -2988,7 +3044,7 @@ bool QWindowsWindow::handleNonClientHitTest(const QPoint &globalPos, LRESULT *re
             return true;
         }
         if (localPos.y() < 0) {
-            const int topResizeBarPos = invisibleMargins(m_data.hwnd).left() - frameMargins().top();
+            const int topResizeBarPos = QWindowsContext::getResizeBorderThickness(m_data.hwnd) - frameMargins().top();
             if (localPos.y() < topResizeBarPos) {
                 *result = HTCAPTION; // Extend caption over top resize bar, let's user move the window.
                 return true;
@@ -3178,10 +3234,12 @@ enum : WORD {
 
 static bool queryDarkBorder(HWND hwnd)
 {
+    if (!QtDwmApis::instance()->isDwmAvailable())
+        return false;
     BOOL result = FALSE;
     const bool ok =
-        SUCCEEDED(DwmGetWindowAttribute(hwnd, DwmwaUseImmersiveDarkMode, &result, sizeof(result)))
-        || SUCCEEDED(DwmGetWindowAttribute(hwnd, DwmwaUseImmersiveDarkModeBefore20h1, &result, sizeof(result)));
+        SUCCEEDED(QtDwmApis::instance()->pDwmGetWindowAttribute(hwnd, DwmwaUseImmersiveDarkMode, &result, sizeof(result)))
+        || SUCCEEDED(QtDwmApis::instance()->pDwmGetWindowAttribute(hwnd, DwmwaUseImmersiveDarkModeBefore20h1, &result, sizeof(result)));
     if (!ok)
         qCWarning(lcQpaWindow, "%s: Unable to retrieve dark window border setting.", __FUNCTION__);
     return result == TRUE;
@@ -3189,10 +3247,12 @@ static bool queryDarkBorder(HWND hwnd)
 
 bool QWindowsWindow::setDarkBorderToWindow(HWND hwnd, bool d)
 {
+    if (!QtDwmApis::instance()->isDwmAvailable())
+        return false;
     const BOOL darkBorder = d ? TRUE : FALSE;
     const bool ok =
-        SUCCEEDED(DwmSetWindowAttribute(hwnd, DwmwaUseImmersiveDarkMode, &darkBorder, sizeof(darkBorder)))
-        || SUCCEEDED(DwmSetWindowAttribute(hwnd, DwmwaUseImmersiveDarkModeBefore20h1, &darkBorder, sizeof(darkBorder)));
+        SUCCEEDED(QtDwmApis::instance()->pDwmSetWindowAttribute(hwnd, DwmwaUseImmersiveDarkMode, &darkBorder, sizeof(darkBorder)))
+        || SUCCEEDED(QtDwmApis::instance()->pDwmSetWindowAttribute(hwnd, DwmwaUseImmersiveDarkModeBefore20h1, &darkBorder, sizeof(darkBorder)));
     if (!ok)
         qCWarning(lcQpaWindow, "%s: Unable to set %s window border.", __FUNCTION__, d ? "dark" : "light");
     return ok;
@@ -3313,6 +3373,9 @@ void QWindowsWindow::registerTouchWindow()
     if ((QWindowsContext::instance()->systemInfo() & QWindowsContext::SI_SupportsTouch) == 0)
         return;
 
+    if (!QWindowsApi::instance()->pRegisterTouchWindow)
+        return;
+
     // Initially register or re-register to change the flags
     const auto touchTypes = QWindowsIntegration::instance()->touchWindowTouchType();
     if (testFlag(TouchRegistered)) {
@@ -3326,7 +3389,7 @@ void QWindowsWindow::registerTouchWindow()
         touchFlags |= TWF_FINETOUCH;
     if (touchTypes.testFlag(TouchWindowTouchType::WantPalmTouch))
         touchFlags |= TWF_WANTPALM;
-    if (RegisterTouchWindow(m_data.hwnd, touchFlags))
+    if (QWindowsApi::instance()->pRegisterTouchWindow(m_data.hwnd, touchFlags))
         setFlag(TouchRegistered);
     else
         qErrnoWarning("RegisterTouchWindow() failed for window '%s'.", qPrintable(window()->objectName()));
diff --git a/src/plugins/platforms/windows/uiautomation/qwindowsuiaaccessibility.cpp b/src/plugins/platforms/windows/uiautomation/qwindowsuiaaccessibility.cpp
index 001cb8505b..3b8ecef292 100644
--- a/src/plugins/platforms/windows/uiautomation/qwindowsuiaaccessibility.cpp
+++ b/src/plugins/platforms/windows/uiautomation/qwindowsuiaaccessibility.cpp
@@ -14,7 +14,6 @@
 #include <QtGui/private/qguiapplication_p.h>
 #include <QtCore/qt_windows.h>
 #include <qpa/qplatformintegration.h>
-#include <QtGui/private/qwindowsuiawrapper_p.h>
 
 #include <QtCore/private/qwinregistry_p.h>
 
@@ -46,7 +45,7 @@ bool QWindowsUiaAccessibility::handleWmGetObject(HWND hwnd, WPARAM wParam, LPARA
     if (QWindow *window = QWindowsContext::instance()->findWindow(hwnd)) {
         if (QAccessibleInterface *accessible = window->accessibleRoot()) {
             QWindowsUiaMainProvider *provider = QWindowsUiaMainProvider::providerForAccessible(accessible);
-            *lResult = QWindowsUiaWrapper::instance()->returnRawElementProvider(hwnd, wParam, lParam, provider);
+            *lResult = UiaReturnRawElementProvider(hwnd, wParam, lParam, provider);
             return true;
         }
     }
@@ -120,12 +119,8 @@ void QWindowsUiaAccessibility::notifyAccessibilityUpdate(QAccessibleEvent *event
     if (!isActive() || !accessible || !accessible->isValid())
         return;
 
-    // Ensures QWindowsUiaWrapper is properly initialized.
-    if (!QWindowsUiaWrapper::instance()->ready())
-        return;
-
     // No need to do anything when nobody is listening.
-    if (!QWindowsUiaWrapper::instance()->clientsAreListening())
+    if (!UiaClientsAreListening())
         return;
 
     switch (event->type()) {
diff --git a/src/plugins/platforms/windows/uiautomation/qwindowsuiabaseprovider.h b/src/plugins/platforms/windows/uiautomation/qwindowsuiabaseprovider.h
index c899b4096e..2bc549f548 100644
--- a/src/plugins/platforms/windows/uiautomation/qwindowsuiabaseprovider.h
+++ b/src/plugins/platforms/windows/uiautomation/qwindowsuiabaseprovider.h
@@ -11,7 +11,9 @@
 #include <QtCore/qpointer.h>
 
 #include <qwindowscombase.h>
-#include <QtGui/private/qwindowsuiawrapper_p.h>
+#include <uiautomationcore.h>
+#include <uiautomationcoreapi.h>
+#include <uiautomationclient.h>
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/plugins/platforms/windows/uiautomation/qwindowsuiamainprovider.cpp b/src/plugins/platforms/windows/uiautomation/qwindowsuiamainprovider.cpp
index cb35ed398c..d7bcf147b9 100644
--- a/src/plugins/platforms/windows/uiautomation/qwindowsuiamainprovider.cpp
+++ b/src/plugins/platforms/windows/uiautomation/qwindowsuiamainprovider.cpp
@@ -24,6 +24,8 @@
 #include "qwindowsuiaprovidercache.h"
 
 #include <QtCore/qloggingcategory.h>
+#include <QtCore/qoperatingsystemversion.h>
+#include <QtCore/private/qsystemlibrary_p.h>
 #include <QtGui/qaccessible.h>
 #include <QtGui/qguiapplication.h>
 #include <QtGui/qwindow.h>
@@ -36,6 +38,8 @@
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
 using namespace QWindowsUiAutomation;
 
 
@@ -77,7 +81,7 @@ void QWindowsUiaMainProvider::notifyFocusChange(QAccessibleEvent *event)
                 accessible = child;
         }
         if (QWindowsUiaMainProvider *provider = providerForAccessible(accessible))
-            QWindowsUiaWrapper::instance()->raiseAutomationEvent(provider, UIA_AutomationFocusChangedEventId);
+            UiaRaiseAutomationEvent(provider, UIA_AutomationFocusChangedEventId);
     }
 }
 
@@ -94,7 +98,7 @@ void QWindowsUiaMainProvider::notifyStateChange(QAccessibleStateChangeEvent *eve
                     if (accessible->state().checked)
                         toggleState = accessible->state().checkStateMixed ? ToggleState_Indeterminate : ToggleState_On;
                     setVariantI4(toggleState, &newVal);
-                    QWindowsUiaWrapper::instance()->raiseAutomationPropertyChangedEvent(provider, UIA_ToggleToggleStatePropertyId, oldVal, newVal);
+                    UiaRaiseAutomationPropertyChangedEvent(provider, UIA_ToggleToggleStatePropertyId, oldVal, newVal);
                 }
             }
         }
@@ -103,13 +107,13 @@ void QWindowsUiaMainProvider::notifyStateChange(QAccessibleStateChangeEvent *eve
                 // Notifies window opened/closed.
                 if (QWindowsUiaMainProvider *provider = providerForAccessible(accessible)) {
                     if (accessible->state().active) {
-                        QWindowsUiaWrapper::instance()->raiseAutomationEvent(provider, UIA_Window_WindowOpenedEventId);
+                        UiaRaiseAutomationEvent(provider, UIA_Window_WindowOpenedEventId);
                         if (QAccessibleInterface *focused = accessible->focusChild()) {
                             if (QWindowsUiaMainProvider *focusedProvider = providerForAccessible(focused))
-                                QWindowsUiaWrapper::instance()->raiseAutomationEvent(focusedProvider, UIA_AutomationFocusChangedEventId);
+                                UiaRaiseAutomationEvent(focusedProvider, UIA_AutomationFocusChangedEventId);
                         }
                     } else {
-                        QWindowsUiaWrapper::instance()->raiseAutomationEvent(provider, UIA_Window_WindowClosedEventId);
+                        UiaRaiseAutomationEvent(provider, UIA_Window_WindowClosedEventId);
                     }
                 }
             }
@@ -142,21 +146,30 @@ void QWindowsUiaMainProvider::notifyValueChange(QAccessibleValueChangeEvent *eve
                 // Tries to notify the change using UiaRaiseNotificationEvent(), which is only available on
                 // Windows 10 version 1709 or newer. Otherwise uses UiaRaiseAutomationPropertyChangedEvent().
 
-                BSTR displayString = bStrFromQString(event->value().toString());
-                BSTR activityId = bStrFromQString(QString());
+                auto hr = HRESULT(UIA_E_NOTSUPPORTED);
+
+                if (QOperatingSystemVersion::isWin10RS3OrGreater()) {
+                    static const auto pUiaRaiseNotificationEvent =
+                        reinterpret_cast<decltype(&::UiaRaiseNotificationEvent)>(
+                            QSystemLibrary::resolve(u"uiautomationcore"_s, "UiaRaiseNotificationEvent"));
+                    if (pUiaRaiseNotificationEvent) {
+                        BSTR displayString = bStrFromQString(event->value().toString());
+                        BSTR activityId = bStrFromQString(QString());
 
-                HRESULT hr = QWindowsUiaWrapper::instance()->raiseNotificationEvent(provider, NotificationKind_Other,
-                                                                                    NotificationProcessing_ImportantMostRecent,
-                                                                                    displayString, activityId);
+                        hr = pUiaRaiseNotificationEvent(provider, NotificationKind_Other,
+                                                        NotificationProcessing_ImportantMostRecent,
+                                                        displayString, activityId);
 
-                ::SysFreeString(displayString);
-                ::SysFreeString(activityId);
+                        ::SysFreeString(displayString);
+                        ::SysFreeString(activityId);
+                    }
+                }
 
                 if (hr == static_cast<HRESULT>(UIA_E_NOTSUPPORTED)) {
                     VARIANT oldVal, newVal;
                     clearVariant(&oldVal);
                     setVariantString(event->value().toString(), &newVal);
-                    QWindowsUiaWrapper::instance()->raiseAutomationPropertyChangedEvent(provider, UIA_ValueValuePropertyId, oldVal, newVal);
+                    UiaRaiseAutomationPropertyChangedEvent(provider, UIA_ValueValuePropertyId, oldVal, newVal);
                     ::SysFreeString(newVal.bstrVal);
                 }
             }
@@ -166,7 +179,7 @@ void QWindowsUiaMainProvider::notifyValueChange(QAccessibleValueChangeEvent *eve
                 VARIANT oldVal, newVal;
                 clearVariant(&oldVal);
                 setVariantDouble(valueInterface->currentValue().toDouble(), &newVal);
-                QWindowsUiaWrapper::instance()->raiseAutomationPropertyChangedEvent(provider, UIA_RangeValueValuePropertyId, oldVal, newVal);
+                UiaRaiseAutomationPropertyChangedEvent(provider, UIA_RangeValueValuePropertyId, oldVal, newVal);
             }
         }
     }
@@ -182,7 +195,7 @@ void QWindowsUiaMainProvider::notifyNameChange(QAccessibleEvent *event)
                 VARIANT oldVal, newVal;
                 clearVariant(&oldVal);
                 setVariantString(accessible->text(QAccessible::Name), &newVal);
-                QWindowsUiaWrapper::instance()->raiseAutomationPropertyChangedEvent(provider, UIA_NamePropertyId, oldVal, newVal);
+                UiaRaiseAutomationPropertyChangedEvent(provider, UIA_NamePropertyId, oldVal, newVal);
                 ::SysFreeString(newVal.bstrVal);
             }
         }
@@ -193,7 +206,7 @@ void QWindowsUiaMainProvider::notifySelectionChange(QAccessibleEvent *event)
 {
     if (QAccessibleInterface *accessible = event->accessibleInterface()) {
         if (QWindowsUiaMainProvider *provider = providerForAccessible(accessible)) {
-            QWindowsUiaWrapper::instance()->raiseAutomationEvent(provider, UIA_SelectionItem_ElementSelectedEventId);
+            UiaRaiseAutomationEvent(provider, UIA_SelectionItem_ElementSelectedEventId);
         }
     }
 }
@@ -205,13 +218,13 @@ void QWindowsUiaMainProvider::notifyTextChange(QAccessibleEvent *event)
         if (accessible->textInterface()) {
             if (QWindowsUiaMainProvider *provider = providerForAccessible(accessible)) {
                 if (event->type() == QAccessible::TextSelectionChanged) {
-                    QWindowsUiaWrapper::instance()->raiseAutomationEvent(provider, UIA_Text_TextSelectionChangedEventId);
+                    UiaRaiseAutomationEvent(provider, UIA_Text_TextSelectionChangedEventId);
                 } else if (event->type() == QAccessible::TextCaretMoved) {
                     if (!accessible->state().readOnly) {
-                        QWindowsUiaWrapper::instance()->raiseAutomationEvent(provider, UIA_Text_TextSelectionChangedEventId);
+                        UiaRaiseAutomationEvent(provider, UIA_Text_TextSelectionChangedEventId);
                     }
                 } else {
-                    QWindowsUiaWrapper::instance()->raiseAutomationEvent(provider, UIA_Text_TextChangedEventId);
+                    UiaRaiseAutomationEvent(provider, UIA_Text_TextChangedEventId);
                 }
             }
         }
@@ -514,7 +527,7 @@ HRESULT QWindowsUiaMainProvider::get_HostRawElementProvider(IRawElementProviderS
     // Returns a host provider only for controls associated with a native window handle. Others should return NULL.
     if (QAccessibleInterface *accessible = accessibleInterface()) {
         if (HWND hwnd = hwndForAccessible(accessible)) {
-            return QWindowsUiaWrapper::instance()->hostProviderFromHwnd(hwnd, pRetVal);
+            return UiaHostProviderFromHwnd(hwnd, pRetVal);
         }
     }
     return S_OK;
diff --git a/src/plugins/platforms/windows/uiautomation/qwindowsuiautils.h b/src/plugins/platforms/windows/uiautomation/qwindowsuiautils.h
index 8fe8b1c6d7..07367efe01 100644
--- a/src/plugins/platforms/windows/uiautomation/qwindowsuiautils.h
+++ b/src/plugins/platforms/windows/uiautomation/qwindowsuiautils.h
@@ -12,7 +12,7 @@
 #include <QtGui/qaccessible.h>
 #include <QtGui/qwindow.h>
 #include <QtCore/qrect.h>
-#include <QtGui/private/qwindowsuiawrapper_p.h>
+#include "qwindowsuiabaseprovider.h"
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/plugins/styles/windowsvista/qwindowsvistastyle.cpp b/src/plugins/styles/windowsvista/qwindowsvistastyle.cpp
index b01402aff4..53d2e11e41 100644
--- a/src/plugins/styles/windowsvista/qwindowsvistastyle.cpp
+++ b/src/plugins/styles/windowsvista/qwindowsvistastyle.cpp
@@ -3953,6 +3953,21 @@ void QWindowsVistaStyle::drawComplexControl(ComplexControl control, const QStyle
                     theme.partId = flags & State_Horizontal ? SBP_THUMBBTNHORZ : SBP_THUMBBTNVERT;
                     theme.stateId = stateId;
                     d->drawBackground(theme);
+
+                    if (!QOperatingSystemVersion::isWin8OrGreater()) {
+                        const QRect gripperBounds = QWindowsVistaStylePrivate::scrollBarGripperBounds(flags, widget, &theme);
+                        // Draw gripper if there is enough space
+                        if (!gripperBounds.isEmpty() && flags & State_Enabled) {
+                            painter->save();
+                            QWindowsThemeData grippBackground = theme;
+                            grippBackground.partId = flags & State_Horizontal ? SBP_LOWERTRACKHORZ : SBP_LOWERTRACKVERT;
+                            theme.rect = gripperBounds;
+                            painter->setClipRegion(d->region(theme));// Only change inside the region of the gripper
+                            d->drawBackground(grippBackground);// The gutter is the grippers background
+                            d->drawBackground(theme);          // Transparent gripper ontop of background
+                            painter->restore();
+                        }
+                    }
                 }
             }
         }
@@ -5043,4 +5058,20 @@ QIcon QWindowsVistaStyle::standardIcon(StandardPixmap standardIcon,
     return QWindowsStyle::standardIcon(standardIcon, option, widget);
 }
 
+QRect QWindowsVistaStylePrivate::scrollBarGripperBounds(QStyle::State flags, const QWidget *widget, QWindowsThemeData *theme)
+{
+    const bool horizontal = flags & QStyle::State_Horizontal;
+    const qreal factor = QWindowsStylePrivate::nativeMetricScaleFactor(widget);
+    const QMargins contentsMargin =
+        (theme->margins(theme->rect, TMT_SIZINGMARGINS) * factor).toMargins();
+    theme->partId = horizontal ? SBP_GRIPPERHORZ : SBP_GRIPPERVERT;
+    const QSize size = (theme->size() * factor).toSize();
+
+    const int hSpace = theme->rect.width() - size.width();
+    const int vSpace = theme->rect.height() - size.height();
+    const bool sufficientSpace = (horizontal && hSpace > (contentsMargin.left() + contentsMargin.right()))
+        || vSpace > contentsMargin.top() + contentsMargin.bottom();
+    return sufficientSpace ? QRect(theme->rect.topLeft() + QPoint(hSpace, vSpace) / 2, size) : QRect();
+}
+
 QT_END_NAMESPACE
diff --git a/src/plugins/styles/windowsvista/qwindowsvistastyle_p_p.h b/src/plugins/styles/windowsvista/qwindowsvistastyle_p_p.h
index 2c38ff4b3b..7705d3200e 100644
--- a/src/plugins/styles/windowsvista/qwindowsvistastyle_p_p.h
+++ b/src/plugins/styles/windowsvista/qwindowsvistastyle_p_p.h
@@ -120,6 +120,7 @@ public:
     static int pixelMetricFromSystemDp(QStyle::PixelMetric pm, const QStyleOption *option = nullptr, const QWidget *widget = nullptr);
     static int fixedPixelMetric(QStyle::PixelMetric pm);
     static bool isLineEditBaseColorSet(const QStyleOption *option, const QWidget *widget);
+    static QRect scrollBarGripperBounds(QStyle::State flags, const QWidget *widget, QWindowsThemeData *theme);
     static HWND winId(const QWidget *widget);
     static bool useVista(bool update = false);
     static QBackingStore *backingStoreForWidget(const QWidget *widget);
diff --git a/src/tools/rcc/main.cpp b/src/tools/rcc/main.cpp
index 2751bc39d6..8e44999f52 100644
--- a/src/tools/rcc/main.cpp
+++ b/src/tools/rcc/main.cpp
@@ -34,9 +34,7 @@ void dumpRecursive(const QDir &dir, QTextStream &out)
         if (entry.isDir()) {
             dumpRecursive(entry.filePath(), out);
         } else {
-            out << "<file>"_L1
-                << entry.filePath()
-                << "</file>\n"_L1;
+            out << "  <file>"_L1 << entry.filePath() << "</file>\n"_L1;
         }
     }
 }
@@ -64,7 +62,8 @@ int createProject(const QString &outFileName)
     }
 
     QTextStream out(&file);
-    out << "<!DOCTYPE RCC><RCC version=\"1.0\">\n"
+    out << "<!DOCTYPE RCC>\n"
+           "<RCC version=\"1.0\">\n"
            "<qresource>\n"_L1;
 
     // use "." as dir to get relative file paths
diff --git a/src/tools/rcc/rcc.cpp b/src/tools/rcc/rcc.cpp
index a87f15de33..51933952a5 100644
--- a/src/tools/rcc/rcc.cpp
+++ b/src/tools/rcc/rcc.cpp
@@ -1097,7 +1097,7 @@ bool RCCResourceLibrary::writeDataBlobs()
     Q_ASSERT(m_errorDevice);
     switch (m_format) {
     case C_Code:
-        writeString("static const unsigned char qt_resource_data[] = {\n");
+        writeString("static constexpr const unsigned char qt_resource_data[] = {\n");
         break;
     case Python_Code:
         writeString("qt_resource_data = b\"\\\n");
@@ -1141,7 +1141,7 @@ bool RCCResourceLibrary::writeDataBlobs()
     case Pass1:
         if (offset < 8)
             offset = 8;
-        writeString("\nstatic const unsigned char qt_resource_data[");
+        writeString("\nstatic constexpr const unsigned char qt_resource_data[");
         writeByteArray(QByteArray::number(offset));
         writeString("] = { 'Q', 'R', 'C', '_', 'D', 'A', 'T', 'A' };\n\n");
         break;
@@ -1156,7 +1156,7 @@ bool RCCResourceLibrary::writeDataNames()
     switch (m_format) {
     case C_Code:
     case Pass1:
-        writeString("static const unsigned char qt_resource_name[] = {\n");
+        writeString("static constexpr const unsigned char qt_resource_name[] = {\n");
         break;
     case Python_Code:
         writeString("qt_resource_name = b\"\\\n");
@@ -1218,7 +1218,7 @@ bool RCCResourceLibrary::writeDataStructure()
     switch (m_format) {
     case C_Code:
     case Pass1:
-        writeString("static const unsigned char qt_resource_struct[] = {\n");
+        writeString("static constexpr const unsigned char qt_resource_struct[] = {\n");
         break;
     case Python_Code:
         writeString("qt_resource_struct = b\"\\\n");
diff --git a/src/widgets/CMakeLists.txt b/src/widgets/CMakeLists.txt
index 417f6a2d8e..bc783425ea 100644
--- a/src/widgets/CMakeLists.txt
+++ b/src/widgets/CMakeLists.txt
@@ -322,7 +322,6 @@ qt_internal_extend_target(Widgets CONDITION MACOS
 
 qt_internal_extend_target(Widgets CONDITION WIN32
     LIBRARIES
-        dwmapi
         shell32
         uxtheme
 )
diff --git a/src/widgets/dialogs/qwizard_win.cpp b/src/widgets/dialogs/qwizard_win.cpp
index e95f0e3b7b..6cc6bb821a 100644
--- a/src/widgets/dialogs/qwizard_win.cpp
+++ b/src/widgets/dialogs/qwizard_win.cpp
@@ -16,6 +16,7 @@
 #include <QtCore/QOperatingSystemVersion>
 #include <QtCore/QVariant>
 #include <QtCore/QDebug>
+#include <QtCore/private/qsystemlibrary_p.h>
 #include <QtGui/QMouseEvent>
 #include <QtGui/QWindow>
 #include <QtGui/private/qhighdpiscaling_p.h>
@@ -33,6 +34,36 @@ Q_DECLARE_METATYPE(QMargins)
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
+struct DwmApis
+{
+    decltype(&::DwmIsCompositionEnabled) pDwmIsCompositionEnabled = nullptr;
+    decltype(&::DwmExtendFrameIntoClientArea) pDwmExtendFrameIntoClientArea = nullptr;
+    decltype(&::DwmDefWindowProc) pDwmDefWindowProc = nullptr;
+
+    explicit DwmApis()
+    {
+        QSystemLibrary dwmapi(u"dwmapi"_s);
+        pDwmIsCompositionEnabled = reinterpret_cast<decltype(pDwmIsCompositionEnabled)>(dwmapi.resolve("DwmIsCompositionEnabled"));
+        pDwmExtendFrameIntoClientArea = reinterpret_cast<decltype(pDwmExtendFrameIntoClientArea)>(dwmapi.resolve("DwmExtendFrameIntoClientArea"));
+        pDwmDefWindowProc = reinterpret_cast<decltype(pDwmDefWindowProc)>(dwmapi.resolve("DwmDefWindowProc"));
+    }
+
+    ~DwmApis() = default;
+
+    [[nodiscard]] bool isDwmAvailable() const
+    {
+        return pDwmIsCompositionEnabled && pDwmExtendFrameIntoClientArea && pDwmDefWindowProc;
+    }
+
+    [[nodiscard]] static DwmApis *instance()
+    {
+        static DwmApis inst;
+        return &inst;
+    }
+};
+
 int QVistaHelper::instanceCount = 0;
 int QVistaHelper::m_devicePixelRatio = 1;
 QVistaHelper::VistaState QVistaHelper::cachedVistaState = QVistaHelper::Dirty;
@@ -152,7 +183,13 @@ void QVistaHelper::updateCustomMargins(bool vistaMargins)
 
 bool QVistaHelper::isCompositionEnabled()
 {
-    return true;
+    // DWM composition is always enabled and can't be disabled since Win8.
+    if (QOperatingSystemVersion::isWin8OrGreater())
+        return true;
+    if (!DwmApis::instance()->isDwmAvailable())
+        return false;
+    BOOL enabled = FALSE;
+    return SUCCEEDED(DwmApis::instance()->pDwmIsCompositionEnabled(&enabled)) && enabled != FALSE;
 }
 
 bool QVistaHelper::isThemeActive()
@@ -188,6 +225,8 @@ QColor QVistaHelper::basicWindowFrameColor()
 
 bool QVistaHelper::setDWMTitleBar(TitleBarChangeType type)
 {
+    if (!DwmApis::instance()->isDwmAvailable())
+        return false;
     bool value = false;
     if (vistaState() == VistaAero) {
         MARGINS mar = {0, 0, 0, 0};
@@ -196,7 +235,7 @@ bool QVistaHelper::setDWMTitleBar(TitleBarChangeType type)
         else
             mar.cyTopHeight = (titleBarSize() + topOffset(wizard)) * QVistaHelper::m_devicePixelRatio;
         if (const HWND wizardHandle = wizardHWND())
-            if (SUCCEEDED(DwmExtendFrameIntoClientArea(wizardHandle, &mar)))
+            if (SUCCEEDED(DwmApis::instance()->pDwmExtendFrameIntoClientArea(wizardHandle, &mar)))
                 value = true;
     }
     return value;
@@ -307,7 +346,9 @@ bool QVistaHelper::winEvent(MSG* msg, qintptr *result)
     case WM_NCHITTEST: {
         LRESULT lResult;
         // Perform hit testing using DWM
-        if (DwmDefWindowProc(msg->hwnd, msg->message, msg->wParam, msg->lParam, &lResult)) {
+        if (DwmApis::instance()->isDwmAvailable() &&
+                DwmApis::instance()->pDwmDefWindowProc(
+                    msg->hwnd, msg->message, msg->wParam, msg->lParam, &lResult)) {
             // DWM returned a hit, no further processing necessary
             *result = lResult;
         } else {
@@ -326,7 +367,9 @@ bool QVistaHelper::winEvent(MSG* msg, qintptr *result)
     default:
         LRESULT lResult;
         // Pass to DWM to handle
-        if (DwmDefWindowProc(msg->hwnd, msg->message, msg->wParam, msg->lParam, &lResult))
+        if (DwmApis::instance()->isDwmAvailable() &&
+                DwmApis::instance()->pDwmDefWindowProc(
+                    msg->hwnd, msg->message, msg->wParam, msg->lParam, &lResult))
             *result = lResult;
         // If the message wasn't handled by DWM, continue processing it as normal
         else
@@ -663,7 +706,9 @@ int QVistaHelper::topOffset(const QPaintDevice *device)
 {
     if (vistaState() != VistaAero)
         return titleBarSize() + 3;
-    static const int aeroOffset = QStyleHelper::dpiScaled(13, device);
+    static const int aeroOffset =
+        QOperatingSystemVersion::isWin8OrGreater() ?
+        QStyleHelper::dpiScaled(13, device) : QStyleHelper::dpiScaled(4, device);
     return aeroOffset + titleBarSize();
 }
 
diff --git a/src/widgets/kernel/qwidget.cpp b/src/widgets/kernel/qwidget.cpp
index a1382a1107..21eb9e6ebf 100644
--- a/src/widgets/kernel/qwidget.cpp
+++ b/src/widgets/kernel/qwidget.cpp
@@ -5130,6 +5130,17 @@ void QWidget::render(QPainter *painter, const QPoint &targetOffset,
         return; // Fully transparent.
 
     Q_D(QWidget);
+
+    // Patch: save and restore dirtyOpaqueChildren field.
+    //
+    // Just like in QWidget::grab() this field should be restored
+    // after the d->render() call, because it will be set to 1 and
+    // opaqueChildren field will be filled with empty region in
+    // case the widget is hidden (because all the opaque children
+    // will be skipped in isVisible() check).
+    //
+    const bool oldDirtyOpaqueChildren = d->dirtyOpaqueChildren;
+
     const bool inRenderWithPainter = d->extra && d->extra->inRenderWithPainter;
     const QRegion toBePainted = !inRenderWithPainter ? d->prepareToRender(sourceRegion, renderFlags)
                                                      : sourceRegion;
@@ -5151,6 +5162,10 @@ void QWidget::render(QPainter *painter, const QPoint &targetOffset,
     if (!inRenderWithPainter && (opacity < 1.0 || (target->devType() == QInternal::Printer))) {
         d->render_helper(painter, targetOffset, toBePainted, renderFlags);
         d->extra->inRenderWithPainter = inRenderWithPainter;
+
+        // Patch: save and restore dirtyOpaqueChildren field.
+        d->dirtyOpaqueChildren = oldDirtyOpaqueChildren;
+
         return;
     }
 
@@ -5183,6 +5198,9 @@ void QWidget::render(QPainter *painter, const QPoint &targetOffset,
     d->setSharedPainter(oldPainter);
 
     d->extra->inRenderWithPainter = inRenderWithPainter;
+
+    // Patch: save and restore dirtyOpaqueChildren field.
+    d->dirtyOpaqueChildren = oldDirtyOpaqueChildren;
 }
 
 static void sendResizeEvents(QWidget *target)
diff --git a/src/widgets/widgets/qabstractscrollarea.cpp b/src/widgets/widgets/qabstractscrollarea.cpp
index d741a70d54..545894d891 100644
--- a/src/widgets/widgets/qabstractscrollarea.cpp
+++ b/src/widgets/widgets/qabstractscrollarea.cpp
@@ -535,15 +535,14 @@ scrolling range.
 QSize QAbstractScrollArea::maximumViewportSize() const
 {
     Q_D(const QAbstractScrollArea);
-    int hsbExt = d->hbar->sizeHint().height();
-    int vsbExt = d->vbar->sizeHint().width();
 
     int f = 2 * d->frameWidth;
     QSize max = size() - QSize(f + d->left + d->right, f + d->top + d->bottom);
+    // Patch: Count the sizeHint of the bar only if it is displayed.
     if (d->vbarpolicy == Qt::ScrollBarAlwaysOn)
-        max.rwidth() -= vsbExt;
+        max.rwidth() -= d->vbar->sizeHint().width();
     if (d->hbarpolicy == Qt::ScrollBarAlwaysOn)
-        max.rheight() -= hsbExt;
+        max.rheight() -= d->hbar->sizeHint().height();
     return max;
 }
 
-- 
2.40.0.windows.1

